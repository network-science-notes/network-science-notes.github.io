[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Network Science: Models, Mathematics, and Computation",
    "section": "",
    "text": "Welcome\nThis is a set of notes developed for an undergraduate course in network science. The target audience for these notes are undergraduates in mathematics and computer science who have completed courses in linear algebra, discrete mathematics, and programming.\nThese notes are a collaborative project between Dr. Heather Zinn Brooks (Department of Mathematics, Harvey Mudd College) and Dr. Phil Chodrow (Department of Computer Science, Middlebury College).",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#pedagogical-features",
    "href": "index.html#pedagogical-features",
    "title": "Network Science: Models, Mathematics, and Computation",
    "section": "Pedagogical Features",
    "text": "Pedagogical Features\nThese notes are explicitly designed for undergraduate instruction with students who are interested in and fluent in both mathematics and computation. For this reason:\n\nComputational examples are integrated into the text and shown throughout.\nLive versions of lecture notes are supplied as Jupyter Notebooks which can be opened in Google Colab. Certain code components have been removed. The purpose is to facilitate live-coding in lectures.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#use-and-reuse",
    "href": "index.html#use-and-reuse",
    "title": "Network Science: Models, Mathematics, and Computation",
    "section": "Use and Reuse",
    "text": "Use and Reuse\nThese notes are free to reuse and adapt for educational purposes. Attribution is appreciated but not required.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#source-texts",
    "href": "index.html#source-texts",
    "title": "Network Science: Models, Mathematics, and Computation",
    "section": "Source Texts",
    "text": "Source Texts\nThese notes draw on several source texts, the most important of which is Newman (2018).",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#acknowledgements",
    "href": "index.html#acknowledgements",
    "title": "Network Science: Models, Mathematics, and Computation",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nThis site was generated using the Quarto publishing system. It is hosted on GitHub and published via GitHub Pages. We thank Mason Porter for inspiration in earlier versions of this course.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#references",
    "href": "index.html#references",
    "title": "Network Science: Models, Mathematics, and Computation",
    "section": "References",
    "text": "References\n\n\n\n\nNewman, Mark. 2018. Networks. Oxford University Press.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "chapters/01-networkrepresentations.html",
    "href": "chapters/01-networkrepresentations.html",
    "title": "1  Networks and their representations",
    "section": "",
    "text": "Introductory Graph Terminology\nWe’ll begin by introducing some terminology for types of graphs we may encounter.",
    "crumbs": [
      "Network Fundamentals",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Networks and their representations</span>"
    ]
  },
  {
    "objectID": "chapters/01-networkrepresentations.html#introductory-graph-terminology",
    "href": "chapters/01-networkrepresentations.html#introductory-graph-terminology",
    "title": "1  Networks and their representations",
    "section": "",
    "text": "Simple graphs\n\n\n\n\n\n\n\nDefinition 1.2 Edges that connect nodes to themselves are called self-edges or self-loops.\nIf there is more than one edge between the same two nodes, this is called a multiedge. A network with multiedges is called a multigraph.\n\n\n\n\n\n\nShow code\nfrom matplotlib import pyplot as plt\nimport networkx as nx\nplt.style.use('seaborn-v0_8-whitegrid')\n\n\nG = nx.Graph()\nedgelist = [(1, 4), (2, 5), (3, 5), (4, 5), (5, 6)]\nG.add_edges_from(edgelist)\nnx.draw(G)\n\n\n\n\n\n\n\n\nFigure 1.2: A simple graph with 6 nodes and 5 edges.\n\n\n\n\n\n\n\n\n\n\n\n\nDefinition 1.3 A network that has neither self-edges nor multiedges is called a simple graph or simple network.\n\n\n\n\nMany of the networks we’ll study this semester will be simple graphs.\n\n\nShow code\nfrom matplotlib import pyplot as plt\nimport networkx as nx\nplt.style.use('seaborn-v0_8-whitegrid')\n\n\nG = nx.Graph()\nG.add_edges_from([(1, 4), (2, 4), (3, 3), (3, 4)])\nnx.draw(G)\n\n\n\n\n\n\n\n\nFigure 1.3: A graph with self-edges.\n\n\n\n\n\n\n\nPlanar graphs\n\n\n\n\n\n\n\nDefinition 1.4 A planar graph is a graph that can be embedded in the plane without having any edges cross.\n\n\n\n\nPlanar graphs are commonly studied objects in graph theory and there are many cool theorems about them (see, for example, the four-color theorem or Kuratowski’s theorem). This means that a network that can be represented with a planar graph can leverage this theory.\n\n\nDirected graphs\nIn this course, we will spend much of our time focused on the analysis of undirected graphs, where an edge between nodes \\(i\\) and \\(j\\) is an unordered pair \\(\\{i,j\\}\\). However, there is an extension that can be important in many modeling contexts where there may be an edge from \\(j\\) to \\(i\\), but no edge from \\(i\\) to \\(j\\). This is called a directed graph. Informally, each edge in a directed graph has a direction, pointing from one node to another. Directed edges are usually represented by lines with arrows.\n\n\n\n\n\n\n\nDefinition 1.5 A directed graph (also called a directed network or digraph) is a graph in which each edge is an ordered pair \\((j, i)\\), which indicates an edge from node \\(j\\) to node \\(i\\). Such edges are called directed edges (or arcs).\n\n\n\n\n\n\nShow code\nfrom matplotlib import pyplot as plt\nimport networkx as nx\nplt.style.use('seaborn-v0_8-whitegrid')\n\n\nDG = nx.DiGraph()\nDG.add_edges_from([(1, 2), (1, 3), (3, 4), (4, 1)])\n\nnx.draw(DG, with_labels = True, arrowsize = 20, font_color = 'white', font_weight = 'bold')\n\n\n\n\n\n\n\n\nFigure 1.4: A directed graph. We’ve chosen some arbitrary node labels for mathematical encoding later on in the notes.",
    "crumbs": [
      "Network Fundamentals",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Networks and their representations</span>"
    ]
  },
  {
    "objectID": "chapters/01-networkrepresentations.html#matrix-representations-of-graphs",
    "href": "chapters/01-networkrepresentations.html#matrix-representations-of-graphs",
    "title": "1  Networks and their representations",
    "section": "Matrix Representations of Graphs",
    "text": "Matrix Representations of Graphs\nOne reason that graphs are particularly useful mathematical representations of networks is that they can be encoded with matrices. This is a huge advantage, because we’ll be able to leverage a lot of theory we know from linear algebra.\nFor our definitions below, we’ll suppose we have a graph \\(G\\) with \\(n\\) vertices.We take the convention that the directed edge \\((j, i)\\) is an edge from \\(j\\) to \\(i\\). Notice that \\((j, i)\\) is represented in the \\(i\\)th row and the \\(j\\)th column of the adjacency matrix. As with so many things in math, this notation is a choice made for mathematical convenience. This choice also allows us to align with both the Newman (2018) textbook and NetworkX syntax. Be aware that different authors and sources might make a different choice!\n\nAdjacency matrix\n\n\n\n\n\n\n\nDefinition 1.6 The adjacency matrix \\(A\\) of a graph \\(G = (V, E)\\) is an \\(n \\times n\\) matrix where \\(n = \\vert V \\vert\\). Its entries are \\[\\begin{align*}\n    A_{ij} = \\begin{cases}\n    1 & (j, i) \\in E \\,, \\\\\n    0 & \\text{otherwise.}\n    \\end{cases}\n\\end{align*}\\]\n\n\n\n\nWe can make a few observations about how the graph structure relates to the structure of the adjacency matrix.\n\nIf there are no self-edges, the diagonal elements are all zero.\nIf the network is undirected, then an edge between \\(i\\) and \\(j\\) implies the existence of an edge between \\(j\\) and \\(i\\). This means that \\(A_{ji} = A_{ij}\\) and thus the adjacency matrix is symmetric.\nSimilarly, if the adjacency matrix is not symmetric, the network cannot be undirected.\n\n\nExample. The adjacency matrix for the graph in Figure 1.4 is \\[\n\\begin{pmatrix}\n0 & 0 & 0 & 1 \\\\\n1 & 0 & 0 & 0 \\\\\n1 & 0 & 0 & 0 \\\\\n0 & 0 & 1 & 0\n\\end{pmatrix}\n\\]\n\nIf we have a graph with self-edges, then \\(\\{i,i\\} \\in E\\) for some \\(i.\\) If the graph is undirected, we represent this in the adjacency matrix by setting \\(A_{ii} = 2.\\) If the graph is directed, we set \\(A_{ii} = 1.\\)This is another convention that will make the mathematics easier. An intuitive way to understand this choice is that, in undirected graphs, every edge “shows up” twice in the adjacency matrix, whereas in directed graphs every edge “shows up” once.\nIf we have a graph with multiedges, then we can set the corresponding matrix element \\(A_{ij}\\) equal to the multiplicity of the edge. For example, a double edge between nodes 2 and 3 in an undirected graph is represented \\(A_{23} = A_{32} = 2.\\)\nBut why stop there? Instead of requiring an integer number of edges between two nodes, we could extend this idea to form weighted networks with real-valued edge weights. Sometimes it is useful to represent edges as having a strength, weight, or value. In this situation, we set the value of \\(A_{ij}\\) equal to the weight of the corresponding edge \\((j, i)\\). For example, weights in an airport network could be used represent a distance between two airports, or weights in a social media network could represent the number of messages sent between two individuals.\n\n\nMany more matrices …\nThere are LOTS of matrices that can be associated to networks. There’s no “right” one — some are more useful than others for certain jobs. Throughout this course, we’ll see examples of matrices that are well-suited to certain specific tasks, like ranking or clustering. If you’re interested in searching around a bit, some other fun matrices are:\n\nThe graph Laplacian matrix and its variants.\nThe nonbacktracking or Hashimoto matrix.\nThe modularity matrix.\nThe random-walk transition matrix.\nThe PageRank matrix.\nThe node-edge incidence matrix.\n\nAnd the list goes on!",
    "crumbs": [
      "Network Fundamentals",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Networks and their representations</span>"
    ]
  },
  {
    "objectID": "chapters/01-networkrepresentations.html#graphs-in-networkx",
    "href": "chapters/01-networkrepresentations.html#graphs-in-networkx",
    "title": "1  Networks and their representations",
    "section": "Graphs in NetworkX",
    "text": "Graphs in NetworkX\nIn this class, we will also be studying networks from a computational perspective. We will be using the NetworkX package in Python.\n\nCreating networks\nWe can create an empty undirected graph \\(G\\) using G = nx.Graph(). You could instead create an empty directed graph using nx.DiGraph() or an empty multigraph using nx.MultiGraph().\nThere are multiple ways to grow your graph in NetworkX.\n\nAdding nodes or edges manually\nYou can add one node at a time. For example,\n\nG.add_node(1)\n\nwill add a node with the label 1. We use an integer here, but a node can be any hashable Python object. You can add one edge at a time using tuples of nodes\n\nG.add_edge(1, 2)\n\nIf you create an edge connecting to a node that’s not in your graph yet, the node gets created automatically.\nIn most cases it’s pretty inefficient to add one node or edge at a time. Fortunately, you can also add nodes and edges from a list or any other iterable container:\n\nG.add_nodes_from(nodelist)\n\n\nG.add_edges_from(edgelist)\n\nThere are corresponding methods to remove nodes and edges: G.remove_node(), G.remove_edge(), G.remove_nodes_from(), G.remove_edges_from().\n\n\nCreating a graph dictionary\nYou can also build your graph using a dictionary that maps nodes to neighbors. The code below creates a graph with 3 nodes, where nodes 1 and 3 are both connected to node 2, but not to each other.\n\n\nShow code\nfrom matplotlib import pyplot as plt\nimport networkx as nx\nplt.style.use('seaborn-v0_8-whitegrid')\n\ngraph_dict = {1: [2], 2: [1, 3], 3:[2]}\nG = nx.Graph(graph_dict) \nnx.draw(G)\n\n\n\n\n\n\n\n\nFigure 1.5: A network built using a dictionary that maps nodes to neighbors.\n\n\n\n\n\n\n\nUsing an adjacency matrix\nYou can directly create a graph using a numpy array that encodes your adjacency matrix representation for your graph. The three-node example above has the adjacency matrix \\[\n\\begin{pmatrix}\n    0 & 1 & 0 \\\\\n    1 & 0 & 1 \\\\\n    0 & 1 & 0\n\\end{pmatrix}\n\\]\nwhich can be encoded after importing the numpy package as np as follows:\n\nA = np.array([[0, 1, 0], [1, 0, 0], [0, 1, 0]])\n\nYou can then quickly build an undirected graph \\(G\\) with\n\nG = nx.from_numpy_array(A)\n\nFor a directed graph, you need to make two additional changes to the code above. You need specify that you want a directed graph with create_using. Additionally, you need to be very careful about the adjacency matrix convention for in and out edges. The default convention for from_numpy_array points edges in the opposite direction to what we defined above (it assumes \\(A_{ij} = 1\\) if \\((i,j) \\in E\\)), so if you want to match that convention, you’ll need to take the transpose with np.transpose.\n\nG = nx.from_numpy_array(np.transpose(A), create_using = nx.DiGraph)\n\n\n\n\nVisualizing your networks\nYou can use the matplotlib plot interface to draw your network. If you have created a graph \\(G\\), you can quickly visualize it using\n\nnx.draw(G)\n\nThere are lots of fun ways to customize your figure, including changing colors, sizes, adding labels, and more. See the documentation for details.\nPractice with the following exercises:\n\nUsing NetworkX to reproduce Figure 1.2, Figure 1.3, Figure 1.4. Use at least two of the different methods described above.\nDraw the network represented by the adjacency matrix \\[\n\\begin{pmatrix}\n  0 & 1 & 0 & 0 & 1 \\\\\n  1 & 0 & 0 & 1 & 1 \\\\\n  0 & 0 & 0 & 1 & 0 \\\\\n  1 & 0 & 0 & 0 & 0 \\\\\n  1 & 0 & 0 & 0 & 0\n\\end{pmatrix} \\,.\n\\]\nCreate your own network.\n\n\n\nShow code\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport networkx as nx\nplt.style.use('seaborn-v0_8-whitegrid')\n\n\n# Use NetworkX to reproduce the figures from the notes.\n# Then, create and visualize the network represented by the given adjacency matrix.\n# Finally, create your own network.\n# This is left as a coding exercise in the live notes.\n\n\nA = np.array([[0, 1, 0, 0, 1], [1, 0, 0, 1, 1], [0, 0, 0, 1, 0], [1, 0, 0, 0, 0], [1, 0, 0, 0, 0]])\nG = nx.from_numpy_array(np.transpose(A), create_using = nx.DiGraph)\nnx.draw(G, with_labels = True, arrowsize = 20, font_color = 'white', font_weight = 'bold')\n\n\n\n\n\n\n\n\nFigure 1.6: The network corresponding to the adjacency matrix given in the exercise.",
    "crumbs": [
      "Network Fundamentals",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Networks and their representations</span>"
    ]
  },
  {
    "objectID": "chapters/01-networkrepresentations.html#references",
    "href": "chapters/01-networkrepresentations.html#references",
    "title": "1  Networks and their representations",
    "section": "References",
    "text": "References\n\n\n\n\nNewman, Mark. 2018. Networks. Oxford University Press.\n\n\nZachary, Wayne W. 1977. “An Information Flow Model for Conflict and Fission in Small Groups.” Journal of Anthropological Research 33 (4): 452–73.",
    "crumbs": [
      "Network Fundamentals",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Networks and their representations</span>"
    ]
  }
]