<!DOCTYPE html>

<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><head>
<meta charset="utf-8"/>
<meta content="quarto-1.6.10" name="generator"/>
<meta content="width=device-width, initial-scale=1.0, user-scalable=yes" name="viewport"/>
<title>8  Degree-Preserving Random Graphs – Network Science: Models, Mathematics, and Computation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>
<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta content="../" name="quarto:offset"/>
<link href="../chapters/11-generating-functions.html" rel="next"/>
<link href="../chapters/09-random-graphs.html" rel="prev"/>
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet"/>
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-2d9718c933debafcce942f9b212640bc.css" id="quarto-text-highlighting-styles" rel="stylesheet"/>
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet"/>
<link append-hash="true" data-mode="light" href="../site_libs/bootstrap/bootstrap-c1bdd270c1c0708cd2ff05417efafcc5.min.css" id="quarto-bootstrap" rel="stylesheet"/>
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>
<link href="../styles.css" rel="stylesheet"/>
</head>
<body class="nav-sidebar floating slimcontent">
<div id="quarto-search-results"></div>
<header class="headroom fixed-top" id="quarto-header">
<nav class="quarto-secondary-nav">
<div class="container-fluid d-flex">
<button aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" class="quarto-btn-toggle btn" data-bs-target=".quarto-sidebar-collapse-item" data-bs-toggle="collapse" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }" role="button" type="button">
<i class="bi bi-layout-text-sidebar-reverse"></i>
</button>
<nav aria-label="breadcrumb" class="quarto-page-breadcrumbs"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../chapters/09-random-graphs.html">Models of Networks</a></li><li class="breadcrumb-item"><a href="../chapters/10-configuration-model.html"><span class="chapter-number">8</span>  <span class="chapter-title">Degree-Preserving Random Graphs</span></a></li></ol></nav>
<a aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" class="flex-grow-1" data-bs-target=".quarto-sidebar-collapse-item" data-bs-toggle="collapse" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }" role="navigation">
</a>
</div>
</nav>
</header>
<!-- content -->
<div class="quarto-container page-columns page-rows-contents page-layout-article" id="quarto-content">
<!-- sidebar -->
<nav class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto" id="quarto-sidebar">
<div class="pt-lg-2 mt-2 text-left sidebar-header">
<div class="sidebar-title mb-0 py-0">
<a href="../">Network Science: Models, Mathematics, and Computation</a>
</div>
</div>
<div class="sidebar-menu-container">
<ul class="list-unstyled mt-1">
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../index.html">
<span class="menu-text">Welcome</span></a>
</div>
</li>
<li class="sidebar-item sidebar-item-section">
<div class="sidebar-item-container">
<a aria-expanded="true" class="sidebar-item-text sidebar-link text-start" data-bs-target="#quarto-sidebar-section-1" data-bs-toggle="collapse" role="navigation">
<span class="menu-text">Network Fundamentals</span></a>
<a aria-expanded="true" aria-label="Toggle section" class="sidebar-item-toggle text-start" data-bs-target="#quarto-sidebar-section-1" data-bs-toggle="collapse" role="navigation">
<i class="bi bi-chevron-right ms-2"></i>
</a>
</div>
<ul class="collapse list-unstyled sidebar-section depth1 show" id="quarto-sidebar-section-1">
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/01-networkrepresentations.html">
<span class="menu-text"><span class="chapter-number">1</span>  <span class="chapter-title">Networks and Their Representations</span></span></a>
</div>
</li>
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/02-degree-walks-paths.html">
<span class="menu-text"><span class="chapter-number">2</span>  <span class="chapter-title">Degree, Walks, and Paths</span></span></a>
</div>
</li>
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/03-components-laplacian.html">
<span class="menu-text"><span class="chapter-number">3</span>  <span class="chapter-title">Components and the Graph Laplacian</span></span></a>
</div>
</li>
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/04-centrality.html">
<span class="menu-text"><span class="chapter-number">4</span>  <span class="chapter-title">Centrality and Importance</span></span></a>
</div>
</li>
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/05-viz.html">
<span class="menu-text"><span class="chapter-number">5</span>  <span class="chapter-title">Visualizing Networks and Why You Shouldn’t</span></span></a>
</div>
</li>
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/07-real-world.html">
<span class="menu-text"><span class="chapter-number">6</span>  <span class="chapter-title">Structure of Empirical Networks</span></span></a>
</div>
</li>
</ul>
</li>
<li class="sidebar-item sidebar-item-section">
<div class="sidebar-item-container">
<a aria-expanded="true" class="sidebar-item-text sidebar-link text-start" data-bs-target="#quarto-sidebar-section-2" data-bs-toggle="collapse" role="navigation">
<span class="menu-text">Models of Networks</span></a>
<a aria-expanded="true" aria-label="Toggle section" class="sidebar-item-toggle text-start" data-bs-target="#quarto-sidebar-section-2" data-bs-toggle="collapse" role="navigation">
<i class="bi bi-chevron-right ms-2"></i>
</a>
</div>
<ul class="collapse list-unstyled sidebar-section depth1 show" id="quarto-sidebar-section-2">
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/09-random-graphs.html">
<span class="menu-text"><span class="chapter-number">7</span>  <span class="chapter-title">Random Graphs: Erdős–Rényi</span></span></a>
</div>
</li>
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link active" href="../chapters/10-configuration-model.html">
<span class="menu-text"><span class="chapter-number">8</span>  <span class="chapter-title">Degree-Preserving Random Graphs</span></span></a>
</div>
</li>
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/11-generating-functions.html">
<span class="menu-text"><span class="chapter-number">9</span>  <span class="chapter-title">Probability Generating Functions</span></span></a>
</div>
</li>
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/120-preferential-attachment.html">
<span class="menu-text"><span class="chapter-number">10</span>  <span class="chapter-title">Preferential Attachment and Power Laws</span></span></a>
</div>
</li>
</ul>
</li>
<li class="sidebar-item sidebar-item-section">
<div class="sidebar-item-container">
<a aria-expanded="true" class="sidebar-item-text sidebar-link text-start" data-bs-target="#quarto-sidebar-section-3" data-bs-toggle="collapse" role="navigation">
<span class="menu-text">Network Algorithms</span></a>
<a aria-expanded="true" aria-label="Toggle section" class="sidebar-item-toggle text-start" data-bs-target="#quarto-sidebar-section-3" data-bs-toggle="collapse" role="navigation">
<i class="bi bi-chevron-right ms-2"></i>
</a>
</div>
<ul class="collapse list-unstyled sidebar-section depth1 show" id="quarto-sidebar-section-3">
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/06-modularity.html">
<span class="menu-text"><span class="chapter-number">11</span>  <span class="chapter-title">Homophily, Assortativity, and Modularity</span></span></a>
</div>
</li>
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/13-modularity-maximization.html">
<span class="menu-text"><span class="chapter-number">12</span>  <span class="chapter-title">Community Detection and Modularity Maximization</span></span></a>
</div>
</li>
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/19-spectral-clustering.html">
<span class="menu-text"><span class="chapter-number">13</span>  <span class="chapter-title">Spectral Clustering</span></span></a>
</div>
</li>
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/41-link-prediction.html">
<span class="menu-text"><span class="chapter-number">14</span>  <span class="chapter-title">Link Prediction and Feedback Loops</span></span></a>
</div>
</li>
</ul>
</li>
<li class="sidebar-item sidebar-item-section">
<div class="sidebar-item-container">
<a aria-expanded="true" class="sidebar-item-text sidebar-link text-start" data-bs-target="#quarto-sidebar-section-4" data-bs-toggle="collapse" role="navigation">
<span class="menu-text">Applications and Extensions</span></a>
<a aria-expanded="true" aria-label="Toggle section" class="sidebar-item-toggle text-start" data-bs-target="#quarto-sidebar-section-4" data-bs-toggle="collapse" role="navigation">
<i class="bi bi-chevron-right ms-2"></i>
</a>
</div>
<ul class="collapse list-unstyled sidebar-section depth1 show" id="quarto-sidebar-section-4">
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/50-random-walks.html">
<span class="menu-text"><span class="chapter-number">15</span>  <span class="chapter-title">Random Walks</span></span></a>
</div>
</li>
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/51-agent-based-modeling.html">
<span class="menu-text"><span class="chapter-number">16</span>  <span class="chapter-title">Agent-Based Modeling on Networks</span></span></a>
</div>
</li>
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/53-epidemiology-computational.html">
<span class="menu-text"><span class="chapter-number">17</span>  <span class="chapter-title">Agent-Based Models of Epidemics on Networks</span></span></a>
</div>
</li>
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/52-epidemiology.html">
<span class="menu-text"><span class="chapter-number">18</span>  <span class="chapter-title">Epidemic Models on Networks</span></span></a>
</div>
</li>
</ul>
</li>
<li class="sidebar-item sidebar-item-section">
<span class="sidebar-item-text sidebar-link text-start">
<span class="menu-text">Appendices</span></span>
</li>
</ul>
</div>
</nav>
<div class="quarto-sidebar-collapse-item" data-bs-target=".quarto-sidebar-collapse-item" data-bs-toggle="collapse" id="quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
<div class="sidebar margin-sidebar" id="quarto-margin-sidebar">
<nav class="toc-active" id="TOC" role="doc-toc">
<h2 id="toc-title">Contents</h2>
<ul>
<li><a class="nav-link active" data-scroll-target="#fixing-a-degree-sequence-the-configuration-model" href="#fixing-a-degree-sequence-the-configuration-model" id="toc-fixing-a-degree-sequence-the-configuration-model">Fixing a Degree Sequence: The Configuration Model</a>
<ul class="collapse">
<li><a class="nav-link" data-scroll-target="#sampling-from-configuration-models" href="#sampling-from-configuration-models" id="toc-sampling-from-configuration-models">Sampling From Configuration Models</a></li>
</ul></li>
<li><a class="nav-link" data-scroll-target="#expected-degree-sequences-the-chunglu-model" href="#expected-degree-sequences-the-chunglu-model" id="toc-expected-degree-sequences-the-chunglu-model">Expected Degree Sequences: The Chung–Lu Model</a></li>
<li><a class="nav-link" data-scroll-target="#fixed-degree-distributions" href="#fixed-degree-distributions" id="toc-fixed-degree-distributions">Fixed Degree Distributions</a></li>
<li><a class="nav-link" data-scroll-target="#excess-degree-distribution" href="#excess-degree-distribution" id="toc-excess-degree-distribution">Excess Degree Distribution</a>
<ul class="collapse">
<li><a class="nav-link" data-scroll-target="#the-friendship-paradox" href="#the-friendship-paradox" id="toc-the-friendship-paradox">The Friendship Paradox</a></li>
</ul></li>
<li><a class="nav-link" data-scroll-target="#references" href="#references" id="toc-references">References</a></li>
</ul>
</nav>
</div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">
<header class="quarto-title-block default" id="title-block-header"><nav aria-label="breadcrumb" class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../chapters/09-random-graphs.html">Models of Networks</a></li><li class="breadcrumb-item"><a href="../chapters/10-configuration-model.html"><span class="chapter-number">8</span>  <span class="chapter-title">Degree-Preserving Random Graphs</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">8</span>  <span class="chapter-title">Degree-Preserving Random Graphs</span></h1>
</div>
<div class="quarto-title-meta">
</div>
</header>
<!-- PC NOTE: MAYBE DO SOME COMPUTATIONAL VALIDATION OF THE APPROXIMATION k_ik_j/2m? -->
<p><em>Open the live notebook in Google Colab <a href="https://colab.research.google.com/github/network-science-notes/network-science-notes.github.io/blob/main/docs/live-notebooks/10-configuration-model.ipynb">here</a>.</em></p>
<p>Many properties of graphs are at least partially determined by the degree sequence of the graph. As we saw in <a href="../chapters/04-centrality.html">our discussion of centrality</a>, for example, the centrality of a node is highly-correlated to its degree. As we’ll see later in these notes, the degree sequence also plays a major role in determining whether, for example, an epidemic can spread on a network. On the other hand, not all properties of graphs are so constrained by the degree sequence. For example, when we studied the <a href="../chapters/07-real-world.html">structure of empirical networks</a>, we saw that the density of triangles (as measured by the transitivity) varies strongly between real-world networks and their degree-preserving random counterparts.</p>
<p>So, which properties of a graph are controlled by the degree sequence? One way to approach this problem is to study models of random graphs in which the degree sequence is held constant, either exactly or approximately. In this set of notes, we’ll introduce several such models and develop some of their properties.</p>
<section class="level2 page-columns page-full" id="fixing-a-degree-sequence-the-configuration-model">
<h2 class="anchored" data-anchor-id="fixing-a-degree-sequence-the-configuration-model">Fixing a Degree Sequence: The Configuration Model</h2>
<p>In the configuration model, we choose a degree sequence. We then attempt to generate a random graph that has <em>exactly</em> that degree sequence.</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div class="theorem definition" id="def-config-model-sequence">
<p><span class="theorem-title"><strong>Definition 8.1 (Configuration Model)</strong></span> Consider a graph with <span class="math inline">\(n\)</span> nodes. Let <span class="math inline">\({\bf k} \in \mathbb{N}^n\)</span> be the degree sequence, where <span class="math inline">\(k_i\)</span> is the degree of node <span class="math inline">\(i\)</span>.</p>
<p>A <strong>configuration model</strong> is a uniform distribution over graphs with degree sequence <span class="math inline">\({\bf k}.\)</span></p>
</div>
</div>
</div>
</div>
<p>It’s not guaranteed that it is always possible to generate a graph with degree sequence <span class="math inline">\(\mathbf{k}\)</span>.</p>
<div class="callout callout-style-simple callout-important no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercise
</div>
</div>
<div class="callout-body-container callout-body">
<p>Give a necessary condition on <span class="math inline">\(\sum_{i = 1}^n k_i\)</span> for it to be possible to form a graph with degree sequence <span class="math inline">\(\mathbf{k}\)</span>.</p>
</div>
</div>
<p>In fact, it is possible to give a complete characterization of the degree sequences <span class="math inline">\(\mathbf{k}\)</span> which can be realized as simple undirected graphs; this characterization is given by the <a href="https://en.wikipedia.org/wiki/Erd%C5%91s%E2%80%93Gallai_theorem">Erdős-Gallai theorem</a> <span class="citation" data-cites="erdos1960graphs">(<a href="#ref-erdos1960graphs" role="doc-biblioref">Erdös and Gallai 1960</a>)</span>.</p>
<section class="level3 page-columns page-full" id="sampling-from-configuration-models">
<h3 class="anchored" data-anchor-id="sampling-from-configuration-models">Sampling From Configuration Models</h3>
<p>It’s surprisingly complicated to draw a sample from a configuration model random graph. We can draw <em>approximate</em> samples from the configuration model using the <em>stub-matching</em> algorithm.</p>
<p>In stub-matching, we create a list of “stubs,” or half-edges. Each node <span class="math inline">\(i\)</span> with degree <span class="math inline">\(k_i\)</span> appears in this list <span class="math inline">\(k_i\)</span> times. We form edges by picking two stubs at a time out of the list and forming an edge between them. Let’s implement this stub-matching algorithm. Before we do, we’ll load in our favorite example graph and extract its degree sequence.</p>
<div class="cell page-columns page-full" data-execution_count="1" id="cell-fig-karate-club-degree-sequence">
<details class="code-fold">
<summary>Show code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a aria-hidden="true" href="#cb1-1" tabindex="-1"></a><span class="im">import</span> networkx <span class="im">as</span> nx</span>
<span id="cb1-2"><a aria-hidden="true" href="#cb1-2" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a aria-hidden="true" href="#cb1-3" tabindex="-1"></a><span class="im">from</span> matplotlib <span class="im">import</span> pyplot <span class="im">as</span> plt</span>
<span id="cb1-4"><a aria-hidden="true" href="#cb1-4" tabindex="-1"></a>plt.style.use(<span class="st">'seaborn-v0_8-whitegrid'</span>)</span>
<span id="cb1-5"><a aria-hidden="true" href="#cb1-5" tabindex="-1"></a>plot_kwargs <span class="op">=</span> {<span class="st">"node_size"</span> : <span class="dv">100</span>, <span class="st">"edgecolors"</span> : <span class="st">'white'</span>, <span class="st">"node_color"</span> : <span class="st">"steelblue"</span>, <span class="st">"width"</span> : <span class="fl">0.5</span>, <span class="st">"edge_color"</span> : <span class="st">"darkgrey"</span>}</span>
<span id="cb1-6"><a aria-hidden="true" href="#cb1-6" tabindex="-1"></a></span>
<span id="cb1-7"><a aria-hidden="true" href="#cb1-7" tabindex="-1"></a></span>
<span id="cb1-8"><a aria-hidden="true" href="#cb1-8" tabindex="-1"></a>G_Karate <span class="op">=</span> nx.karate_club_graph()</span>
<span id="cb1-9"><a aria-hidden="true" href="#cb1-9" tabindex="-1"></a>deg_seq <span class="op">=</span> [k <span class="cf">for</span> n, k <span class="kw">in</span> G_Karate.degree()]</span>
<span id="cb1-10"><a aria-hidden="true" href="#cb1-10" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>, figsize <span class="op">=</span> (<span class="dv">4</span>, <span class="dv">3</span>))</span>
<span id="cb1-11"><a aria-hidden="true" href="#cb1-11" tabindex="-1"></a>ax.scatter(np.arange(<span class="dv">0</span>, <span class="bu">len</span>(deg_seq)), np.sort(deg_seq),  s <span class="op">=</span> <span class="dv">10</span>)</span>
<span id="cb1-12"><a aria-hidden="true" href="#cb1-12" tabindex="-1"></a>labs <span class="op">=</span> ax.<span class="bu">set</span>(xlabel <span class="op">=</span> <span class="st">"Node (sorted by degree)"</span>, ylabel <span class="op">=</span> <span class="st">"Degree"</span>, title <span class="op">=</span> <span class="st">"Karate Club Degree Sequence"</span>)</span></code><button class="code-copy-button" title="Copy to Clipboard"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display page-columns page-full">
<div class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full" id="fig-karate-club-degree-sequence">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-karate-club-degree-sequence-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img class="figure-img" height="294" src="10-configuration-model_files/figure-html/fig-karate-club-degree-sequence-output-1.png" width="365"/>
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-fig margin-caption" id="fig-karate-club-degree-sequence-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure 8.1: Sorted degree sequence of the karate club graph.
</figcaption>
</figure>
</div>
</div>
</div>
<p>Now we’ll implement an algorithm to perform stub-matching. First, we create the list of stubs. Each node appears a number of times equal to its degree.</p>
<div class="cell" data-execution_count="2" id="6902f596">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a aria-hidden="true" href="#cb2-1" tabindex="-1"></a>stubs <span class="op">=</span> np.repeat(np.arange(<span class="bu">len</span>(deg_seq)), deg_seq)</span>
<span id="cb2-2"><a aria-hidden="true" href="#cb2-2" tabindex="-1"></a><span class="bu">print</span>(stubs)</span></code><button class="code-copy-button" title="Copy to Clipboard"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  1  1  1  1
  1  2  2  2  2  2  2  2  2  2  2  3  3  3  3  3  3  4  4  4  5  5  5  5
  6  6  6  6  7  7  7  7  8  8  8  8  8  9  9 10 10 10 11 12 12 13 13 13
 13 13 14 14 15 15 16 16 17 17 18 18 19 19 19 20 20 21 21 22 22 23 23 23
 23 23 24 24 24 25 25 25 26 26 27 27 27 27 28 28 28 29 29 29 29 30 30 30
 30 31 31 31 31 31 31 32 32 32 32 32 32 32 32 32 32 32 32 33 33 33 33 33
 33 33 33 33 33 33 33 33 33 33 33 33]</code></pre>
</div>
</div>
<p>Now we need to take random pairs from this list of stubs. We could do this with a loop, but another way is to shuffle the list and then reshape it into a list of pairs:</p>
<div class="cell" data-execution_count="3" id="c3937205">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a aria-hidden="true" href="#cb4-1" tabindex="-1"></a>mixed_stubs <span class="op">=</span> np.random.permutation(stubs)</span>
<span id="cb4-2"><a aria-hidden="true" href="#cb4-2" tabindex="-1"></a>edge_list <span class="op">=</span> mixed_stubs.reshape(<span class="bu">len</span>(mixed_stubs)<span class="op">//</span><span class="dv">2</span>, <span class="dv">2</span>)</span></code><button class="code-copy-button" title="Copy to Clipboard"><i class="bi"></i></button></pre></div>
</div>
<p>Now we can create a graph from our newly-constructed edge-list. Importantly, this graph might contain both self-loops and multi-edges, and so we need to use the <code>nx.MultiGraph</code> constructor.</p>
<div class="cell" data-execution_count="4" id="b5a074f5">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a aria-hidden="true" href="#cb5-1" tabindex="-1"></a>G <span class="op">=</span> nx.MultiGraph()</span>
<span id="cb5-2"><a aria-hidden="true" href="#cb5-2" tabindex="-1"></a>edges <span class="op">=</span> G.add_edges_from(edge_list)</span></code><button class="code-copy-button" title="Copy to Clipboard"><i class="bi"></i></button></pre></div>
</div>
<p>Here’s how our random graph compares to our original:</p>
<div class="cell page-columns page-full" data-execution_count="5" id="cell-fig-karate-stub-matching">
<details class="code-fold">
<summary>Show code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a aria-hidden="true" href="#cb6-1" tabindex="-1"></a>fig, axarr <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize <span class="op">=</span> (<span class="dv">6</span>, <span class="dv">3</span>))</span>
<span id="cb6-2"><a aria-hidden="true" href="#cb6-2" tabindex="-1"></a>axarr[<span class="dv">0</span>].<span class="bu">set</span>(title <span class="op">=</span> <span class="st">"Karate Club Graph"</span>)</span>
<span id="cb6-3"><a aria-hidden="true" href="#cb6-3" tabindex="-1"></a></span>
<span id="cb6-4"><a aria-hidden="true" href="#cb6-4" tabindex="-1"></a>pos <span class="op">=</span> nx.spring_layout(G_Karate)</span>
<span id="cb6-5"><a aria-hidden="true" href="#cb6-5" tabindex="-1"></a></span>
<span id="cb6-6"><a aria-hidden="true" href="#cb6-6" tabindex="-1"></a>nx.draw(G_Karate, pos, ax <span class="op">=</span> axarr[<span class="dv">0</span>], <span class="op">**</span>plot_kwargs)</span>
<span id="cb6-7"><a aria-hidden="true" href="#cb6-7" tabindex="-1"></a></span>
<span id="cb6-8"><a aria-hidden="true" href="#cb6-8" tabindex="-1"></a>nx.draw(G, pos, ax <span class="op">=</span> axarr[<span class="dv">1</span>], <span class="op">**</span>plot_kwargs)</span>
<span id="cb6-9"><a aria-hidden="true" href="#cb6-9" tabindex="-1"></a>axarr[<span class="dv">1</span>].<span class="bu">set</span>(title <span class="op">=</span> <span class="st">"Configuration Model Graph"</span>)</span></code><button class="code-copy-button" title="Copy to Clipboard"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display page-columns page-full">
<div class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full" id="fig-karate-stub-matching">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-karate-stub-matching-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img class="figure-img" height="260" src="10-configuration-model_files/figure-html/fig-karate-stub-matching-output-1.png" width="466"/>
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-fig margin-caption" id="fig-karate-stub-matching-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure 8.2: Original karate club graph alongside a random graph formed via stub-matching. The random graph has the same degree sequence, but also self-loops and multi-edges.
</figcaption>
</figure>
</div>
</div>
</div>
<p>The stub-matching algorithm can produce multiedges and self-loops, which can cause the graph to not be simple. However, <span class="citation" data-cites="bollobas1980probabilistic">Bollobás (<a href="#ref-bollobas1980probabilistic" role="doc-biblioref">1980</a>)</span> proved that, when the graph is sparse, the expected number of multi-edges and self-loops does not grow with network size. One can, as a result, show these structures are rare, and can often be ignored in arguments. In practical terms, we often discard the self-loops and multi-edges when constructing the graph; this results in the degree sequence no longer being <em>exactly</em> preserved, but the effect is u sually small.</p>
<p><span class="citation" data-cites="fosdick2018configuring">Fosdick et al. (<a href="#ref-fosdick2018configuring" role="doc-biblioref">2018</a>)</span> discuss the subtleties that arise due to whether we allow or disallow multiedges and self-loops and whether we choose to label stubs distinctly (as opposed to only labeling vertices). These choices result in different spaces of graphs from which we are sampling. If we want to sample a simple graph from a configuration model with exactly the specified degree sequence, stub-matching is no longer sufficient. Instead, we need to rely on edge-rewiring algorithms, which randomly swap edges between nodes of the graph to randomize the graph while ensuring that the degrees of nodes remain constant. NetworkX implements a version of such an algorithm. The user needs to specify how many rewiring steps should be performed.</p>
<div class="cell" data-execution_count="6" id="0d75cda2">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a aria-hidden="true" href="#cb7-1" tabindex="-1"></a>G <span class="op">=</span> nx.random_reference(G_Karate, connectivity <span class="op">=</span> <span class="va">False</span>, niter <span class="op">=</span> <span class="dv">1000</span>)</span></code><button class="code-copy-button" title="Copy to Clipboard"><i class="bi"></i></button></pre></div>
</div>
<p>Here’s how this looks:</p>
<div class="cell page-columns page-full" data-execution_count="7" id="cell-fig-karate-club-rewiring">
<details class="code-fold">
<summary>Show code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a aria-hidden="true" href="#cb8-1" tabindex="-1"></a>fig, axarr <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize <span class="op">=</span> (<span class="dv">6</span>, <span class="dv">3</span>))</span>
<span id="cb8-2"><a aria-hidden="true" href="#cb8-2" tabindex="-1"></a>axarr[<span class="dv">0</span>].<span class="bu">set</span>(title <span class="op">=</span> <span class="st">"Karate Club Graph"</span>)</span>
<span id="cb8-3"><a aria-hidden="true" href="#cb8-3" tabindex="-1"></a></span>
<span id="cb8-4"><a aria-hidden="true" href="#cb8-4" tabindex="-1"></a>nx.draw(G_Karate, pos, ax <span class="op">=</span> axarr[<span class="dv">0</span>], <span class="op">**</span>plot_kwargs)</span>
<span id="cb8-5"><a aria-hidden="true" href="#cb8-5" tabindex="-1"></a></span>
<span id="cb8-6"><a aria-hidden="true" href="#cb8-6" tabindex="-1"></a>nx.draw(G, pos, ax <span class="op">=</span> axarr[<span class="dv">1</span>], <span class="op">**</span>plot_kwargs)</span>
<span id="cb8-7"><a aria-hidden="true" href="#cb8-7" tabindex="-1"></a>axarr[<span class="dv">1</span>].<span class="bu">set</span>(title <span class="op">=</span> <span class="st">"Configuration Model </span><span class="ch">\n</span><span class="st">Graph (Rewiring)"</span>)</span></code><button class="code-copy-button" title="Copy to Clipboard"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display page-columns page-full">
<div class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full" id="fig-karate-club-rewiring">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-karate-club-rewiring-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img class="figure-img" height="277" src="10-configuration-model_files/figure-html/fig-karate-club-rewiring-output-1.png" width="466"/>
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-fig margin-caption" id="fig-karate-club-rewiring-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure 8.3: Karate club graph alongside a random graph formed by many successive rewirings. The random graph has the same degree sequence as the karate club graph and is simple, but is not guaranteed to be a uniform sample from the set of all such graphs.
</figcaption>
</figure>
</div>
</div>
</div>
<div class="page-columns page-full"><p>This algorithm is guaranteed not to produce multiedges or self-loops and therefore exactly preserves the degree sequence. However, it can be much slower to generate random graphs this way, and it is difficult to know how many iterations are necessary to ensure that the resulting graph is “random enough.” </p><div class="no-row-height column-margin column-container"><span class="margin-aside">Technically, the rewiring process creates a <em>Markov chain</em> on the space of graphs, and the question of whether the graph is “random enough” is a question about the <em>mixing time</em> of the Markov chain.</span></div></div>
</section>
</section>
<section class="level2 page-columns page-full" id="expected-degree-sequences-the-chunglu-model">
<h2 class="anchored" data-anchor-id="expected-degree-sequences-the-chunglu-model">Expected Degree Sequences: The Chung–Lu Model</h2>
<p>Some of the challenges with stub-matching arise from the requirement that we generate a graph with a specified degree sequence <span class="math inline">\({\bf k}.\)</span> <span class="citation" data-cites="chung2002connected">Chung and Lu (<a href="#ref-chung2002connected" role="doc-biblioref">2002</a>)</span> relax this constraint and generate networks whose degree sequences are <em>approximately</em> <span class="math inline">\({\bf k}\)</span> <em>in expectation</em>, which avoids some of these issues.</p>
<p>Suppose that we want to generate a graph with <span class="math inline">\(n\)</span> nodes where the degree of node <span class="math inline">\(i\)</span> is approximately equal to <span class="math inline">\(k_i\)</span>. We’ll again think with stubs: if node <span class="math inline">\(i\)</span> has degree <span class="math inline">\(k_i\)</span>, then it has <span class="math inline">\(k_i\)</span> stubs. There are a total of <span class="math inline">\(2m\)</span> stubs, of which <span class="math inline">\(k_i\)</span> are already attached to <span class="math inline">\(i\)</span>, so the number of stubs <span class="math inline">\(i\)</span> could attach to is <span class="math inline">\(2m-k_i\)</span>. Of these, <span class="math inline">\(k_j\)</span> are attached to node <span class="math inline">\(j\)</span>. So, the probability that a given stub of <span class="math inline">\(i\)</span> connects to node <span class="math inline">\(j\)</span> is approximately <span class="math inline">\(k_j/(2m-k_i)\)</span>, and there are <span class="math inline">\(k_i\)</span> such stubs: <span class="math display">\[
    \mathbb{P}(\text{node $i$ stub connects to node $j$}) = \frac{k_j}{2m-1} \approx \frac{k_j}{2m}
\]</span></p>
<p>for large <span class="math inline">\(m\)</span>. Summing over all <span class="math inline">\(k_i\)</span> stubs, we have</p>
<p><span class="math display">\[
\begin{aligned}
    \mathbb{E}[\text{number of edges between $i$ and $j$}] &amp;\approx \frac{k_ik_j}{2m} \,.
\end{aligned}
\]</span></p>
<p>So, we can place down a Poisson-distributed number of edges between <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> with mean <span class="math inline">\(k_ik_j/2m\)</span>. When <span class="math inline">\(k_ik_j \ll 2m\)</span>, this is very similar to placing down a single edge with probability <span class="math inline">\(k_ik_j/2m\)</span>; the probability of placing down two or more edges becomes very small.</p>
<div class="page-columns page-full"><p>We might notice that this feels a little similar to the <span class="math inline">\(G(n,p)\)</span> model, and in fact, this is by construction. The degree of node <span class="math inline">\(i\)</span> will be Poisson distributed with mean <span class="math inline">\(k_i\)</span> under the assumptions given above.  This means that, instead of stub-matching, we can use an algorithm like for a <span class="math inline">\(G(n,p)\)</span> network by placing an edge between two nodes with probability <span class="math inline">\(P_{ij} = \frac{k_ik_j}{2m}\)</span>.</p><div class="no-row-height column-margin column-container"><span class="margin-aside">Another assumption required here is that the maximum degree is not too large in comparison to <span class="math inline">\(n\)</span>.</span></div></div>
<div class="callout callout-style-simple callout-important no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercise
</div>
</div>
<div class="callout-body-container callout-body">
<p>Implement a function <code>chung_lu(deg_seq)</code> that generates a graph with expected degree sequence approximately equal to the input <code>deg_seq</code> in expectation using the algorithm described above. Your algorithm should return a <code>networkx</code> graph object. You can choose to either place a Poisson-distributed number of edges between each pair of nodes with the appropriate mean or simply place a single edge with the appropriate probability.</p>
<p><em>Hint</em>: You can use <code>itertools.combinations(range(n), 2)</code> to loop through all pairs of nodes in a graph.</p>
</div>
</div>

<p>NetworkX supplies a built-in Chung-Lu implementation:</p>
<div class="cell" data-execution_count="9" id="eceb8b89">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a aria-hidden="true" href="#cb10-1" tabindex="-1"></a>G <span class="op">=</span> nx.expected_degree_graph(deg_seq, selfloops<span class="op">=</span><span class="va">False</span>)</span></code><button class="code-copy-button" title="Copy to Clipboard"><i class="bi"></i></button></pre></div>
</div>
<p>Visually, this looks fairly similar to the configuration model and quite different from the original graph:</p>
<div class="cell page-columns page-full" data-execution_count="10" id="cell-fig-karate-club-chung-lu">
<details class="code-fold">
<summary>Show code</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a aria-hidden="true" href="#cb11-1" tabindex="-1"></a>fig, axarr <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize <span class="op">=</span> (<span class="dv">6</span>, <span class="dv">3</span>))</span>
<span id="cb11-2"><a aria-hidden="true" href="#cb11-2" tabindex="-1"></a>axarr[<span class="dv">0</span>].<span class="bu">set</span>(title <span class="op">=</span> <span class="st">"Karate Club Graph"</span>)</span>
<span id="cb11-3"><a aria-hidden="true" href="#cb11-3" tabindex="-1"></a></span>
<span id="cb11-4"><a aria-hidden="true" href="#cb11-4" tabindex="-1"></a>nx.draw(G_Karate, pos, ax <span class="op">=</span> axarr[<span class="dv">0</span>], <span class="op">**</span>plot_kwargs)</span>
<span id="cb11-5"><a aria-hidden="true" href="#cb11-5" tabindex="-1"></a></span>
<span id="cb11-6"><a aria-hidden="true" href="#cb11-6" tabindex="-1"></a>nx.draw(G, pos, ax <span class="op">=</span> axarr[<span class="dv">1</span>], <span class="op">**</span>plot_kwargs)</span>
<span id="cb11-7"><a aria-hidden="true" href="#cb11-7" tabindex="-1"></a>axarr[<span class="dv">1</span>].<span class="bu">set</span>(title <span class="op">=</span> <span class="st">"Chung-Lu Model </span><span class="ch">\n</span><span class="st">Graph"</span>)</span></code><button class="code-copy-button" title="Copy to Clipboard"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display page-columns page-full">
<div class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full" id="fig-karate-club-chung-lu">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-karate-club-chung-lu-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img class="figure-img" height="277" src="10-configuration-model_files/figure-html/fig-karate-club-chung-lu-output-1.png" width="466"/>
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-fig margin-caption" id="fig-karate-club-chung-lu-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure 8.4: Karate club graph alongside a Chung-Lu random graph.
</figcaption>
</figure>
</div>
</div>
</div>
<p>We can compare the degree sequence of the random graph we constructed to that of the original graph:</p>
<div class="cell page-columns page-full" data-execution_count="11" id="cell-fig-karate-club-chung-lu-degree-comparison">
<details class="code-fold">
<summary>Show code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a aria-hidden="true" href="#cb12-1" tabindex="-1"></a>chung_lu_deg_seq <span class="op">=</span> [k <span class="cf">for</span> n, k <span class="kw">in</span> G.degree()]</span>
<span id="cb12-2"><a aria-hidden="true" href="#cb12-2" tabindex="-1"></a></span>
<span id="cb12-3"><a aria-hidden="true" href="#cb12-3" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>, figsize <span class="op">=</span> (<span class="dv">4</span>, <span class="dv">4</span>))</span>
<span id="cb12-4"><a aria-hidden="true" href="#cb12-4" tabindex="-1"></a>plt.plot([<span class="dv">0</span>, <span class="dv">17</span>], [<span class="dv">0</span>, <span class="dv">17</span>], color <span class="op">=</span> <span class="st">"grey"</span>, linestyle <span class="op">=</span> <span class="st">"--"</span>, linewidth <span class="op">=</span> <span class="fl">0.75</span>)</span>
<span id="cb12-5"><a aria-hidden="true" href="#cb12-5" tabindex="-1"></a>ax.scatter(deg_seq, chung_lu_deg_seq,  s <span class="op">=</span> <span class="dv">10</span>, label <span class="op">=</span> <span class="st">"Karate Club"</span>, alpha <span class="op">=</span> <span class="fl">0.5</span>)</span>
<span id="cb12-6"><a aria-hidden="true" href="#cb12-6" tabindex="-1"></a>t <span class="op">=</span> ax.<span class="bu">set</span>(xlabel <span class="op">=</span> <span class="st">"Original Degree"</span>, ylabel <span class="op">=</span> <span class="st">"Degree in Chung-Lu Random Graph"</span>)</span></code><button class="code-copy-button" title="Copy to Clipboard"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display page-columns page-full">
<div class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full" id="fig-karate-club-chung-lu-degree-comparison">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-karate-club-chung-lu-degree-comparison-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img class="figure-img" height="349" src="10-configuration-model_files/figure-html/fig-karate-club-chung-lu-degree-comparison-output-1.png" width="365"/>
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-fig margin-caption" id="fig-karate-club-chung-lu-degree-comparison-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure 8.5: Comparison of the degree sequences of the karate club graph and a Chung-Lu random version. The line of equality, corresponding to nodes which have the same degree in both graphs, is shown.
</figcaption>
</figure>
</div>
</div>
</div>
<p>We observe that the degrees in the Chung-Lu model are correlated with but not exactly equal to the original degrees. We notice that the nodes with high degrees in the original graph tend to have lower degree in the Chung-Lu model; this is expected as shown in the following exercise.</p>
<div class="callout callout-style-simple callout-important no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercise
</div>
</div>
<div class="callout-body-container callout-body">
<p>Show that the expected degree <span class="math inline">\(\mathbb{E}[K_i]\)</span> of node <span class="math inline">\(i\)</span> in the Chung-Lu model is equal to <span class="math inline">\(k_i - \frac{k_i^2}{2m}\)</span>.</p>
</div>
</div>
</section>
<section class="level2" id="fixed-degree-distributions">
<h2 class="anchored" data-anchor-id="fixed-degree-distributions">Fixed Degree Distributions</h2>
<p>When making mathematical arguments, you may want to consider a “general graph with degree distribution <span class="math inline">\(p_k\)</span>.” That is, we’re interested in a graph in which proportion <span class="math inline">\(p_k\)</span> of all nodes have degree <span class="math inline">\(k\)</span>. This is a more flexible approach than specifying the degree <span class="math inline">\(k_i\)</span> of each individual node in a graph via the degree sequence <span class="math inline">\(\mathbf{k}_i\)</span>.</p>
<p>We can do this using a slight modification to the strategy described above.</p>
<ol type="1">
<li>Draw a degree sequence <span class="math inline">\(\{k_i\}\)</span> from the given distribution <span class="math inline">\(p_k.\)</span>
<ul>
<li>In practice, this is most likely achieved by <span class="math inline">\(n\)</span> independent draws from <span class="math inline">\(p_k\)</span>. A particular degree sequence then appears with probability <span class="math inline">\(\Pi_i p_{k_i}.\)</span></li>
</ul></li>
<li>Construct a graph with this degree sequence either exactly (configuration model) or approximately and in expectation (Chung-Lu) as described above.</li>
</ol>
<p>Once again, we can easily run into some challenges here. With the algorithm described above it is very possible to generate a degree sequence with an odd number of stubs, and such degree sequences would need to be discarded. The concerns about self-edges, multiedges, and labeling that apply to the configuration model and Chung-Lu models still apply here.</p>
<div class="callout callout-style-simple callout-important no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercise
</div>
</div>
<div class="callout-body-container callout-body">
<p>Write a function <code>degree_dist_random_graph(n, p)</code> which accepts a number of nodes <code>n</code> and a desired degree distribution <code>p</code>, which can be passed as a <code>numpy</code> array. Your function should (a) sample a degree sequence of length <code>n</code> from the desired degree distribution <code>p</code> and then (b) construct a graph with approximately this degree sequence using the Chung-Lu model.</p>
<p>We assume that <code>p</code> is a valid probability vector: its entries are nonnegative and sum to 1. <code>p[0]</code> is assumed to be the proportion of nodes of degree 0, <code>p[1]</code> the proportion of nodes of degree 1, and so on. Passing <code>p = np.array([0, 0, 0, 0])</code>, for example, would result in a regular graph where all nodes have degree 3.</p>
<p><em>Hint</em>: <code>np.random.choice(np.arange(len(p)), n, p = p)</code> will sample <code>n</code> random integers from <code>0, 1, ..., len(p) - 1</code> with probabilities given by <code>p</code>.</p>
<p>Once you’ve completed your implementation, generate some graphs with numbers of nodes ranging from 10 to 1000. Compare the degree distribution of the generated graphs to the desired degree distribution. You can plot the full distributions, check the means and variances, or any other comparison method you find interesting.</p>
</div>
</div>

<p>While the two models we describe here are different, we expect them to behave similarly in the large-<span class="math inline">\(n\)</span> limit, where a sequence drawn from a degree distribution more accurately captures the underlying distribution. This approximation is justifiable using formal asymptotic reasoning when <span class="math inline">\(n\)</span> grows large and the degree distribution <span class="math inline">\(p_k\)</span> has variance that doesn’t grow too rapidly with <span class="math inline">\(n\)</span>.</p>
<p>There are some important special cases that we’ve already encountered:</p>
<ul>
<li>Using a Poisson degree distribution approximately recovers the <span class="math inline">\(G(n,p)\)</span> model, excepting that we are able to generate self- and multiedges with this configuration model variant.</li>
<li>Using a power-law degree distribution helps us mathematically study the properties of scale-free networks, like those generated by preferential attachment.</li>
</ul>
<p>With this approximation scheme, we can go on to study one of the most important properties of random graphs: the excess degree distribution.</p>
</section>
<section class="level2 page-columns page-full" id="excess-degree-distribution">
<h2 class="anchored" data-anchor-id="excess-degree-distribution">Excess Degree Distribution</h2>
<p>Consider a configuration model with degree distribution <span class="math inline">\(p_k\)</span> (so a fraction <span class="math inline">\(p_k\)</span> of nodes have degree <span class="math inline">\(k\)</span>). This means that <span class="math inline">\(p_k\)</span> can be viewed as the probability that a node chosen uniformly at random from our network has degree <span class="math inline">\(k\)</span>. We’ll let <span class="math inline">\(n_k = np_k\)</span> be the expected number of nodes of degree <span class="math inline">\(k\)</span>.</p>
<p>Now, suppose we choose a node uniformly at random and follow an edges to this node’s neighbor (if it has one). What is the probability that the neighbor will have degree <span class="math inline">\(k\)</span>?</p>
<div class="callout callout-style-simple callout-warning no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercise
</div>
</div>
<div class="callout-body-container callout-body">
<p>Explain why the probability that the neighbor has degree <span class="math inline">\(k\)</span> is <strong>not</strong> also <span class="math inline">\(p_k\)</span>.</p>
</div>
</div>

<p>We’ll again reason using stubs. First, let’s calculate the probability that we have a stub connected to a particular degree <span class="math inline">\(k\)</span> node. A node with degree <span class="math inline">\(k\)</span> has <span class="math inline">\(k\)</span> stubs, and there are <span class="math inline">\(2m-1\)</span> possible stubs other than the one we selected. So,</p>
<p><span class="math display">\[
\begin{aligned}
    \mathbb{P}(\text{edge ends at particular degree $k$ node}) = \frac{k}{2m-1} \,.
\end{aligned}
\]</span></p>
<p>Thus, because in expectation there are <span class="math inline">\(np_k\)</span> nodes of degree <span class="math inline">\(k\)</span>, we have</p>
<p><span class="math display">\[
\begin{align}
    \mathbb{P}(\text{edge ends at any degree $k$ node}) = \frac{k}{2m-1}n p_k \approx \frac{k}{2m}np_k \,.
\end{align}
\]</span></p>
<p>Let <span class="math inline">\(\langle  k \rangle = \frac{1}{n} \sum_{i = 1}^n\)</span> be the mean degree. Then, we must have that <span class="math inline">\(\langle  k \rangle = \frac{2m}{n}\)</span>, so the probability that we reach a node of degree <span class="math inline">\(k\)</span> is approximately <span class="math inline">\(\frac{1}{\langle k \rangle}k p_k.\)</span> In other words, this probability is proportional to <span class="math inline">\(kp_k\)</span> (not <span class="math inline">\(p_k\)</span> as we might expect). This quantity is called the <strong>edge-biased degree distribution.</strong></p>
<p>We can calculate the additional number of edges attached to a neighbor <em>other</em> than the edge we arrived along. For a node to have <span class="math inline">\(k\)</span> additional neighbors, it must have degree <span class="math inline">\(k+1\)</span>. So, the probability that a neighbor has degree <span class="math inline">\(k+1\)</span> is <span class="math display">\[
\begin{align}
    q_k = \frac{(k+1)p_{k+1}}{\langle k \rangle} \,.
\end{align}
\]</span></p>
<p>This quantity is called the <strong>excess degree distribution.</strong></p>
<section class="level3 page-columns page-full" id="the-friendship-paradox">
<h3 class="anchored" data-anchor-id="the-friendship-paradox">The Friendship Paradox</h3>
<p>Suppose we model a social network of friends with degree-preserving random graph. How many friends does your friend have?</p>
<p>To see this, let’s calculate the average degree of a neighbor of a randomly chosen node using the edge-biased degree distribution.</p>
<p><span class="math display">\[
\begin{align}
    \sum_k k \frac{1}{\langle k \rangle}kp_k = \frac{1}{\langle k \rangle}\sum_k k^2 p_k\,.
\end{align}
\]</span></p>
<p>Let <span class="math inline">\(n\)</span> be the total number of nodes and <span class="math inline">\(n_k\)</span> be the number of nodes of degree <span class="math inline">\(k\)</span>.</p>
<p>Now we’ll simplify our expression with a reindexing trick. As written, we’ve indexed over node degrees <span class="math inline">\(k\)</span>, but we could choose to index over node labels <span class="math inline">\(i\)</span> instead. Remembering that <span class="math inline">\(p_k = \frac{1}{n}n_k\)</span>, this gives: <span id="eq-friendship-paradox-1"><span class="math display">\[
\begin{align}
    \frac{1}{\langle k \rangle}\sum_k k^2 \frac{1}{n}n_k = \frac{1}{\langle k \rangle n}\sum_i k_i^2 =  \frac{\langle k^2 \rangle}{\langle k \rangle}\,,
\end{align}
\tag{8.1}\]</span></span></p>
<div class="page-columns page-full"><p>where <span class="math inline">\(\langle k^2 \rangle = \frac{1}{n} \sum_i k_i^2\)</span>.  To get the first equality, we notice that the set <span class="math inline">\(\{n_1, (2)^2n_2, (3)^2n_3, \dots, (k_{max})^2 n_{k_{max}}\}\)</span> has the same sum as <span class="math inline">\(\{k_1^2, k_2^2, ..., k_n^2\}\)</span>.</p><div class="no-row-height column-margin column-container"><span class="margin-aside">The quantity <span class="math inline">\(\langle k^2 \rangle\)</span> is often called the <em>second moment</em> of the degree distribution. The first moment <span class="math inline">\(\langle k \rangle = \frac{1}{n}\sum_{i = 1}^n k_i\)</span> is the mean degree.</span></div></div>
<p>Let’s compare this value to the expected degree of a randomly chosen node:</p>
<p><span id="eq-friendship-paradox-2"><span class="math display">\[
\begin{aligned}
    \frac{\langle k^2 \rangle}{\langle k \rangle} - \langle k  \rangle = \frac{1}{\langle k \rangle}\left(\langle k^2 \rangle - \langle k \rangle^2\right) = \frac{\sigma_k^2}{\langle k \rangle}\,,
\end{aligned}
\tag{8.2}\]</span></span></p>
<p>where <span class="math inline">\(\sigma_k^2 = \langle k^2 \rangle - \langle k \rangle^2\)</span> is the empirical variance of the degree distribution. As we know, the variance of a random variable is 0 if and only the random variable is constant. In the context of degrees, this corresponds to a <span class="math inline">\(k\)</span>-regular graph. So, unless the graph is <span class="math inline">\(k\)</span>-regular, <span class="math inline">\(\sigma_k^2 &gt; 0.\)</span> Thus,</p>
<p><span class="math display">\[
\begin{align}
    \frac{\sigma_k^2}{\langle k \rangle} &amp;&gt; 0, \\
    \Rightarrow \frac{\langle k^2 \rangle}{\langle k \rangle} - \langle k \rangle &amp;&gt; 0, \\
    \Rightarrow \frac{\langle k^2 \rangle}{\langle k \rangle} &amp;&gt; \langle k \rangle \,.
\end{align}
\]</span></p>
<p>That is, the expected degree of a node’s neighbor (lefthand side) is greater than the expected node degree <span class="math inline">\(c\)</span> … in other words, (in expectation), your friends have more friends than you do!</p>
<p>The intuition behind this idea is that a node with degree <span class="math inline">\(k\)</span> appears as a neighbor to <span class="math inline">\(k\)</span> other nodes, so high degree nodes are over-represented in the calculations.</p>
<p>The friendship paradox has some practical applications in network analysis and interventions. For example, to interrupt the spread of an illness with a limited number of vaccines, it’s useful to target high-degree nodes in social networks, as they are more likely to be infected and to infect others. But how to identify the high-degree nodes? The friendship paradox suggests a simple way: pick some people at random and ask them to recommend one of their friends. This is sometimes called <em>acquaintance immunization</em> and can be a relative effective strategy for vaccine distribution. See <span class="citation" data-cites="rosenblatt2020immunization">Rosenblatt et al. (<a href="#ref-rosenblatt2020immunization" role="doc-biblioref">2020</a>)</span> for some discussion of this and related strategies.</p>
<p>Let’s visualize the degree of each node in comparison to the average degree of its neighbors to get a feel for this result:</p>
<div class="cell page-columns page-full" data-execution_count="13" id="cell-fig-karate-club-friendship-paradox">
<details class="code-fold">
<summary>Show code</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a aria-hidden="true" href="#cb14-1" tabindex="-1"></a>mean_degree <span class="op">=</span> np.mean(deg_seq)</span>
<span id="cb14-2"><a aria-hidden="true" href="#cb14-2" tabindex="-1"></a></span>
<span id="cb14-3"><a aria-hidden="true" href="#cb14-3" tabindex="-1"></a></span>
<span id="cb14-4"><a aria-hidden="true" href="#cb14-4" tabindex="-1"></a>neighbor_degrees <span class="op">=</span> <span class="bu">list</span>(nx.average_neighbor_degree(G_Karate).values())</span>
<span id="cb14-5"><a aria-hidden="true" href="#cb14-5" tabindex="-1"></a></span>
<span id="cb14-6"><a aria-hidden="true" href="#cb14-6" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>, figsize <span class="op">=</span> (<span class="dv">5</span>, <span class="dv">4</span>))</span>
<span id="cb14-7"><a aria-hidden="true" href="#cb14-7" tabindex="-1"></a>ax.scatter(deg_seq, neighbor_degrees, s <span class="op">=</span> <span class="dv">10</span>, alpha <span class="op">=</span> <span class="fl">0.5</span>)</span>
<span id="cb14-8"><a aria-hidden="true" href="#cb14-8" tabindex="-1"></a>ax.plot([<span class="dv">0</span>, <span class="dv">17</span>], [<span class="dv">0</span>, <span class="dv">17</span>], color <span class="op">=</span> <span class="st">"grey"</span>, linestyle <span class="op">=</span> <span class="st">"--"</span>, linewidth <span class="op">=</span> <span class="fl">0.75</span>)</span>
<span id="cb14-9"><a aria-hidden="true" href="#cb14-9" tabindex="-1"></a>t <span class="op">=</span> ax.<span class="bu">set</span>(xlabel <span class="op">=</span> <span class="st">"Node Degree"</span>, ylabel <span class="op">=</span> <span class="st">"Mean degree of neighbors"</span>, title <span class="op">=</span> <span class="st">"Friendship Paradox in the Karate Club Graph"</span>)</span></code><button class="code-copy-button" title="Copy to Clipboard"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display page-columns page-full">
<div class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full" id="fig-karate-club-friendship-paradox">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-karate-club-friendship-paradox-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img class="figure-img" height="368" src="10-configuration-model_files/figure-html/fig-karate-club-friendship-paradox-output-1.png" width="445"/>
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-fig margin-caption" id="fig-karate-club-friendship-paradox-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure 8.6: Computational illustration of the friendship paradox in the karate club graph. The average degree of the neighbors of a node tends to be higher than the degree of the node itself, with a few exceptions.
</figcaption>
</figure>
</div>
</div>
</div>
<p>For most nodes (but not all), the mean degree of their neighbors is higher than their own degree. On average, the mean degree of a node in this graph is just half of the mean degree of that node’s neighbors.</p>
<p>We can verify <a class="quarto-xref" href="#eq-friendship-paradox-1">Equation <span>8.1</span></a> by computing the appropriate quantities in two ways.</p>
<div class="callout callout-style-simple callout-warning no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercise
</div>
</div>
<div class="callout-body-container callout-body">
<p>Write a function which computes the average neighbor degree in the graph. Your function should loop through all nodes in the graph, collect the degrees of their neighbors, and combine those degrees in a large list (or similar data structure). You should then return the mean of that list.</p>
</div>
</div>

<p>Let’s compare our computational result to the result expected by theory.</p>
<div class="callout callout-style-simple callout-warning no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercise
</div>
</div>
<div class="callout-body-container callout-body">
<p>Implement the mathematical calculation of the average neighbor degree using <a class="quarto-xref" href="#eq-friendship-paradox-1">Equation <span>8.1</span></a> and show that it agrees with your function in the previous exercise.</p>
</div>
</div>

</section>
</section>
<section class="level2" id="references">
<h2 class="anchored" data-anchor-id="references">References</h2>
<div class="references csl-bib-body hanging-indent" data-entry-spacing="0" id="refs" role="list">
<div class="csl-entry" id="ref-bollobas1980probabilistic" role="listitem">
Bollobás, Béla. 1980. <span>“A Probabilistic Proof of an Asymptotic Formula for the Number of Labelled Regular Graphs.”</span> <em>European Journal of Combinatorics</em> 1 (4): 311–16.
</div>
<div class="csl-entry" id="ref-chung2002connected" role="listitem">
Chung, Fan, and Linyuan Lu. 2002. <span>“Connected Components in Random Graphs with Given Expected Degree Sequences.”</span> <em>Annals of Combinatorics</em> 6 (2): 125–45.
</div>
<div class="csl-entry" id="ref-erdos1960graphs" role="listitem">
Erdös, Paul, and Tibor Gallai. 1960. <span>“Graphs with Given Degrees of Vertices.”</span> <em>Math. Lapok</em> 11: 264–74.
</div>
<div class="csl-entry" id="ref-fosdick2018configuring" role="listitem">
Fosdick, Bailey K, Daniel B Larremore, Joel Nishimura, and Johan Ugander. 2018. <span>“Configuring Random Graph Models with Fixed Degree Sequences.”</span> <em>Siam Review</em> 60 (2): 315–55.
</div>
<div class="csl-entry" id="ref-rosenblatt2020immunization" role="listitem">
Rosenblatt, Samuel F, Jeffrey A Smith, G Robin Gauthier, and Laurent Hébert-Dufresne. 2020. <span>“Immunization Strategies in Networks with Missing Data.”</span> <em>PLoS Computational Biology</em> 16 (7): e1007897.
</div>
</div>
</section>
<p><br/> <br/> <span style="color:grey;">© Heather Zinn Brooks and Phil Chodrow, 2025</span></p></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
<div class="nav-page nav-page-previous">
<a aria-label="Random Graphs: Erdős–Rényi" class="pagination-link" href="../chapters/09-random-graphs.html">
<i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">7</span>  <span class="chapter-title">Random Graphs: Erdős–Rényi</span></span>
</a>
</div>
<div class="nav-page nav-page-next">
<a aria-label="Probability Generating Functions" class="pagination-link" href="../chapters/11-generating-functions.html">
<span class="nav-page-text"><span class="chapter-number">9</span>  <span class="chapter-title">Probability Generating Functions</span></span> <i class="bi bi-arrow-right-short"></i>
</a>
</div>
</nav>
</div> <!-- /content -->
</body></html>