<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.10">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>17&nbsp; Epidemic Models on Networks – Network Science: Models, Mathematics, and Computation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../chapters/51-agent-based-modeling.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-2d9718c933debafcce942f9b212640bc.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-c1bdd270c1c0708cd2ff05417efafcc5.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../chapters/50-random-walks.html">Applications and Extensions</a></li><li class="breadcrumb-item"><a href="../chapters/52-epidemiology.html"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Epidemic Models on Networks</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">Network Science: Models, Mathematics, and Computation</a> 
    </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Welcome</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Network Fundamentals</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/01-networkrepresentations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Networks and Their Representations</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/02-degree-walks-paths.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Degree, Walks, and Paths</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/03-components-laplacian.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Components and the Graph Laplacian</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">Measuring Networks</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/04-centrality.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Centrality and Importance</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/05-viz.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Visualizing Networks and Why You Shouldn’t</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/06-modularity.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Homophily, assortativity, and modularity</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true">
 <span class="menu-text">Real-World Networks</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/07-real-world.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Structure of Empirical Networks</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/08-power-laws.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Power Law Degree Distributions</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true">
 <span class="menu-text">Models of Networks</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/09-random-graphs.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Random Graphs: Erdős–Rényi</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/10-configuration-model.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Configuration models</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/11-generating-functions.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Probability Generating Functions</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="true">
 <span class="menu-text">Network Algorithms</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/13-modularity-maximization.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Community Detection and Modularity Maximization</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/19-spectral-clustering.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Spectral Clustering</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/41-link-prediction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Link Prediction and Feedback Loops</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" role="navigation" aria-expanded="true">
 <span class="menu-text">Applications and Extensions</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-6" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/50-random-walks.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Random Walks</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/51-agent-based-modeling.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Agent-Based Modeling on Networks</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/52-epidemiology.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Epidemic Models on Networks</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <span class="sidebar-item-text sidebar-link text-start">
 <span class="menu-text">Appendices</span></span>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Contents</h2>
   
  <ul>
  <li><a href="#outbreak-sizes" id="toc-outbreak-sizes" class="nav-link active" data-scroll-target="#outbreak-sizes">Outbreak sizes</a>
  <ul class="collapse">
  <li><a href="#the-si-model" id="toc-the-si-model" class="nav-link" data-scroll-target="#the-si-model">The SI model</a></li>
  <li><a href="#the-sir-model" id="toc-the-sir-model" class="nav-link" data-scroll-target="#the-sir-model">The SIR model</a></li>
  <li><a href="#sir-on-configuration-model-networks" id="toc-sir-on-configuration-model-networks" class="nav-link" data-scroll-target="#sir-on-configuration-model-networks">SIR on configuration model networks</a></li>
  </ul></li>
  <li><a href="#time-dependent-properties-of-epidemics-on-networks" id="toc-time-dependent-properties-of-epidemics-on-networks" class="nav-link" data-scroll-target="#time-dependent-properties-of-epidemics-on-networks">Time-dependent properties of epidemics on networks</a>
  <ul class="collapse">
  <li><a href="#si-model" id="toc-si-model" class="nav-link" data-scroll-target="#si-model">SI model</a></li>
  </ul></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../chapters/50-random-walks.html">Applications and Extensions</a></li><li class="breadcrumb-item"><a href="../chapters/52-epidemiology.html"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Epidemic Models on Networks</span></a></li></ol></nav>
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Epidemic Models on Networks</span></h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><em>Open the live notebook in Google Colab <a href="https://colab.research.google.com/github/network-science-notes/network-science-notes.github.io/blob/main/docs/live-notebooks/52-epidemiology.ipynb">here</a>.</em></p>
<p>Mathematical models play an important role in understanding the spread of diseases in a population, and are an integral part of informing policies for disease mitigation. The structure of people’s contact networks can have a big effect on the way a disease spreads.</p>
<section id="outbreak-sizes" class="level2">
<h2 class="anchored" data-anchor-id="outbreak-sizes">Outbreak sizes</h2>
<section id="the-si-model" class="level3">
<h3 class="anchored" data-anchor-id="the-si-model">The SI model</h3>
<p>First, we’ll model a scenario where individuals can have one of two disease states: <em>susceptible</em> (has not yet contracted the disease) and <em>infectious</em> (is a carrier of the disease). Suppose we have a network with <span class="math inline">\(N\)</span> agents. We’ll denote the number of susceptible individuals at time <span class="math inline">\(t\)</span> as <span class="math inline">\(S(t)\)</span> and the number of infectious agents at time <span class="math inline">\(t\)</span> as <span class="math inline">\(I(t)\)</span>. We will make several important simplifying assumptions in our model:</p>
<ul>
<li>We’ll ignore births or deaths in the population, assuming that these processes happen on slower timescales than the disease spreads.</li>
<li>Because the total population is conserved, and every agent is in one of the two disease states, we have <span class="math inline">\(N = S(t) + I(t).\)</span></li>
<li>Infections can only be transmitted from an infectious individual to a susceptible individual. The probability per unit time that the infection will be transmitted via an edge connecting one susceptible and one infected individual is <span class="math inline">\(\beta &gt;0\)</span>. We call this quantity the <strong>transmission rate</strong> or the <strong>infection rate</strong>.</li>
</ul>
<p><img src="../assets/img/transmission-rate.png" alt="transmission rate" width="200"></p>
<p>The model as described above is called an <strong>SI model</strong>. An important question with any model of disease spread is what happens to the size of the outbreak as <span class="math inline">\(t \to \infty.\)</span> Let’s explore this question now.</p>
<p>Start with one infectious node <span class="math inline">\(i\)</span>. During a time interval of length <span class="math inline">\(\Delta t &lt;&lt;1\)</span>, the probability of transmitting the disease to a susceptible neighbor (supposing there is one) is <span class="math inline">\(\beta \Delta t.\)</span> The probability of <em>not</em> transmitting the disease in time interval <span class="math inline">\(\Delta t\)</span> is <span class="math inline">\(1-\beta \Delta t.\)</span> Given a total time <span class="math inline">\(\tau\)</span>, we have</p>
<p><span class="math display">\[
    \mathbb{P}(\text{disease not transmitted after total time } \tau) = \lim_{\Delta t \to 0} \left(1 -\beta \Delta t\right)^{\tau/\Delta t} = e^{-\beta \tau} \,.
\]</span></p>
<p>That is, as <span class="math inline">\(\tau \to \infty\)</span>, the probability of the susceptible node remaining uninfected approaches 0. We expect that a susceptible node with an infected neighbor will eventually become infected. Continuing this argument, any node that is path-connected to an infected node will eventually become infected. From this we can conclude that the size of the outbreak will be the size of the component that contains the initially infected node.</p>
<p>Fortunately, we have already studied the calculation of component sizes (see <a href="09-random-graphs.html#sec-component" class="quarto-xref"><span>Section 9.4.3.1</span></a>). Consider a network where the fraction of nodes in the giant component is <span class="math inline">\(S\)</span>. Then, with probability <span class="math inline">\(S\)</span>, the expected size of the outbreak will be <span class="math inline">\(NS.\)</span> With probability <span class="math inline">\(1-S\)</span>, the number of infectious individuals will remain small, with the size of the outbreak determined by the size of the connected component containing the initially infectious node.</p>
<p>Through this quick analysis, we see that even in the simplest epidemic model, network structure introduces stochasticity into the dynamics.</p>
</section>
<section id="the-sir-model" class="level3">
<h3 class="anchored" data-anchor-id="the-sir-model">The SIR model</h3>
<p>To make the model slightly more realistic, we could assume that agents could eventually recover from the disease, while keeping the other parameters and assumptions as above. We will assume that recovered individuals are no longer infectious (they cannot spread the disease to other agents) and they are also no longer susceptible (they have developed immunity to future infections). Let <span class="math inline">\(R(t)\)</span> denote the class of recovered individuals at time <span class="math inline">\(t\)</span>. Now, <span class="math inline">\(N = S(t) + I(t) + R(t).\)</span> This model is called an <strong>SIR model</strong>.</p>
<p>As in the SI model, the <em>transmission probability</em> between an infectious nodes <span class="math inline">\(i\)</span> and susceptible node <span class="math inline">\(j\)</span> is <span class="math display">\[
    \phi_{ij} = 1 - e^{-\beta \tau_i} \,
\]</span></p>
<p>where <span class="math inline">\(\tau_i\)</span> is the amount of time that an individual <span class="math inline">\(i\)</span> is infectious. In this case, <span class="math inline">\(\tau_i\)</span> is a disease-dependent parameter that can be interpreted as a recovery rate. While this value is often chosen to be a fixed constant, we could also draw <span class="math inline">\(\tau_i\)</span> from a distribution or allow it to depend on other node properties.</p>
<p>Notice that we have a key difference in our dynamics due to the introduction of the recovered class. Unlike in the SI model, it is possible for an infectious node to recover before it infects its susceptible neighbors, thus limiting the spread of disease.</p>
<p>Intuitively we can see the qualitative effects of our parameters <span class="math inline">\(\beta\)</span> and <span class="math inline">\(\tau\)</span>. If either (or both) of these parameters are small, then the transmission probability <span class="math inline">\(\phi\)</span> will also be small. In this regime, we expect the outbreak to reach a limited number of agents and exist only in isolated clusters.</p>
<p><img src="../assets/img/percolation-example.png" class="img-fluid"></p>
<p>As <span class="math inline">\(\phi\)</span> increases, we will eventually reach a <em>percolation transition</em> where a large “cluster” forms, and thus an epidemic (i.e., a large outbreak) is possible. Again, if <span class="math inline">\(S\)</span> is the fraction of nodes in the cluster, the size of the outbreak will be <span class="math inline">\(NS\)</span> will probability <span class="math inline">\(S\)</span>. Note that a large value of <span class="math inline">\(\phi\)</span> doesn’t guarantee an epidemic — this is a stochastic process and it is possible for the disease to die out by chance.</p>
</section>
<section id="sir-on-configuration-model-networks" class="level3">
<h3 class="anchored" data-anchor-id="sir-on-configuration-model-networks">SIR on configuration model networks</h3>
<p>Now that we have some intuition behind the effect of parameters in the SIR model, let’s calculate the size distribution of the epidemic as well as the epidemic threshold. The mathematical ideas we use in this section come from the study of bond percolation (see <span class="citation" data-cites="sahimi2023applications">Sahimi (<a href="#ref-sahimi2023applications" role="doc-biblioref">2023</a>)</span>).</p>
<p>Suppose we have a configuration model with degree distribution <span class="math inline">\(p_k\)</span>. We will initially choose one node uniformly at random to be infectious. The transmission probability (as derived in the previous section) will be denoted <span class="math inline">\(\phi\)</span>; we can also think of this as an edge “occupation” probability. We will assume that transmission along each edge is independent.</p>
<p>What is the probability that a node <span class="math inline">\(i\)</span> is connected to a giant percolation cluster (that is, in an epidemic)? It’s easier to calculate the expected probability <span class="math inline">\(u\)</span> that a node is {} connected to the giant percolation cluster via one of its edges, say <span class="math inline">\((i,j)\)</span>. This can happen one of two ways:</p>
<ol type="1">
<li><p>The edge <span class="math inline">\((i,j)\)</span> is unoccupied (no transmission of infection between <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>): <span class="math display">\[
\mathbb{P}(\text{edge unoccupied}) = 1 - \phi,.
\]</span></p></li>
<li><p>The edge is occupied (infection has been transmitted between <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>), but <span class="math inline">\(j\)</span> is not connected to the giant cluster (no transmission between node <span class="math inline">\(j\)</span> and any of its <span class="math inline">\(k\)</span> neighbors): <span class="math display">\[
\mathbb{P}(j \text{ not connected to giant cluster by any of } k \text{ edges}) = u^k \,,
\]</span> and so <span class="math display">\[
\mathbb{P}((i,j) \text{ occupied and } j \text{ not connected by any of } k \text{ edges}) = \phi u^k \,,
\]</span></p></li>
</ol>
<p><img src="../assets/img/second-neighbors.png" alt="second neighbors" width="200"></p>
<p>Combining (1) and (2) gives our desired quantity: <span class="math display">\[
    \mathbb{P}(i \text{ not connected to giant cluster via degree} (k+1) \text{ neighbor}) = 1 - \phi + \phi u^k \,.
\]</span></p>
<p>We know that, for a configuration model with degree distribution given by <span class="math inline">\(p_k\)</span>, the value of <span class="math inline">\(k\)</span> is distributed according to the excess degree distribution <span class="math display">\[
    q_k = \frac{(k+1)p_{k+1}}{\langle k \rangle} \,,
\]</span> where <span class="math inline">\(\langle k \rangle\)</span> is the mean degree.</p>
<p>Summing over all possible values of <span class="math inline">\(k\)</span> gives <span id="eq-u-prob"><span class="math display">\[
\begin{aligned}
    u &amp;= \sum_{k=0}^\infty q_k \left(1-\phi+\phi u^k\right) \nonumber \\
    &amp;= \sum_{k=0}^\infty q_k - \phi \sum_{k=0}^\infty q_k + \phi \sum_{k=0}^\infty q_k u^k \nonumber \\
    &amp;= 1 - \phi + \phi g_1(u) \,,
\end{aligned}
\tag{17.1}\]</span></span></p>
<p>where <span class="math inline">\(g_1(u)\)</span> is the generating function associated with the excess degree distribution for our network. In general, <a href="#eq-u-prob" class="quarto-xref">Equation&nbsp;<span>17.1</span></a> may be difficult to solve, or may not have a closed form solution. However, we can use a graphical method to get insight into the epidemic threshold.</p>
<p>We know that <span class="math inline">\(g_1(u)\)</span> is a polynomial with nonnegative coefficients because it is a probability generating function. Therefore, for <span class="math inline">\(u \in [0,1]\)</span>, we know</p>
<ul>
<li><span class="math inline">\(g_1(u) \geq 0\)</span>,</li>
<li>all derivatives of <span class="math inline">\(g_1\)</span> with respect to <span class="math inline">\(u\)</span> are nonnegative, and</li>
<li><span class="math inline">\(g_1(1) = 1\)</span>.</li>
</ul>
<p>We look for intersections of <span class="math inline">\(u\)</span> and <span class="math inline">\(1- \phi + \phi g_1(u) = y\)</span>. To calculate <span class="math inline">\(y\)</span>, we take <span class="math inline">\(g_1(u)\)</span> and shift up by <span class="math inline">\(1- \phi\)</span> and multiply by <span class="math inline">\(\phi\)</span>.</p>
<p>If <span class="math inline">\(\phi\)</span> is sufficiently large, we will see the following qualitative behavior: <img src="../assets/img/large-phi.png" class="img-fluid"></p>
<p>As <span class="math inline">\(\phi\)</span> decreases, then eventually at <span class="math inline">\(\phi = \phi_c\)</span> the second intersection disappears: <img src="../assets/img/critical-phi.png" class="img-fluid"> <img src="../assets/img/small-phi.png" class="img-fluid"></p>
<p>Inspired by our sketches, we can calculate the value of <span class="math inline">\(\phi_c\)</span> by noticing this transition occurs when the curve is tangent to the identity line at <span class="math inline">\(u=1\)</span>, that is,</p>
<p><span class="math display">\[
    \begin{aligned}
    \frac{d}{du} \left[ 1 - \phi_c + \phi_c g_1(u)\right] \bigg \vert_{u=1} = 1 \,, \\
    \rightarrow \phi_c g_1'(1) = 1 \,, \\
    \rightarrow \phi_c = \frac{1}{g_1'(1)} \,.
    \end{aligned}
\]</span></p>
<p>We have previously calculated the quantity <span class="math inline">\(g_1'(1)\)</span> in terms of the degree distribution in <a href="11-generating-functions.html#sec-secondneighbors" class="quarto-xref"><span>Section 11.4.2</span></a>: this is the expected excess degree, which is given by <span class="math inline">\(\frac{\langle k^2\rangle - \langle k \rangle}{\langle k \rangle}\)</span>. Thus, <span class="math display">\[
    \phi_c = \frac{\langle k \rangle}{\langle k^2\rangle - \langle k \rangle} \,.
\]</span></p>
<p>We can even write this in terms of model parameters <span class="math inline">\(\beta\)</span> and <span class="math inline">\(\tau\)</span>. Since <span class="math inline">\(\phi_c = 1-e^{-\beta \tau}\)</span>, we have <span class="math display">\[
\begin{aligned}
    \beta \tau &amp;= -\ln \left(1-\phi_c \right) \\
    &amp; = -\ln \left[ \frac{\langle k^2 \rangle- \langle k \rangle - \langle k \rangle}{\langle k^2 \rangle- \langle k \rangle} \right] \\
    &amp;= \ln \left[ \frac{\langle k^2 \rangle- \langle k \rangle}{\langle k^2 \rangle- 2\langle k \rangle} \right] \,.
\end{aligned}
\]</span></p>
<p>If the product <span class="math inline">\(\beta \tau\)</span> is less than this value, we do not expect an epidemic. However, if <span class="math inline">\(\beta \tau\)</span> is larger than this value, then an epidemic is possible! This helps us link disease model parameters to network structure.</p>
<p>The argument to approximate the size of the outbreak is similar to what we have done previously. Let <span class="math inline">\(S\)</span> be the fraction of nodes in the giant percolation cluster. Since <span class="math inline">\(u\)</span> is the probability that a node is not connected to a giant cluster via a particular edge, a node with <span class="math inline">\(k\)</span> edges is not connected to the giant cluster with probability <span class="math inline">\(u^k\)</span>.</p>
<p>For the network, we expect that <span class="math display">\[
    \mathbb{P}(\text{not in cluster}) = \sum_{k=0}^\infty p_k u^k = g_0(u)\,,
\]</span> and so <span class="math display">\[
    \mathbb{P}(\text{in cluster}) = S = 1-g_0(u)\,.
\]</span></p>
<p>As before, the expected size of the outbreak is <span class="math inline">\(NS\)</span>, which occurs with probability <span class="math inline">\(S\)</span>. Note that, unlike in the SI model, <span class="math inline">\(S\)</span> depends on <span class="math inline">\(\beta\)</span> and <span class="math inline">\(\tau\)</span>. If these values exceed the threshold, then an epidemic is possible, if the infection is introduced in the giant cluster.</p>
</section>
</section>
<section id="time-dependent-properties-of-epidemics-on-networks" class="level2">
<h2 class="anchored" data-anchor-id="time-dependent-properties-of-epidemics-on-networks">Time-dependent properties of epidemics on networks</h2>
<p>If we want to understand the dynamic evolution and understand the progression of the disease spread in time (not just the limiting behavior) in an analytic way, we need to develope additional techniques. One strategy is to leverage tools from differential equations to study the evolution of the probabilities of a particular node have a particular state at time <span class="math inline">\(t\)</span>. We’ll give a taste of the methods here for the SI model. <span class="citation" data-cites="porter2016dynamical">Porter and Gleeson (<a href="#ref-porter2016dynamical" role="doc-biblioref">2016</a>)</span> provide a resource for further techniques for dynamical systems on networks.</p>
<section id="si-model" class="level3">
<h3 class="anchored" data-anchor-id="si-model">SI model</h3>
<p>Imagine running many simulations of an SI model with the same parameters on the same network with the same initial conditions.</p>
<p>For node <span class="math inline">\(i\)</span>, define <span class="math inline">\(S_i(t) =\)</span> expected probability that node <span class="math inline">\(i\)</span> is susceptible at time <span class="math inline">\(t\)</span>, and $X_i(t) = $ expected probability that node <span class="math inline">\(i\)</span> is infected at time <span class="math inline">\(t\)</span>. As before, we’ll assume infections occur with probability <span class="math inline">\(\beta dt\)</span> if node <span class="math inline">\(i\)</span> is susceptible and connected to an infectious node <span class="math inline">\(j\)</span>.</p>
<p>Then, we can write equations to describe how these quantities evolve in time. <span class="math display">\[
    \begin{aligned}
        \frac{dS_i(t)}{dt} &amp;= -\beta S_i \sum_{j=1}^n A_{ij}X_j \\
        \frac{dX_i(t)}{dt} &amp;= \beta S_i  \sum_{j=1}^n A_{ij}X_j
    \end{aligned}
\]</span></p>
<p>Note that, because we have a conserved quantity <span class="math inline">\(X_i(t) + S_i(t) = 1\)</span>, these two equations are redundant. The system can be reduced to an equation describing the evolution of the probability that node <span class="math inline">\(i\)</span> is infected: <span class="math display">\[
    \frac{dX_i(t)}{dt} = \beta (1-X_i)\sum_{j=1}^n A_{ij}X_j = \beta \sum_{j=1}^n A_{ij}X_j - \beta X_i \sum_{j=1}^n A_{ij}X_j \,.
\]</span></p>
<p>Now, we have a system of <span class="math inline">\(n\)</span> ordinary differential equations for infection probabilities, which are coupled through the network structure. For an arbitrary adjacency matrix <span class="math inline">\(A\)</span> this system does not have a closed-form solution. However, we can learn something about the behavior for small <span class="math inline">\(t\)</span> (the beginning of an outbreak) by considering suitable limits.</p>
<p>Assume we use an initial condition where we infect only a single node selected uniformly at random. In this case, <span class="math inline">\(X_i(0) = \frac{1}{n}\)</span> and <span class="math inline">\(S_i(0) = 1-\frac{1}{n}\)</span>. Consider the large-<span class="math inline">\(n\)</span> limit (<span class="math inline">\(n \to \infty\)</span>). In other words, when <span class="math inline">\(n\)</span> is large, <span class="math inline">\(S_i(0) \approx 1\)</span> and <span class="math inline">\(X_i(0)\)</span> is extremely small for all <span class="math inline">\(i\)</span>. Thus, for sufficiently small <span class="math inline">\(t\)</span>, the quadratic term <span class="math inline">\(X_iX_j\)</span> is much smaller than the linear term. This observation allows us to write an approximate linear system <span class="math display">\[
    \frac{dX_i}{dt} \approx \beta \sum_{j=1}^n A_{ij}X_j.
\]</span></p>
<p>Writing <span class="math inline">\({\bf x}(t)\)</span> as the vector <span class="math inline">\((X_1(t), X_2(t), \dots X_n(t))^T\)</span> containing the probabilities for each node, we can write our system in matrix form <span id="eq-linearSI"><span class="math display">\[
    \frac{d}{dt}{\bf x} \approx \beta A {\bf x}\,.
\tag{17.2}\]</span></span></p>
<p>We can study the solutions of the linearized system by studying the eigenvalues and eigenvectors of <span class="math inline">\(A\)</span>. Let <span class="math inline">\({\bf v}_r\)</span> be the eigenvector with associated eigenvalue <span class="math inline">\(\lambda_r\)</span>, so that <span class="math inline">\(A{\bf v}_r = \lambda_r {\bf v}_r\)</span>. If we write <span class="math inline">\({\bf x}\)</span> as a linear combination of the eigenvectors of <span class="math inline">\(A\)</span>, we have</p>
<p><span id="eq-eigsLC"><span class="math display">\[
    {\bf x} = \sum_{r=1}^n c_r(t) {\bf v}_r \,,
\tag{17.3}\]</span></span></p>
<p>where <span class="math inline">\(c_r(t)\)</span> are the time-dependent coefficients of this linear combination. Substituting <a href="#eq-eigsLC" class="quarto-xref">Equation&nbsp;<span>17.3</span></a> into <a href="#eq-linearSI" class="quarto-xref">Equation&nbsp;<span>17.2</span></a> gives <span class="math display">\[
    \frac{d}{dt} {\bf x} = \sum_{r=1}^n \frac{dc_r}{dt} {\bf v}_r = \beta \sum_{r=1}^n c_r(t) \lambda_r {\bf v}_r \,.
\]</span></p>
<p>Therefore, for each term, we have a first-order linear differential equation describing the coefficients <span class="math display">\[
    \frac{dc_r}{dt} = \beta \lambda_r c_r \ \Rightarrow \ c_r(t) = c_r(0)e^{\beta \lambda_r t} \,.
\]</span></p>
<p>Finally, substitute this expression for the time-dependent coefficients into <a href="#eq-eigsLC" class="quarto-xref">Equation&nbsp;<span>17.3</span></a> to get the solution for <span class="math inline">\({\bf x}\)</span>: <span class="math display">\[
    {\bf x} = \sum_{r=1}^n c_r(0)e^{\beta \lambda_r t}{\bf v}_r\,.
\]</span></p>
<p>Our solution will be dominated by the fasted growing term (i.e., the largest magnitude eigenvalue, which we will call <span class="math inline">\(\lambda_1\)</span>). <span class="math display">\[
    {\bf x}(t) \sim e^{\beta \lambda_1 t} {\bf v}_1 \,.
\]</span></p>
<p>This means that in the early stages of the disease spread, we expect the number of infectious individuals to grow exponentially. The growth rate is determined by the largest magnitude eigenvalue <span class="math inline">\(\lambda_1\)</span> of the adjacency matrix, and the probability varies for different nodes. These probabilities correspond to different components of <span class="math inline">\({\bf v}_1\)</span>.</p>
<p>In fact, we have met such a vector before. The components of the leading eigenvector are what we previously defined as eigenvector centralities — so this centrality measure gives an approximation to early infection time probability in an SI model!</p>
<p>We have made several approximations in this analysis. In particular, in order to study the linearized problem, we have neglected correlations between neighbors. However, <span class="math inline">\(S_i\)</span> and <span class="math inline">\(X_j\)</span> are not necessarily independent! This can be accounted for using pair approximation (or moment closure) methods; see <span class="citation" data-cites="porter2016dynamical">Porter and Gleeson (<a href="#ref-porter2016dynamical" role="doc-biblioref">2016</a>)</span>.</p>
</section>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>


<!-- -->

<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-porter2016dynamical" class="csl-entry" role="listitem">
Porter, Mason A, and James P Gleeson. 2016. <span>“Dynamical Systems on Networks.”</span> <em>Frontiers in Applied Dynamical Systems: Reviews and Tutorials</em> 4: 29.
</div>
<div id="ref-sahimi2023applications" class="csl-entry" role="listitem">
Sahimi, Muhammad. 2023. <em>Applications of Percolation Theory</em>. Springer.
</div>
</div>
</section>

<p><br> <br> <span style="color:grey;">© Heather Zinn Brooks and Phil Chodrow, 2025</span></p></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../chapters/51-agent-based-modeling.html" class="pagination-link" aria-label="Agent-Based Modeling on Networks">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Agent-Based Modeling on Networks</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb1" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="an">code-fold:</span><span class="co"> true</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="an">code-summary:</span><span class="co"> "Show code"</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="fu"># Epidemic Models on Networks</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>*Open the live notebook in Google Colab [here](https://colab.research.google.com/github/network-science-notes/network-science-notes.github.io/blob/main/docs/live-notebooks/52-epidemiology.ipynb).* </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>Mathematical models play an important role in understanding the spread of diseases in a population, and are an integral part of informing policies for disease mitigation. The structure of people's contact networks can have a big effect on the way a disease spreads.</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="fu">## Outbreak sizes</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="fu">### The SI model</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>First, we'll model a scenario where individuals can have one of two disease states: *susceptible* (has not yet contracted the disease) and *infectious* (is a carrier of the disease). Suppose we have a network with $N$ agents. We'll denote the number of susceptible individuals at time $t$ as $S(t)$ and the number of infectious agents at time $t$ as $I(t)$. We will make several important simplifying assumptions in our model:</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>We'll ignore births or deaths in the population, assuming  that these processes happen on slower timescales than the disease spreads.</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Because the total population is conserved, and every agent is in one of the two disease states, we have $N = S(t) + I(t).$</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Infections can only be transmitted from an infectious individual to a susceptible individual. The probability per unit time that the infection will be transmitted via an edge connecting one susceptible and one infected individual is $\beta &gt;0$. We call this quantity the **transmission rate** or the **infection rate**. </span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>&lt;img src="../assets/img/transmission-rate.png" alt="transmission rate" width="200"/&gt;</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>The model as described above is called an **SI model**. An important question with any model of disease spread is what happens to the size of the outbreak as $t \to \infty.$ Let's explore this question now.</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>Start with one infectious node $i$. During a time interval of length $\Delta t &lt;&lt;1$, the probability of transmitting the disease to a susceptible neighbor (supposing there is one) is $\beta \Delta t.$ The probability of *not* transmitting the disease in time interval $\Delta t$ is $1-\beta \Delta t.$ Given a total time $\tau$, we have</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    \mathbb{P}(\text{disease not transmitted after total time } \tau) = \lim_{\Delta t \to 0} \left(1 -\beta \Delta t\right)^{\tau/\Delta t} = e^{-\beta \tau} \,.</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>That is, as $\tau \to \infty$, the probability of the susceptible node remaining uninfected approaches 0. We expect that a susceptible node with an infected neighbor will eventually become infected. Continuing this argument, any node that is path-connected to an infected node will eventually become infected. From this we can conclude that the size of the outbreak will be the size of the component that contains the initially infected node.</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>Fortunately, we have already studied the calculation of component sizes (see @sec-component). Consider a network where the fraction of nodes in the giant component is $S$. Then, with probability $S$, the expected size of the outbreak will be $NS.$ With probability $1-S$, the number of infectious individuals will remain small, with the size of the outbreak determined by the size of the connected component containing the initially infectious node.</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>Through this quick analysis, we see that even in the simplest epidemic model, network structure introduces stochasticity into the dynamics. </span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a><span class="fu">### The SIR model</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>To make the model slightly more realistic, we could assume that agents could eventually recover from the disease, while keeping the other parameters and assumptions as above. We will assume that recovered individuals are no longer infectious (they cannot spread the disease to other agents) and they are also no longer susceptible (they have developed immunity to future infections). Let $R(t)$ denote the class of recovered individuals at time $t$. Now, $N = S(t) + I(t) + R(t).$ This model is called an **SIR model**.</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>As in the SI model, the *transmission probability* between an infectious nodes $i$ and susceptible node $j$ is </span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>    \phi_{ij} = 1 - e^{-\beta \tau_i} \,</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>where $\tau_i$ is the amount of time that an individual $i$ is infectious. In this case, $\tau_i$ is a disease-dependent parameter that can be interpreted as a recovery rate. While this value is often chosen to be a fixed constant, we could also draw $\tau_i$ from a distribution or allow it to depend on other node properties. </span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>Notice that we have a key difference in our dynamics due to the introduction of the recovered class. Unlike in the SI model, it is possible for an infectious node to recover before it infects its susceptible neighbors, thus limiting the spread of disease.</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>Intuitively we can see the qualitative effects of our parameters $\beta$ and $\tau$. If either (or both) of these parameters are small, then the transmission probability $\phi$ will also be small. In this regime, we expect the outbreak to reach a limited number of agents and exist only in isolated clusters.</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a><span class="al">![](../assets/img/percolation-example.png)</span></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>As $\phi$ increases, we will eventually reach a *percolation transition* where a large "cluster" forms, and thus an epidemic (i.e., a large outbreak) is possible. Again, if $S$ is the fraction of nodes in the cluster, the size of the outbreak will be $NS$ will probability $S$. Note that a large value of $\phi$ doesn't guarantee an epidemic --- this is a stochastic process and it is possible for the disease to die out by chance.</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a><span class="fu">### SIR on configuration model networks</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>Now that we have some intuition behind the effect of parameters in the SIR model, let's calculate the size distribution of the epidemic as well as the epidemic threshold. The mathematical ideas we use in this section come from the study of bond percolation (see @sahimi2023applications).</span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>Suppose we have a configuration model with degree distribution $p_k$. We will initially choose one node uniformly at random to be infectious. The transmission probability (as derived in the previous section) will be denoted $\phi$; we can also think of this as an edge "occupation" probability. We will assume that transmission along each edge is independent.</span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>What is the probability that a node $i$ is connected to a giant percolation cluster (that is, in an epidemic)? It's easier to calculate the expected probability $u$ that a node is {\em not} connected to the giant percolation cluster via one of its edges, say $(i,j)$. This can happen one of two ways:</span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>The edge $(i,j)$ is unoccupied (no transmission of infection between $i$ and $j$):</span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>    \mathbb{P}(\text{edge unoccupied}) = 1 - \phi,.</span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>The edge is occupied (infection has been transmitted between $i$ and $j$), but $j$ is not connected to the giant cluster (no transmission between node $j$ and any of its $k$ neighbors):</span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a>    \mathbb{P}(j \text{ not connected to giant cluster by any of } k \text{ edges}) = u^k \,,</span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>and so </span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>    \mathbb{P}((i,j) \text{ occupied and } j \text{ not connected by any of } k \text{ edges}) = \phi u^k \,,</span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a>&lt;img src="../assets/img/second-neighbors.png" alt="second neighbors" width="200"/&gt;</span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a>Combining (1) and (2) gives our desired quantity:</span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a>    \mathbb{P}(i \text{ not connected to giant cluster via degree} (k+1) \text{ neighbor}) = 1 - \phi + \phi u^k \,. </span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a>We know that, for a configuration model with degree distribution given by $p_k$, the value of $k$ is distributed according to the excess degree distribution</span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a>    q_k = \frac{(k+1)p_{k+1}}{\langle k \rangle} \,,</span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a>where $\langle k \rangle$ is the mean degree.</span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a>Summing over all possible values of $k$ gives</span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb1-95"><a href="#cb1-95" aria-hidden="true" tabindex="-1"></a>    u &amp;= \sum_{k=0}^\infty q_k \left(1-\phi+\phi u^k\right) \nonumber <span class="sc">\\</span></span>
<span id="cb1-96"><a href="#cb1-96" aria-hidden="true" tabindex="-1"></a>    &amp;= \sum_{k=0}^\infty q_k - \phi \sum_{k=0}^\infty q_k + \phi \sum_{k=0}^\infty q_k u^k \nonumber <span class="sc">\\</span></span>
<span id="cb1-97"><a href="#cb1-97" aria-hidden="true" tabindex="-1"></a>    &amp;= 1 - \phi + \phi g_1(u) \,,</span>
<span id="cb1-98"><a href="#cb1-98" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb1-99"><a href="#cb1-99" aria-hidden="true" tabindex="-1"></a>$$ {#eq-u-prob}</span>
<span id="cb1-100"><a href="#cb1-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-101"><a href="#cb1-101" aria-hidden="true" tabindex="-1"></a>where $g_1(u)$ is the generating function associated with the excess degree distribution for our network. In general, @eq-u-prob may be difficult to solve, or may not have a closed form solution. However, we can use a graphical method to get insight into the epidemic threshold. </span>
<span id="cb1-102"><a href="#cb1-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-103"><a href="#cb1-103" aria-hidden="true" tabindex="-1"></a>We know that $g_1(u)$ is a polynomial with nonnegative coefficients because it is a probability generating function. Therefore, for $u \in <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>$, we know</span>
<span id="cb1-104"><a href="#cb1-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-105"><a href="#cb1-105" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$g_1(u) \geq 0$,</span>
<span id="cb1-106"><a href="#cb1-106" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>all derivatives of $g_1$ with respect to $u$ are nonnegative, and</span>
<span id="cb1-107"><a href="#cb1-107" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$g_1(1) = 1$.</span>
<span id="cb1-108"><a href="#cb1-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-109"><a href="#cb1-109" aria-hidden="true" tabindex="-1"></a>We look for intersections of $u$ and $1- \phi + \phi g_1(u) = y$. To calculate $y$, we take $g_1(u)$ and shift up by $1- \phi$ and multiply by $\phi$.</span>
<span id="cb1-110"><a href="#cb1-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-111"><a href="#cb1-111" aria-hidden="true" tabindex="-1"></a>If $\phi$ is sufficiently large, we will see the following qualitative behavior:</span>
<span id="cb1-112"><a href="#cb1-112" aria-hidden="true" tabindex="-1"></a><span class="al">![](../assets/img/large-phi.png)</span></span>
<span id="cb1-113"><a href="#cb1-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-114"><a href="#cb1-114" aria-hidden="true" tabindex="-1"></a>As $\phi$ decreases, then eventually at $\phi = \phi_c$ the second intersection disappears:</span>
<span id="cb1-115"><a href="#cb1-115" aria-hidden="true" tabindex="-1"></a><span class="al">![](../assets/img/critical-phi.png)</span></span>
<span id="cb1-116"><a href="#cb1-116" aria-hidden="true" tabindex="-1"></a><span class="al">![](../assets/img/small-phi.png)</span></span>
<span id="cb1-117"><a href="#cb1-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-118"><a href="#cb1-118" aria-hidden="true" tabindex="-1"></a>Inspired by our sketches, we can calculate the value of $\phi_c$ by noticing this transition occurs when the curve is tangent to the identity line at $u=1$, that is,</span>
<span id="cb1-119"><a href="#cb1-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-120"><a href="#cb1-120" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-121"><a href="#cb1-121" aria-hidden="true" tabindex="-1"></a>    \begin{aligned}</span>
<span id="cb1-122"><a href="#cb1-122" aria-hidden="true" tabindex="-1"></a>    \frac{d}{du} \left<span class="co">[</span><span class="ot"> 1 - \phi_c + \phi_c g_1(u)\right</span><span class="co">]</span> \bigg \vert_{u=1} = 1 \,, <span class="sc">\\</span></span>
<span id="cb1-123"><a href="#cb1-123" aria-hidden="true" tabindex="-1"></a>    \rightarrow \phi_c g_1'(1) = 1 \,, <span class="sc">\\</span></span>
<span id="cb1-124"><a href="#cb1-124" aria-hidden="true" tabindex="-1"></a>    \rightarrow \phi_c = \frac{1}{g_1'(1)} \,.</span>
<span id="cb1-125"><a href="#cb1-125" aria-hidden="true" tabindex="-1"></a>    \end{aligned}</span>
<span id="cb1-126"><a href="#cb1-126" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-127"><a href="#cb1-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-128"><a href="#cb1-128" aria-hidden="true" tabindex="-1"></a>We have previously calculated the quantity $g_1'(1)$ in terms of the degree distribution in @sec-secondneighbors: this is the expected excess degree, which is given by $\frac{\langle k^2\rangle - \langle k \rangle}{\langle k \rangle}$. Thus, </span>
<span id="cb1-129"><a href="#cb1-129" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-130"><a href="#cb1-130" aria-hidden="true" tabindex="-1"></a>    \phi_c = \frac{\langle k \rangle}{\langle k^2\rangle - \langle k \rangle} \,.</span>
<span id="cb1-131"><a href="#cb1-131" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-132"><a href="#cb1-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-133"><a href="#cb1-133" aria-hidden="true" tabindex="-1"></a>We can even write this in terms of model parameters $\beta$ and $\tau$. Since $\phi_c = 1-e^{-\beta \tau}$, we have</span>
<span id="cb1-134"><a href="#cb1-134" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-135"><a href="#cb1-135" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb1-136"><a href="#cb1-136" aria-hidden="true" tabindex="-1"></a>    \beta \tau &amp;= -\ln \left(1-\phi_c \right) <span class="sc">\\</span></span>
<span id="cb1-137"><a href="#cb1-137" aria-hidden="true" tabindex="-1"></a>    &amp; = -\ln \left<span class="co">[</span><span class="ot"> \frac{\langle k^2 \rangle- \langle k \rangle - \langle k \rangle}{\langle k^2 \rangle- \langle k \rangle} \right</span><span class="co">]</span> <span class="sc">\\</span></span>
<span id="cb1-138"><a href="#cb1-138" aria-hidden="true" tabindex="-1"></a>    &amp;= \ln \left<span class="co">[</span><span class="ot"> \frac{\langle k^2 \rangle- \langle k \rangle}{\langle k^2 \rangle- 2\langle k \rangle} \right</span><span class="co">]</span> \,.</span>
<span id="cb1-139"><a href="#cb1-139" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb1-140"><a href="#cb1-140" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-141"><a href="#cb1-141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-142"><a href="#cb1-142" aria-hidden="true" tabindex="-1"></a>If the product $\beta \tau$ is less than this value, we do not expect an epidemic. However, if $\beta \tau$ is larger than this value, then an epidemic is possible! This helps us link disease model parameters to network structure.</span>
<span id="cb1-143"><a href="#cb1-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-144"><a href="#cb1-144" aria-hidden="true" tabindex="-1"></a>The argument to approximate the size of the outbreak is similar to what we have done previously. Let $S$ be the fraction of nodes in the giant percolation cluster. Since $u$ is the probability that a node is not connected to a giant cluster via a particular edge, a node with $k$ edges is not connected to the giant cluster with probability $u^k$. </span>
<span id="cb1-145"><a href="#cb1-145" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-146"><a href="#cb1-146" aria-hidden="true" tabindex="-1"></a>For the network, we expect that</span>
<span id="cb1-147"><a href="#cb1-147" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-148"><a href="#cb1-148" aria-hidden="true" tabindex="-1"></a>    \mathbb{P}(\text{not in cluster}) = \sum_{k=0}^\infty p_k u^k = g_0(u)\,,</span>
<span id="cb1-149"><a href="#cb1-149" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-150"><a href="#cb1-150" aria-hidden="true" tabindex="-1"></a>and so</span>
<span id="cb1-151"><a href="#cb1-151" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-152"><a href="#cb1-152" aria-hidden="true" tabindex="-1"></a>    \mathbb{P}(\text{in cluster}) = S = 1-g_0(u)\,.</span>
<span id="cb1-153"><a href="#cb1-153" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-154"><a href="#cb1-154" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-155"><a href="#cb1-155" aria-hidden="true" tabindex="-1"></a>As before, the expected size of the outbreak is $NS$, which occurs with probability $S$. Note that, unlike in the SI model, $S$ depends on $\beta$ and $\tau$. If these values exceed the threshold, then an epidemic is possible, if the infection is introduced in the giant cluster.</span>
<span id="cb1-156"><a href="#cb1-156" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-157"><a href="#cb1-157" aria-hidden="true" tabindex="-1"></a><span class="fu">## Time-dependent properties of epidemics on networks</span></span>
<span id="cb1-158"><a href="#cb1-158" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-159"><a href="#cb1-159" aria-hidden="true" tabindex="-1"></a>If we want to understand the dynamic evolution and understand the progression of the disease spread in time (not just the limiting behavior) in an analytic way, we need to develope additional techniques. One strategy is to leverage tools from differential equations to study the evolution of the probabilities of a particular node have a particular state at time $t$. We'll give a taste of the methods here for the SI model. @porter2016dynamical provide a resource for further techniques for dynamical systems on networks.</span>
<span id="cb1-160"><a href="#cb1-160" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-161"><a href="#cb1-161" aria-hidden="true" tabindex="-1"></a><span class="fu">### SI model</span></span>
<span id="cb1-162"><a href="#cb1-162" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-163"><a href="#cb1-163" aria-hidden="true" tabindex="-1"></a>Imagine running many simulations of an SI model with the same parameters on the same network with the same initial conditions.</span>
<span id="cb1-164"><a href="#cb1-164" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-165"><a href="#cb1-165" aria-hidden="true" tabindex="-1"></a>For node $i$, define $S_i(t) =$ expected probability that node $i$ is susceptible at time $t$, and $X_i(t) = $ expected probability that node $i$ is infected at time $t$. As before, we'll assume infections occur with probability $\beta dt$ if node $i$ is susceptible and connected to an infectious node $j$.</span>
<span id="cb1-166"><a href="#cb1-166" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-167"><a href="#cb1-167" aria-hidden="true" tabindex="-1"></a>Then, we can write equations to describe how these quantities evolve in time. </span>
<span id="cb1-168"><a href="#cb1-168" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-169"><a href="#cb1-169" aria-hidden="true" tabindex="-1"></a>    \begin{aligned}</span>
<span id="cb1-170"><a href="#cb1-170" aria-hidden="true" tabindex="-1"></a>        \frac{dS_i(t)}{dt} &amp;= -\beta S_i \sum_{j=1}^n A_{ij}X_j <span class="sc">\\</span></span>
<span id="cb1-171"><a href="#cb1-171" aria-hidden="true" tabindex="-1"></a>        \frac{dX_i(t)}{dt} &amp;= \beta S_i  \sum_{j=1}^n A_{ij}X_j</span>
<span id="cb1-172"><a href="#cb1-172" aria-hidden="true" tabindex="-1"></a>    \end{aligned}</span>
<span id="cb1-173"><a href="#cb1-173" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-174"><a href="#cb1-174" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-175"><a href="#cb1-175" aria-hidden="true" tabindex="-1"></a>Note that, because we have a conserved quantity $X_i(t) + S_i(t) = 1$, these two equations are redundant. The system can be reduced to an equation describing the evolution of the probability that node $i$ is infected:</span>
<span id="cb1-176"><a href="#cb1-176" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-177"><a href="#cb1-177" aria-hidden="true" tabindex="-1"></a>    \frac{dX_i(t)}{dt} = \beta (1-X_i)\sum_{j=1}^n A_{ij}X_j = \beta \sum_{j=1}^n A_{ij}X_j - \beta X_i \sum_{j=1}^n A_{ij}X_j \,.</span>
<span id="cb1-178"><a href="#cb1-178" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-179"><a href="#cb1-179" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-180"><a href="#cb1-180" aria-hidden="true" tabindex="-1"></a>Now, we have a system of $n$ ordinary differential equations for infection probabilities, which are coupled through the network structure. For an arbitrary adjacency matrix $A$ this system does not have a closed-form solution. However, we can learn something about the behavior for small $t$ (the beginning of an outbreak) by considering suitable limits.</span>
<span id="cb1-181"><a href="#cb1-181" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-182"><a href="#cb1-182" aria-hidden="true" tabindex="-1"></a>Assume we use an initial condition where we infect only a single node selected uniformly at random. In this case, $X_i(0) = \frac{1}{n}$ and $S_i(0) = 1-\frac{1}{n}$.</span>
<span id="cb1-183"><a href="#cb1-183" aria-hidden="true" tabindex="-1"></a>Consider the large-$n$ limit ($n \to \infty$). In other words, when $n$ is large, $S_i(0) \approx 1$ and $X_i(0)$ is extremely small for all $i$. Thus, for sufficiently small $t$, the quadratic term $X_iX_j$ is much smaller than the linear term. This observation allows us to write an approximate linear system</span>
<span id="cb1-184"><a href="#cb1-184" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-185"><a href="#cb1-185" aria-hidden="true" tabindex="-1"></a>    \frac{dX_i}{dt} \approx \beta \sum_{j=1}^n A_{ij}X_j.</span>
<span id="cb1-186"><a href="#cb1-186" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-187"><a href="#cb1-187" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-188"><a href="#cb1-188" aria-hidden="true" tabindex="-1"></a>Writing ${\bf x}(t)$ as the vector $(X_1(t), X_2(t), \dots X_n(t))^T$ containing the probabilities for each node, we can write our system in matrix form</span>
<span id="cb1-189"><a href="#cb1-189" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-190"><a href="#cb1-190" aria-hidden="true" tabindex="-1"></a>    \frac{d}{dt}{\bf x} \approx \beta A {\bf x}\,.</span>
<span id="cb1-191"><a href="#cb1-191" aria-hidden="true" tabindex="-1"></a>$$ {#eq-linearSI}</span>
<span id="cb1-192"><a href="#cb1-192" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-193"><a href="#cb1-193" aria-hidden="true" tabindex="-1"></a>We can study the solutions of the linearized system by studying the eigenvalues and eigenvectors of $A$. Let ${\bf v}_r$ be the eigenvector with associated eigenvalue $\lambda_r$, so that $A{\bf v}_r = \lambda_r {\bf v}_r$. If we write ${\bf x}$ as a linear combination of the eigenvectors of $A$, we have</span>
<span id="cb1-194"><a href="#cb1-194" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-195"><a href="#cb1-195" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-196"><a href="#cb1-196" aria-hidden="true" tabindex="-1"></a>    {\bf x} = \sum_{r=1}^n c_r(t) {\bf v}_r \,,</span>
<span id="cb1-197"><a href="#cb1-197" aria-hidden="true" tabindex="-1"></a>$$ {#eq-eigsLC}</span>
<span id="cb1-198"><a href="#cb1-198" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-199"><a href="#cb1-199" aria-hidden="true" tabindex="-1"></a>where $c_r(t)$ are the time-dependent coefficients of this linear combination. Substituting @eq-eigsLC into @eq-linearSI gives</span>
<span id="cb1-200"><a href="#cb1-200" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-201"><a href="#cb1-201" aria-hidden="true" tabindex="-1"></a>    \frac{d}{dt} {\bf x} = \sum_{r=1}^n \frac{dc_r}{dt} {\bf v}_r = \beta \sum_{r=1}^n c_r(t) \lambda_r {\bf v}_r \,.</span>
<span id="cb1-202"><a href="#cb1-202" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-203"><a href="#cb1-203" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-204"><a href="#cb1-204" aria-hidden="true" tabindex="-1"></a>Therefore, for each term, we have a first-order linear differential equation describing the coefficients</span>
<span id="cb1-205"><a href="#cb1-205" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-206"><a href="#cb1-206" aria-hidden="true" tabindex="-1"></a>    \frac{dc_r}{dt} = \beta \lambda_r c_r \ \Rightarrow \ c_r(t) = c_r(0)e^{\beta \lambda_r t} \,.</span>
<span id="cb1-207"><a href="#cb1-207" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-208"><a href="#cb1-208" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-209"><a href="#cb1-209" aria-hidden="true" tabindex="-1"></a>Finally, substitute this expression for the time-dependent coefficients into @eq-eigsLC to get the solution for ${\bf x}$:</span>
<span id="cb1-210"><a href="#cb1-210" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-211"><a href="#cb1-211" aria-hidden="true" tabindex="-1"></a>    {\bf x} = \sum_{r=1}^n c_r(0)e^{\beta \lambda_r t}{\bf v}_r\,.</span>
<span id="cb1-212"><a href="#cb1-212" aria-hidden="true" tabindex="-1"></a>$$ </span>
<span id="cb1-213"><a href="#cb1-213" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-214"><a href="#cb1-214" aria-hidden="true" tabindex="-1"></a>Our solution will be dominated by the fasted growing term (i.e., the largest magnitude eigenvalue, which we will call $\lambda_1$).</span>
<span id="cb1-215"><a href="#cb1-215" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-216"><a href="#cb1-216" aria-hidden="true" tabindex="-1"></a>    {\bf x}(t) \sim e^{\beta \lambda_1 t} {\bf v}_1 \,.</span>
<span id="cb1-217"><a href="#cb1-217" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-218"><a href="#cb1-218" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-219"><a href="#cb1-219" aria-hidden="true" tabindex="-1"></a>This means that in the early stages of the disease spread, we expect the number of infectious individuals to grow exponentially. The growth rate is determined by the largest magnitude eigenvalue $\lambda_1$ of the adjacency matrix, and the probability varies for different nodes. These probabilities correspond to different components of ${\bf v}_1$.</span>
<span id="cb1-220"><a href="#cb1-220" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-221"><a href="#cb1-221" aria-hidden="true" tabindex="-1"></a>In fact, we have met such a vector before. The components of the leading eigenvector are what we previously defined as eigenvector centralities --- so this centrality measure gives an approximation to early infection time probability in an SI model!</span>
<span id="cb1-222"><a href="#cb1-222" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-223"><a href="#cb1-223" aria-hidden="true" tabindex="-1"></a>We have made several approximations in this analysis. In particular, in order to study the linearized problem, we have neglected correlations between neighbors. However, $S_i$ and $X_j$ are not necessarily independent! This can be accounted for using pair approximation (or moment closure) methods; see @porter2016dynamical.</span>
<span id="cb1-224"><a href="#cb1-224" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-225"><a href="#cb1-225" aria-hidden="true" tabindex="-1"></a><span class="fu">## References</span></span>
<span id="cb1-226"><a href="#cb1-226" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-227"><a href="#cb1-227" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-228"><a href="#cb1-228" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-229"><a href="#cb1-229" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-230"><a href="#cb1-230" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-231"><a href="#cb1-231" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-232"><a href="#cb1-232" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-233"><a href="#cb1-233" aria-hidden="true" tabindex="-1"></a></span></code><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->




</body></html>