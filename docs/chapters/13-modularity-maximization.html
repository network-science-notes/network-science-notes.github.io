<!DOCTYPE html>

<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><head>
<meta charset="utf-8"/>
<meta content="quarto-1.6.10" name="generator"/>
<meta content="width=device-width, initial-scale=1.0, user-scalable=yes" name="viewport"/>
<title>12  Community Detection and Modularity Maximization – Network Science: Models, Mathematics, and Computation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>
<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta content="../" name="quarto:offset"/>
<link href="../chapters/19-spectral-clustering.html" rel="next"/>
<link href="../chapters/06-modularity.html" rel="prev"/>
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet"/>
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-2d9718c933debafcce942f9b212640bc.css" id="quarto-text-highlighting-styles" rel="stylesheet"/>
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet"/>
<link append-hash="true" data-mode="light" href="../site_libs/bootstrap/bootstrap-c1bdd270c1c0708cd2ff05417efafcc5.min.css" id="quarto-bootstrap" rel="stylesheet"/>
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-80H959492S"></script>
<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-80H959492S', { 'anonymize_ip': true});
</script>
<script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>
<link href="../styles.css" rel="stylesheet"/>
</head>
<body class="nav-sidebar floating slimcontent">
<div id="quarto-search-results"></div>
<header class="headroom fixed-top" id="quarto-header">
<nav class="quarto-secondary-nav">
<div class="container-fluid d-flex">
<button aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" class="quarto-btn-toggle btn" data-bs-target=".quarto-sidebar-collapse-item" data-bs-toggle="collapse" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }" role="button" type="button">
<i class="bi bi-layout-text-sidebar-reverse"></i>
</button>
<nav aria-label="breadcrumb" class="quarto-page-breadcrumbs"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../chapters/06-modularity.html">Network Algorithms</a></li><li class="breadcrumb-item"><a href="../chapters/13-modularity-maximization.html"><span class="chapter-number">12</span>  <span class="chapter-title">Community Detection and Modularity Maximization</span></a></li></ol></nav>
<a aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" class="flex-grow-1" data-bs-target=".quarto-sidebar-collapse-item" data-bs-toggle="collapse" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }" role="navigation">
</a>
</div>
</nav>
</header>
<!-- content -->
<div class="quarto-container page-columns page-rows-contents page-layout-article" id="quarto-content">
<!-- sidebar -->
<nav class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto" id="quarto-sidebar">
<div class="pt-lg-2 mt-2 text-left sidebar-header">
<div class="sidebar-title mb-0 py-0">
<a href="../">Network Science: Models, Mathematics, and Computation</a>
</div>
</div>
<div class="sidebar-menu-container">
<ul class="list-unstyled mt-1">
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../index.html">
<span class="menu-text">Welcome</span></a>
</div>
</li>
<li class="sidebar-item sidebar-item-section">
<div class="sidebar-item-container">
<a aria-expanded="true" class="sidebar-item-text sidebar-link text-start" data-bs-target="#quarto-sidebar-section-1" data-bs-toggle="collapse" role="navigation">
<span class="menu-text">Network Fundamentals</span></a>
<a aria-expanded="true" aria-label="Toggle section" class="sidebar-item-toggle text-start" data-bs-target="#quarto-sidebar-section-1" data-bs-toggle="collapse" role="navigation">
<i class="bi bi-chevron-right ms-2"></i>
</a>
</div>
<ul class="collapse list-unstyled sidebar-section depth1 show" id="quarto-sidebar-section-1">
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/01-networkrepresentations.html">
<span class="menu-text"><span class="chapter-number">1</span>  <span class="chapter-title">Networks and Their Representations</span></span></a>
</div>
</li>
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/02-degree-walks-paths.html">
<span class="menu-text"><span class="chapter-number">2</span>  <span class="chapter-title">Degree, Walks, and Paths</span></span></a>
</div>
</li>
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/03-components-laplacian.html">
<span class="menu-text"><span class="chapter-number">3</span>  <span class="chapter-title">Components and the Graph Laplacian</span></span></a>
</div>
</li>
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/04-centrality.html">
<span class="menu-text"><span class="chapter-number">4</span>  <span class="chapter-title">Centrality and Importance</span></span></a>
</div>
</li>
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/05-viz.html">
<span class="menu-text"><span class="chapter-number">5</span>  <span class="chapter-title">Visualizing Networks and Why You Shouldn’t</span></span></a>
</div>
</li>
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/07-real-world.html">
<span class="menu-text"><span class="chapter-number">6</span>  <span class="chapter-title">Structure of Empirical Networks</span></span></a>
</div>
</li>
</ul>
</li>
<li class="sidebar-item sidebar-item-section">
<div class="sidebar-item-container">
<a aria-expanded="true" class="sidebar-item-text sidebar-link text-start" data-bs-target="#quarto-sidebar-section-2" data-bs-toggle="collapse" role="navigation">
<span class="menu-text">Models of Networks</span></a>
<a aria-expanded="true" aria-label="Toggle section" class="sidebar-item-toggle text-start" data-bs-target="#quarto-sidebar-section-2" data-bs-toggle="collapse" role="navigation">
<i class="bi bi-chevron-right ms-2"></i>
</a>
</div>
<ul class="collapse list-unstyled sidebar-section depth1 show" id="quarto-sidebar-section-2">
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/09-random-graphs.html">
<span class="menu-text"><span class="chapter-number">7</span>  <span class="chapter-title">Random Graphs: Erdős–Rényi</span></span></a>
</div>
</li>
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/10-configuration-model.html">
<span class="menu-text"><span class="chapter-number">8</span>  <span class="chapter-title">Degree-Preserving Random Graphs</span></span></a>
</div>
</li>
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/11-generating-functions.html">
<span class="menu-text"><span class="chapter-number">9</span>  <span class="chapter-title">Probability Generating Functions</span></span></a>
</div>
</li>
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/120-preferential-attachment.html">
<span class="menu-text"><span class="chapter-number">10</span>  <span class="chapter-title">Preferential Attachment and Power Laws</span></span></a>
</div>
</li>
</ul>
</li>
<li class="sidebar-item sidebar-item-section">
<div class="sidebar-item-container">
<a aria-expanded="true" class="sidebar-item-text sidebar-link text-start" data-bs-target="#quarto-sidebar-section-3" data-bs-toggle="collapse" role="navigation">
<span class="menu-text">Network Algorithms</span></a>
<a aria-expanded="true" aria-label="Toggle section" class="sidebar-item-toggle text-start" data-bs-target="#quarto-sidebar-section-3" data-bs-toggle="collapse" role="navigation">
<i class="bi bi-chevron-right ms-2"></i>
</a>
</div>
<ul class="collapse list-unstyled sidebar-section depth1 show" id="quarto-sidebar-section-3">
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/06-modularity.html">
<span class="menu-text"><span class="chapter-number">11</span>  <span class="chapter-title">Homophily, Assortativity, and Modularity</span></span></a>
</div>
</li>
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link active" href="../chapters/13-modularity-maximization.html">
<span class="menu-text"><span class="chapter-number">12</span>  <span class="chapter-title">Community Detection and Modularity Maximization</span></span></a>
</div>
</li>
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/19-spectral-clustering.html">
<span class="menu-text"><span class="chapter-number">13</span>  <span class="chapter-title">Spectral Clustering</span></span></a>
</div>
</li>
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/41-link-prediction.html">
<span class="menu-text"><span class="chapter-number">14</span>  <span class="chapter-title">Link Prediction and Feedback Loops</span></span></a>
</div>
</li>
</ul>
</li>
<li class="sidebar-item sidebar-item-section">
<div class="sidebar-item-container">
<a aria-expanded="true" class="sidebar-item-text sidebar-link text-start" data-bs-target="#quarto-sidebar-section-4" data-bs-toggle="collapse" role="navigation">
<span class="menu-text">Applications and Extensions</span></a>
<a aria-expanded="true" aria-label="Toggle section" class="sidebar-item-toggle text-start" data-bs-target="#quarto-sidebar-section-4" data-bs-toggle="collapse" role="navigation">
<i class="bi bi-chevron-right ms-2"></i>
</a>
</div>
<ul class="collapse list-unstyled sidebar-section depth1 show" id="quarto-sidebar-section-4">
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/50-random-walks.html">
<span class="menu-text"><span class="chapter-number">15</span>  <span class="chapter-title">Random Walks</span></span></a>
</div>
</li>
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/51-agent-based-modeling.html">
<span class="menu-text"><span class="chapter-number">16</span>  <span class="chapter-title">Agent-Based Modeling on Networks</span></span></a>
</div>
</li>
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/53-epidemiology-computational.html">
<span class="menu-text"><span class="chapter-number">17</span>  <span class="chapter-title">Agent-Based Models of Epidemics on Networks</span></span></a>
</div>
</li>
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/52-epidemiology.html">
<span class="menu-text"><span class="chapter-number">18</span>  <span class="chapter-title">Epidemic Models on Networks</span></span></a>
</div>
</li>
</ul>
</li>
<li class="sidebar-item sidebar-item-section">
<span class="sidebar-item-text sidebar-link text-start">
<span class="menu-text">Appendices</span></span>
</li>
</ul>
</div>
</nav>
<div class="quarto-sidebar-collapse-item" data-bs-target=".quarto-sidebar-collapse-item" data-bs-toggle="collapse" id="quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
<div class="sidebar margin-sidebar" id="quarto-margin-sidebar">
<nav class="toc-active" id="TOC" role="doc-toc">
<h2 id="toc-title">Contents</h2>
<ul>
<li><a class="nav-link active" data-scroll-target="#recall-measuring-assortativity-with-modularity" href="#recall-measuring-assortativity-with-modularity" id="toc-recall-measuring-assortativity-with-modularity">Recall: Measuring Assortativity with Modularity</a></li>
<li><a class="nav-link" data-scroll-target="#the-community-detection-problem" href="#the-community-detection-problem" id="toc-the-community-detection-problem">The Community Detection Problem</a>
<ul class="collapse">
<li><a class="nav-link" data-scroll-target="#community-detection-as-optimization" href="#community-detection-as-optimization" id="toc-community-detection-as-optimization">Community Detection as Optimization</a></li>
</ul></li>
<li><a class="nav-link" data-scroll-target="#a-community-detection-algorithm-greedy-agglomerative-clustering" href="#a-community-detection-algorithm-greedy-agglomerative-clustering" id="toc-a-community-detection-algorithm-greedy-agglomerative-clustering">A Community Detection Algorithm: Greedy Agglomerative Clustering</a></li>
<li><a class="nav-link" data-scroll-target="#validation-of-community-detection-algorithms" href="#validation-of-community-detection-algorithms" id="toc-validation-of-community-detection-algorithms">Validation of Community Detection Algorithms</a></li>
<li><a class="nav-link" data-scroll-target="#other-approaches" href="#other-approaches" id="toc-other-approaches">Other Approaches</a></li>
<li><a class="nav-link" data-scroll-target="#references" href="#references" id="toc-references">References</a></li>
</ul>
</nav>
</div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">
<header class="quarto-title-block default" id="title-block-header"><nav aria-label="breadcrumb" class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../chapters/06-modularity.html">Network Algorithms</a></li><li class="breadcrumb-item"><a href="../chapters/13-modularity-maximization.html"><span class="chapter-number">12</span>  <span class="chapter-title">Community Detection and Modularity Maximization</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">12</span>  <span class="chapter-title">Community Detection and Modularity Maximization</span></h1>
</div>
<div class="quarto-title-meta">
</div>
</header>
<p><em>Open the live notebook in Google Colab <a href="https://colab.research.google.com/github/network-science-notes/network-science-notes.github.io/blob/main/docs/live-notebooks/13-modularity-maximization.ipynb">here</a>.</em></p>
<p>In a <a href="../chapters/06-modularity.html">previous lecture</a>, we introduced the idea of <em>assortativity</em> in networks. Roughly, a network is assortative with respect to some attribute if nodes which share that attribute are more likely to be connected to each other than to nodes without that attribute.</p>
<p>Our data for this set of lecture notes is a data set of social interactions between students at a French high school in 2012. The data was collected by <span class="citation" data-cites="fournet2014contact">Fournet and Barrat (<a href="#ref-fournet2014contact" role="doc-biblioref">2014</a>)</span> as part of the <a href="http://www.sociopatterns.org/">SocioPatterns project</a>. Students were given wearable sensors which would ping when two students were in close proximity and facing each other. Each of these pings is an edge in the raw data, although in our processing for this lecture we simplify the data set down so that there is an edge between each pair of students who interacted at all during the data collection period.</p>
<p>In this high school, students were tracked into one of five classes:</p>
<ol type="1">
<li>MP*1 and MP*2 were two classes focusing on mathematics and physics.</li>
<li>PC and PC* were two classes focusing on physics and chemistry.</li>
<li>PSI* was one class focusing on engineering.</li>
</ol>
<p>We might reasonably expect that students in the same class would interact more with each other than with students in other classes. Let’s acquire the data and visualize the network to begin to develop a feel for this idea.</p>
<div class="cell" data-execution_count="1" id="f1c6cc27">
<details class="code-fold">
<summary>Show code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a aria-hidden="true" href="#cb1-1" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-2"><a aria-hidden="true" href="#cb1-2" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a aria-hidden="true" href="#cb1-3" tabindex="-1"></a><span class="im">import</span> networkx <span class="im">as</span> nx</span>
<span id="cb1-4"><a aria-hidden="true" href="#cb1-4" tabindex="-1"></a><span class="im">from</span> matplotlib <span class="im">import</span> pyplot <span class="im">as</span> plt</span>
<span id="cb1-5"><a aria-hidden="true" href="#cb1-5" tabindex="-1"></a><span class="im">from</span> matplotlib.lines <span class="im">import</span> Line2D <span class="co"># for legend later</span></span>
<span id="cb1-6"><a aria-hidden="true" href="#cb1-6" tabindex="-1"></a>plt.style.use(<span class="st">'seaborn-v0_8-whitegrid'</span>)</span>
<span id="cb1-7"><a aria-hidden="true" href="#cb1-7" tabindex="-1"></a></span>
<span id="cb1-8"><a aria-hidden="true" href="#cb1-8" tabindex="-1"></a><span class="kw">def</span> unweight(G):</span>
<span id="cb1-9"><a aria-hidden="true" href="#cb1-9" tabindex="-1"></a>    <span class="cf">for</span> source, target <span class="kw">in</span> G.edges():</span>
<span id="cb1-10"><a aria-hidden="true" href="#cb1-10" tabindex="-1"></a>        G[source][target][<span class="st">'weight'</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb1-11"><a aria-hidden="true" href="#cb1-11" tabindex="-1"></a>    <span class="cf">return</span> G</span>
<span id="cb1-12"><a aria-hidden="true" href="#cb1-12" tabindex="-1"></a></span>
<span id="cb1-13"><a aria-hidden="true" href="#cb1-13" tabindex="-1"></a><span class="kw">def</span> acquire_contact_data():</span>
<span id="cb1-14"><a aria-hidden="true" href="#cb1-14" tabindex="-1"></a>    url <span class="op">=</span> <span class="st">"https://raw.githubusercontent.com/network-science-notes/network-science-notes.github.io/refs/heads/main/data/contact-high-school.csv"</span></span>
<span id="cb1-15"><a aria-hidden="true" href="#cb1-15" tabindex="-1"></a></span>
<span id="cb1-16"><a aria-hidden="true" href="#cb1-16" tabindex="-1"></a>    contact <span class="op">=</span> pd.read_csv(url, sep <span class="op">=</span> <span class="st">"</span><span class="ch">\t</span><span class="st">"</span>, names <span class="op">=</span> [<span class="st">"time"</span>, <span class="st">"source"</span>, <span class="st">"target"</span>, <span class="st">"class_s"</span>, <span class="st">"class_t"</span>])[[<span class="st">"source"</span>, <span class="st">"target"</span>, <span class="st">"class_s"</span>, <span class="st">"class_t"</span>]]</span>
<span id="cb1-17"><a aria-hidden="true" href="#cb1-17" tabindex="-1"></a></span>
<span id="cb1-18"><a aria-hidden="true" href="#cb1-18" tabindex="-1"></a>    G <span class="op">=</span> nx.from_pandas_edgelist(contact)</span>
<span id="cb1-19"><a aria-hidden="true" href="#cb1-19" tabindex="-1"></a></span>
<span id="cb1-20"><a aria-hidden="true" href="#cb1-20" tabindex="-1"></a>    class_labels <span class="op">=</span> contact[[<span class="st">"source"</span>, <span class="st">"class_s"</span>]].drop_duplicates(subset<span class="op">=</span>[<span class="st">'source'</span>])</span>
<span id="cb1-21"><a aria-hidden="true" href="#cb1-21" tabindex="-1"></a>    class_labels <span class="op">=</span> <span class="bu">dict</span>(<span class="bu">zip</span>(class_labels[<span class="st">"source"</span>], class_labels[<span class="st">"class_s"</span>]))</span>
<span id="cb1-22"><a aria-hidden="true" href="#cb1-22" tabindex="-1"></a>    more_class_labels <span class="op">=</span> contact[[<span class="st">"target"</span>, <span class="st">"class_t"</span>]].drop_duplicates(subset<span class="op">=</span>[<span class="st">'target'</span>])</span>
<span id="cb1-23"><a aria-hidden="true" href="#cb1-23" tabindex="-1"></a>    more_class_labels <span class="op">=</span> <span class="bu">dict</span>(<span class="bu">zip</span>(more_class_labels[<span class="st">"target"</span>], more_class_labels[<span class="st">"class_t"</span>]))</span>
<span id="cb1-24"><a aria-hidden="true" href="#cb1-24" tabindex="-1"></a></span>
<span id="cb1-25"><a aria-hidden="true" href="#cb1-25" tabindex="-1"></a>    class_labels.update(more_class_labels)</span>
<span id="cb1-26"><a aria-hidden="true" href="#cb1-26" tabindex="-1"></a></span>
<span id="cb1-27"><a aria-hidden="true" href="#cb1-27" tabindex="-1"></a>    classes <span class="op">=</span> [<span class="st">"MP*1"</span>, <span class="st">"MP*2"</span>, <span class="st">"PC"</span>, <span class="st">"PC*"</span>, <span class="st">"PSI*"</span>]</span>
<span id="cb1-28"><a aria-hidden="true" href="#cb1-28" tabindex="-1"></a></span>
<span id="cb1-29"><a aria-hidden="true" href="#cb1-29" tabindex="-1"></a>    class_to_int <span class="op">=</span> {class_label : i <span class="cf">for</span> i, class_label <span class="kw">in</span> <span class="bu">enumerate</span>(classes)}</span>
<span id="cb1-30"><a aria-hidden="true" href="#cb1-30" tabindex="-1"></a></span>
<span id="cb1-31"><a aria-hidden="true" href="#cb1-31" tabindex="-1"></a>    class_labels <span class="op">=</span> {node : class_to_int[label] <span class="cf">for</span> node, label <span class="kw">in</span> class_labels.items()}</span>
<span id="cb1-32"><a aria-hidden="true" href="#cb1-32" tabindex="-1"></a></span>
<span id="cb1-33"><a aria-hidden="true" href="#cb1-33" tabindex="-1"></a>    nx.set_node_attributes(G, class_labels, <span class="st">"class"</span>)</span>
<span id="cb1-34"><a aria-hidden="true" href="#cb1-34" tabindex="-1"></a></span>
<span id="cb1-35"><a aria-hidden="true" href="#cb1-35" tabindex="-1"></a>    G <span class="op">=</span> nx.convert_node_labels_to_integers(G)</span>
<span id="cb1-36"><a aria-hidden="true" href="#cb1-36" tabindex="-1"></a>    G <span class="op">=</span> unweight(G)</span>
<span id="cb1-37"><a aria-hidden="true" href="#cb1-37" tabindex="-1"></a>    <span class="cf">return</span> G</span>
<span id="cb1-38"><a aria-hidden="true" href="#cb1-38" tabindex="-1"></a></span>
<span id="cb1-39"><a aria-hidden="true" href="#cb1-39" tabindex="-1"></a><span class="kw">def</span> draw_graph(G, clusters <span class="op">=</span> <span class="va">None</span>, ax <span class="op">=</span> <span class="va">None</span>, legend <span class="op">=</span> <span class="va">True</span>):</span>
<span id="cb1-40"><a aria-hidden="true" href="#cb1-40" tabindex="-1"></a>    </span>
<span id="cb1-41"><a aria-hidden="true" href="#cb1-41" tabindex="-1"></a></span>
<span id="cb1-42"><a aria-hidden="true" href="#cb1-42" tabindex="-1"></a>    node_kwargs <span class="op">=</span> {<span class="st">"node_size"</span> : <span class="dv">50</span>, <span class="st">"edgecolors"</span> : <span class="st">'black'</span>}</span>
<span id="cb1-43"><a aria-hidden="true" href="#cb1-43" tabindex="-1"></a>    <span class="cf">if</span> clusters <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>: </span>
<span id="cb1-44"><a aria-hidden="true" href="#cb1-44" tabindex="-1"></a>        num_clusters <span class="op">=</span> np.unique(<span class="bu">list</span>(clusters.values())).shape[<span class="dv">0</span>]</span>
<span id="cb1-45"><a aria-hidden="true" href="#cb1-45" tabindex="-1"></a>        cluster_to_color <span class="op">=</span> [plt.cm.Set3(i) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(num_clusters)]</span>
<span id="cb1-46"><a aria-hidden="true" href="#cb1-46" tabindex="-1"></a>        node_kwargs[<span class="st">"node_color"</span>] <span class="op">=</span> [cluster_to_color[clusters[i]] <span class="cf">for</span> i <span class="kw">in</span> G.nodes()]</span>
<span id="cb1-47"><a aria-hidden="true" href="#cb1-47" tabindex="-1"></a>    edge_kwargs <span class="op">=</span> {<span class="st">"edge_color"</span> : <span class="st">"gray"</span>, <span class="st">"alpha"</span> : <span class="fl">0.3</span>}</span>
<span id="cb1-48"><a aria-hidden="true" href="#cb1-48" tabindex="-1"></a>    pos <span class="op">=</span> nx.spring_layout(G)</span>
<span id="cb1-49"><a aria-hidden="true" href="#cb1-49" tabindex="-1"></a>    nx.draw_networkx_edges(G, pos, ax <span class="op">=</span> ax, <span class="op">**</span>edge_kwargs)</span>
<span id="cb1-50"><a aria-hidden="true" href="#cb1-50" tabindex="-1"></a>    nx.draw_networkx_nodes(G, pos, ax <span class="op">=</span> ax, <span class="op">**</span>node_kwargs)</span>
<span id="cb1-51"><a aria-hidden="true" href="#cb1-51" tabindex="-1"></a>    off <span class="op">=</span> ax.axis(<span class="st">"off"</span>)</span>
<span id="cb1-52"><a aria-hidden="true" href="#cb1-52" tabindex="-1"></a></span>
<span id="cb1-53"><a aria-hidden="true" href="#cb1-53" tabindex="-1"></a>    <span class="cf">if</span> (clusters <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>) <span class="kw">and</span> legend: </span>
<span id="cb1-54"><a aria-hidden="true" href="#cb1-54" tabindex="-1"></a>        classes <span class="op">=</span> [<span class="st">"MP*1"</span>, <span class="st">"MP*2"</span>, <span class="st">"PC"</span>, <span class="st">"PC*"</span>, <span class="st">"PSI*"</span>]</span>
<span id="cb1-55"><a aria-hidden="true" href="#cb1-55" tabindex="-1"></a>        legend_elements <span class="op">=</span> [Line2D([<span class="dv">0</span>], [<span class="dv">0</span>], marker<span class="op">=</span><span class="st">'o'</span>, color<span class="op">=</span><span class="st">"black"</span>, label<span class="op">=</span>classes[i], lw<span class="op">=</span><span class="dv">0</span>, markerfacecolor<span class="op">=</span>plt.cm.Set3(i), markersize<span class="op">=</span><span class="dv">10</span>) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">5</span>)]</span>
<span id="cb1-56"><a aria-hidden="true" href="#cb1-56" tabindex="-1"></a></span>
<span id="cb1-57"><a aria-hidden="true" href="#cb1-57" tabindex="-1"></a>        ax.legend(handles<span class="op">=</span>legend_elements, loc<span class="op">=</span><span class="st">'upper right'</span>)</span>
<span id="cb1-58"><a aria-hidden="true" href="#cb1-58" tabindex="-1"></a></span>
<span id="cb1-59"><a aria-hidden="true" href="#cb1-59" tabindex="-1"></a><span class="kw">def</span> labels_to_array(z, G):</span>
<span id="cb1-60"><a aria-hidden="true" href="#cb1-60" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(z, <span class="bu">dict</span>):</span>
<span id="cb1-61"><a aria-hidden="true" href="#cb1-61" tabindex="-1"></a>        z <span class="op">=</span> np.array([z[node] <span class="cf">for</span> node <span class="kw">in</span> G.nodes])</span>
<span id="cb1-62"><a aria-hidden="true" href="#cb1-62" tabindex="-1"></a>    <span class="cf">elif</span> <span class="bu">isinstance</span>(z, <span class="bu">list</span>):</span>
<span id="cb1-63"><a aria-hidden="true" href="#cb1-63" tabindex="-1"></a>        z <span class="op">=</span> np.array(z)</span>
<span id="cb1-64"><a aria-hidden="true" href="#cb1-64" tabindex="-1"></a>    <span class="cf">return</span> z</span></code><button class="code-copy-button" title="Copy to Clipboard"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="no-row-height column-margin column-container"><div class="">
<p>This hidden code cell implements a number of utilities for processing and node labels associated with them. It also has a lot of plotting implementations.</p>
</div></div><div class="cell" data-execution_count="2" id="1093c7c1">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a aria-hidden="true" href="#cb2-1" tabindex="-1"></a>G <span class="op">=</span> acquire_contact_data()</span>
<span id="cb2-2"><a aria-hidden="true" href="#cb2-2" tabindex="-1"></a>clusters <span class="op">=</span> nx.get_node_attributes(G, <span class="st">"class"</span>)</span>
<span id="cb2-3"><a aria-hidden="true" href="#cb2-3" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb2-4"><a aria-hidden="true" href="#cb2-4" tabindex="-1"></a>draw_graph(G, clusters <span class="op">=</span> clusters, ax <span class="op">=</span> ax)</span></code><button class="code-copy-button" title="Copy to Clipboard"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img class="figure-img" height="389" src="13-modularity-maximization_files/figure-html/cell-3-output-1.png" width="540"/></p>
</figure>
</div>
</div>
</div>
<p>There are 5 classes in the network: MP*1, MP*2, PC, PC*, and PSI*. Visual inspection of the plot suggests that the network may be assortative with respect to class: there are many edges between nodes of the same class, and fewer edges between nodes of different classes. There is even some <em>nested</em> assortative structure. The MP*1 and MP*2 classes seem to form a distinct subgraph. Students in MP*1 are more likely interact amongst themselves, but if they do interact with anyone outside their own class, it is likely to be with students in MP*2.</p>
<section class="level2 page-columns page-full" id="recall-measuring-assortativity-with-modularity">
<h2 class="anchored" data-anchor-id="recall-measuring-assortativity-with-modularity">Recall: Measuring Assortativity with Modularity</h2>
<p>Recall that we can quantify the extent to which a network is assortative with respect to some attribute by calculating the <em>modularity</em> of the network with respect to that attribute. Let <span class="math inline">\(\mathcal{Z}\)</span> be a finite set of possible node labels, and let <span class="math inline">\(\mathbf{z} \in \mathcal{Z}^n\)</span> be a vector whose <span class="math inline">\(i\)</span>th entry gives the label of the <span class="math inline">\(i\)</span>th node. Then, the modularity functional of <span class="math inline">\(G\)</span> with respect to <span class="math inline">\(\mathbf{z}\)</span> as defined by <span class="citation" data-cites="newman2004finding">M. E. J. Newman and Girvan (<a href="#ref-newman2004finding" role="doc-biblioref">2004</a>)</span> is given by the formula</p>
<p><span class="math display">\[
\begin{aligned}
    Q(G, \mathbf{z}) = \frac{1}{2m} \sum_{\substack{i,j \in N \\ i \neq j}} \left[ a_{ij} - \frac{k_i k_j}{2m} \right] \delta_{z_i z_j} \,,
\end{aligned}
\]</span></p>
<p>This formula can be motivated in several ways.</p>
<ol type="1">
<li><strong>Comparison to random graphs</strong>: <span class="math inline">\(Q\)</span> is a comparison of <span class="math inline">\(a_{ij}\)</span> to the expected number of edges between nodes <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> if edges were placed at random while approximately preserving the degree sequence (This point is surprisingly subtle; see <span class="citation" data-cites="chodrow2020moments">Chodrow (<a href="#ref-chodrow2020moments" role="doc-biblioref">2020</a>)</span> for a discussion of some of the difficulties.).</li>
<li><strong>Dynamical stability</strong>: <span class="math inline">\(Q\)</span> is a measure of the tendency of random walks on the graph <span class="math inline">\(G\)</span> to stay within the same community; see <span class="citation" data-cites="delvenne2010stability">Delvenne, Yaliraki, and Barahona (<a href="#ref-delvenne2010stability" role="doc-biblioref">2010</a>)</span>.</li>
<li><strong>Statistical inference</strong>: <span class="math inline">\(Q\)</span> is a term in the objective function for a statistical inference task in which we try to infer the labels <span class="math inline">\(\mathbf{z}\)</span> from the graph structure; see <span class="citation" data-cites="newman2016equivalence">M. E. Newman (<a href="#ref-newman2016equivalence" role="doc-biblioref">2016</a>)</span>.</li>
</ol>
<div class="page-columns page-full"><p>We often informally say that the network is <em>assortative</em> or <em>has modular structure</em> when <span class="math inline">\(Q\)</span> is substantially larger than 0. </p><div class="no-row-height column-margin column-container"><span class="margin-aside">The question of what counts as “substantially larger” can be tricky; for example; see discussion in <span class="citation" data-cites="zhang2014scalable">Zhang and Moore (<a href="#ref-zhang2014scalable" role="doc-biblioref">2014</a>)</span> for cases in which Erdős–Rényi random graphs can have high modularity with respect to a carefully-chosen partition.</span></div></div>
<p>Networkx implements a function to compute the modularity, but it’s not difficult to implement our own either. We’ll structure our function to accept a vector of characters giving the class labels.</p>
<div class="cell" data-execution_count="3" id="bc293fbb">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a aria-hidden="true" href="#cb3-1" tabindex="-1"></a><span class="kw">def</span> modularity(G, z):</span>
<span id="cb3-2"><a aria-hidden="true" href="#cb3-2" tabindex="-1"></a></span>
<span id="cb3-3"><a aria-hidden="true" href="#cb3-3" tabindex="-1"></a>    <span class="co"># converts z from a dict to an array if it isn't one already</span></span>
<span id="cb3-4"><a aria-hidden="true" href="#cb3-4" tabindex="-1"></a>    z <span class="op">=</span> labels_to_array(z, G)</span>
<span id="cb3-5"><a aria-hidden="true" href="#cb3-5" tabindex="-1"></a></span>
<span id="cb3-6"><a aria-hidden="true" href="#cb3-6" tabindex="-1"></a>    <span class="co"># form the matrices we need</span></span>
<span id="cb3-7"><a aria-hidden="true" href="#cb3-7" tabindex="-1"></a>    A <span class="op">=</span> nx.to_numpy_array(G)</span>
<span id="cb3-8"><a aria-hidden="true" href="#cb3-8" tabindex="-1"></a>    k <span class="op">=</span> A.<span class="bu">sum</span>(axis <span class="op">=</span> <span class="dv">1</span>)</span>
<span id="cb3-9"><a aria-hidden="true" href="#cb3-9" tabindex="-1"></a>    m <span class="op">=</span> G.number_of_edges()</span>
<span id="cb3-10"><a aria-hidden="true" href="#cb3-10" tabindex="-1"></a></span>
<span id="cb3-11"><a aria-hidden="true" href="#cb3-11" tabindex="-1"></a>    <span class="co"># computes a matrix whose ith entry is delta_{z_i, z_j}</span></span>
<span id="cb3-12"><a aria-hidden="true" href="#cb3-12" tabindex="-1"></a>    delta <span class="op">=</span> z[:, <span class="va">None</span>] <span class="op">==</span> z[<span class="va">None</span>, :] </span>
<span id="cb3-13"><a aria-hidden="true" href="#cb3-13" tabindex="-1"></a></span>
<span id="cb3-14"><a aria-hidden="true" href="#cb3-14" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span><span class="op">/</span>(<span class="dv">2</span><span class="op">*</span>m)<span class="op">*</span>((A <span class="op">-</span> np.outer(k, k) <span class="op">/</span> (<span class="dv">2</span> <span class="op">*</span> m))<span class="op">*</span>delta).<span class="bu">sum</span>()</span></code><button class="code-copy-button" title="Copy to Clipboard"><i class="bi"></i></button></pre></div>
</div>
<p>Now let’s try calling our function to find the modularity of the graph and its labels:</p>
<div class="cell" data-execution_count="4" id="90fc94e1">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a aria-hidden="true" href="#cb4-1" tabindex="-1"></a>modularity(G, clusters)</span></code><button class="code-copy-button" title="Copy to Clipboard"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="4">
<pre><code>np.float64(0.5039115128642156)</code></pre>
</div>
</div>
<p>Let’s do a quick check against the built-in implementation of modularity in Networkx. This implementation works just a bit differently: we need to pass a list of sets in which each set represents a community.</p>
<div class="cell" data-execution_count="5" id="b524bf1a">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a aria-hidden="true" href="#cb6-1" tabindex="-1"></a>communities <span class="op">=</span> [{node <span class="cf">for</span> node <span class="kw">in</span> G.nodes() <span class="cf">if</span> clusters[node] <span class="op">==</span> i} <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">5</span>)]</span>
<span id="cb6-2"><a aria-hidden="true" href="#cb6-2" tabindex="-1"></a>nx.community.modularity(G, communities)</span></code><button class="code-copy-button" title="Copy to Clipboard"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="5">
<pre><code>0.5039115128642155</code></pre>
</div>
</div>
<p>Our answers agree!</p>
</section>
<section class="level2 page-columns page-full" id="the-community-detection-problem">
<h2 class="anchored" data-anchor-id="the-community-detection-problem">The Community Detection Problem</h2>
<div class="page-columns page-full"><p>In the community detection problem, we consider a graph <span class="math inline">\(G\)</span> which we <em>suspect</em> to have some interesting modular structure, but we do not have access to the label vector <span class="math inline">\(\mathbf{z}\)</span>. Instead, we attempt to <em>find</em> a good label vector based on the graph structure itself. </p><div class="no-row-height column-margin column-container"><span class="margin-aside">This kind of task is also often called “graph clustering” or “graph partitioning.” The idea that networks have community structure and that algorithms can find this structure was popularized by <span class="citation" data-cites="girvan2002community">Girvan and Newman (<a href="#ref-girvan2002community" role="doc-biblioref">2002</a>)</span>.</span></div></div>
<div class="no-row-height column-margin column-container"><div class="">
<p>So, in the community detection problem, we have access to an <em>unlabeled graph</em> like this one.</p>
<div class="cell" data-execution_count="6" id="45f06b0d">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img class="figure-img img-fluid" height="389" src="13-modularity-maximization_files/figure-html/cell-7-output-1.png" width="540"/></p>
</figure>
</div>
</div>
</div>
<p>We’d like to find a “good” partition of the nodes.</p>
</div></div><section class="level3" id="community-detection-as-optimization">
<h3 class="anchored" data-anchor-id="community-detection-as-optimization">Community Detection as Optimization</h3>
<p>Many algorithms for community detection are based on the idea of optimization. The goal is to formulate a function <span class="math inline">\(R(G, \mathbf{z})\)</span> with two main properties:</p>
<ol type="1">
<li><span class="math inline">\(R(G, \mathbf{z})\)</span> is large when <span class="math inline">\(\mathbf{z}\)</span> is a “good” partition of the graph.</li>
<li>It is feasible to find a partition of <span class="math inline">\(\mathbf{z}\)</span> which gives a large value of <span class="math inline">\(R(G, \mathbf{z})\)</span> in practical computational time.</li>
</ol>
<p>Roughly, criterion 1 says that we are “optimizing the right thing,” while criterion 2 says that “optimizing the right thing” is in fact computationally feasible. Due to its many useful interpretations, the modularity <span class="math inline">\(Q\)</span> has been a very popular choice of objective functions for community detection. In <a href="../chapters/19-spectral-clustering.html">later notes</a>, we’ll explore an alternative objective function.</p>
</section>
</section>
<section class="level2" id="a-community-detection-algorithm-greedy-agglomerative-clustering">
<h2 class="anchored" data-anchor-id="a-community-detection-algorithm-greedy-agglomerative-clustering">A Community Detection Algorithm: Greedy Agglomerative Clustering</h2>
<p>Unfortunately, exactly maximizing the modularity is NP-hard <span class="citation" data-cites="brandes2007modularity">(<a href="#ref-brandes2007modularity" role="doc-biblioref">Brandes et al. 2007</a>)</span>, and so we need to consider tractable heuristic algorithms that we hope may lead us to solutions which are close to optimal.</p>
<p>One simple algorithm for heuristic modularity maximization is the <em>greedy agglomerative clustering</em> algorithm. The idea is to start with each node in its own community, and then iteratively swap the labels of nodes until no improvement in the modularity can be obtained. An important computational feature of this algorithm is that we don’t need to always recalculate the modularity from scratch.</p>
<p>Instead, we can simply <em>update</em> the modularity with the change that results from swapping a node <span class="math inline">\(h\)</span> from community <span class="math inline">\(x\)</span> to community <span class="math inline">\(y\)</span>. Let <span class="math inline">\(\mathbf{z}\)</span> be the label vector before the swap and let <span class="math inline">\(\mathbf{z}'\)</span> be the label vector after the swap. Importantly, this quantity can be evaluated much more efficiently than the complete modularity.</p>
<div class="callout callout-style-simple callout-important no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercise
</div>
</div>
<div class="callout-body-container callout-body">
<p>Prove that <span class="math inline">\(Q(G, \mathbf{z}') - Q(G, \mathbf{z}) = \sum_{j \neq h} b_{hj}(x,y)\)</span> for some numbers <span class="math inline">\(b_{hj}(x,y)\)</span> which depend on the node <span class="math inline">\(j\)</span>, its original community <span class="math inline">\(x\)</span>, and its proposed new community <span class="math inline">\(y\)</span>, and which can be computed in <span class="math inline">\(O(1)\)</span> time.</p>
</div>
</div>

<p>Our implementation of the main loop relies on the following function which calculates the change in modularity from swapping a node <span class="math inline">\(h\)</span> from community <span class="math inline">\(x\)</span> to community <span class="math inline">\(y\)</span>.</p>
<div class="cell" data-execution_count="7" id="4b5208ab">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a aria-hidden="true" href="#cb8-1" tabindex="-1"></a><span class="kw">def</span> modularity_change(A, k, m, i, x, y, labels):    </span>
<span id="cb8-2"><a aria-hidden="true" href="#cb8-2" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb8-3"><a aria-hidden="true" href="#cb8-3" tabindex="-1"></a><span class="co">    compute the change in modularity associated with moving the current label of node i (assumed to be labels[i]) from x to y</span></span>
<span id="cb8-4"><a aria-hidden="true" href="#cb8-4" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb8-5"><a aria-hidden="true" href="#cb8-5" tabindex="-1"></a>    change_vec <span class="op">=</span> <span class="dv">1</span><span class="op">/</span>m <span class="op">*</span>((A[i] <span class="op">-</span> k[i]<span class="op">*</span>k<span class="op">/</span>(<span class="dv">2</span><span class="op">*</span>m))<span class="op">*</span>(<span class="dv">1</span><span class="op">*</span>(y <span class="op">==</span> labels) <span class="op">-</span> <span class="dv">1</span><span class="op">*</span>(x <span class="op">==</span> labels)))</span>
<span id="cb8-6"><a aria-hidden="true" href="#cb8-6" tabindex="-1"></a>    change_vec[i] <span class="op">=</span> <span class="dv">0</span> <span class="co"># zero out the term corresponding to i</span></span>
<span id="cb8-7"><a aria-hidden="true" href="#cb8-7" tabindex="-1"></a>    change <span class="op">=</span> change_vec.<span class="bu">sum</span>()</span>
<span id="cb8-8"><a aria-hidden="true" href="#cb8-8" tabindex="-1"></a>    <span class="cf">return</span> change</span></code><button class="code-copy-button" title="Copy to Clipboard"><i class="bi"></i></button></pre></div>
</div>
<p>Now we can use this function in a loop to iteratively swap node labels until no improvement can be made (or until the step limit is exceeded).</p>
<div class="cell" data-execution_count="8" id="eb983558">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a aria-hidden="true" href="#cb9-1" tabindex="-1"></a><span class="kw">def</span> greedy_clustering(G, num_steps <span class="op">=</span> <span class="bu">int</span>(<span class="fl">1e4</span>)):</span>
<span id="cb9-2"><a aria-hidden="true" href="#cb9-2" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb9-3"><a aria-hidden="true" href="#cb9-3" tabindex="-1"></a><span class="co">    Return a label vector of integers from greedy agglomerative clustering</span></span>
<span id="cb9-4"><a aria-hidden="true" href="#cb9-4" tabindex="-1"></a><span class="co">    Also return a list showing the progress of the modularity at each step</span></span>
<span id="cb9-5"><a aria-hidden="true" href="#cb9-5" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb9-6"><a aria-hidden="true" href="#cb9-6" tabindex="-1"></a></span>
<span id="cb9-7"><a aria-hidden="true" href="#cb9-7" tabindex="-1"></a>    <span class="co"># initialize every node in its own cluster</span></span>
<span id="cb9-8"><a aria-hidden="true" href="#cb9-8" tabindex="-1"></a>    labels <span class="op">=</span> np.arange(G.number_of_nodes()) </span>
<span id="cb9-9"><a aria-hidden="true" href="#cb9-9" tabindex="-1"></a></span>
<span id="cb9-10"><a aria-hidden="true" href="#cb9-10" tabindex="-1"></a>    <span class="co"># compute the modularity initially -- we'll update it as we go</span></span>
<span id="cb9-11"><a aria-hidden="true" href="#cb9-11" tabindex="-1"></a>    progress <span class="op">=</span> [modularity(G, labels)]</span>
<span id="cb9-12"><a aria-hidden="true" href="#cb9-12" tabindex="-1"></a></span>
<span id="cb9-13"><a aria-hidden="true" href="#cb9-13" tabindex="-1"></a>    <span class="co"># matrices and vectors we'll need</span></span>
<span id="cb9-14"><a aria-hidden="true" href="#cb9-14" tabindex="-1"></a>    m <span class="op">=</span> G.number_of_edges()</span>
<span id="cb9-15"><a aria-hidden="true" href="#cb9-15" tabindex="-1"></a>    A <span class="op">=</span> nx.to_numpy_array(G)</span>
<span id="cb9-16"><a aria-hidden="true" href="#cb9-16" tabindex="-1"></a>    k <span class="op">=</span> A.<span class="bu">sum</span>(axis <span class="op">=</span> <span class="dv">1</span>)</span>
<span id="cb9-17"><a aria-hidden="true" href="#cb9-17" tabindex="-1"></a>    </span>
<span id="cb9-18"><a aria-hidden="true" href="#cb9-18" tabindex="-1"></a>    <span class="co"># main loop</span></span>
<span id="cb9-19"><a aria-hidden="true" href="#cb9-19" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(num_steps):</span>
<span id="cb9-20"><a aria-hidden="true" href="#cb9-20" tabindex="-1"></a></span>
<span id="cb9-21"><a aria-hidden="true" href="#cb9-21" tabindex="-1"></a>        <span class="co"># pick two nodes at random and retrieve their labels</span></span>
<span id="cb9-22"><a aria-hidden="true" href="#cb9-22" tabindex="-1"></a>        i, j <span class="op">=</span> np.random.choice(G.number_of_nodes(), <span class="dv">2</span>, replace <span class="op">=</span> <span class="va">False</span>)</span>
<span id="cb9-23"><a aria-hidden="true" href="#cb9-23" tabindex="-1"></a></span>
<span id="cb9-24"><a aria-hidden="true" href="#cb9-24" tabindex="-1"></a>        <span class="co"># prospective swap is that i will change its label from x to y</span></span>
<span id="cb9-25"><a aria-hidden="true" href="#cb9-25" tabindex="-1"></a>        x <span class="op">=</span> labels[i]</span>
<span id="cb9-26"><a aria-hidden="true" href="#cb9-26" tabindex="-1"></a>        y <span class="op">=</span> labels[j]</span>
<span id="cb9-27"><a aria-hidden="true" href="#cb9-27" tabindex="-1"></a></span>
<span id="cb9-28"><a aria-hidden="true" href="#cb9-28" tabindex="-1"></a>        <span class="cf">if</span> x <span class="op">==</span> y: </span>
<span id="cb9-29"><a aria-hidden="true" href="#cb9-29" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb9-30"><a aria-hidden="true" href="#cb9-30" tabindex="-1"></a></span>
<span id="cb9-31"><a aria-hidden="true" href="#cb9-31" tabindex="-1"></a>        <span class="cf">else</span>: </span>
<span id="cb9-32"><a aria-hidden="true" href="#cb9-32" tabindex="-1"></a>            <span class="co"># compute the change in modularity of the prospective swap</span></span>
<span id="cb9-33"><a aria-hidden="true" href="#cb9-33" tabindex="-1"></a>            change <span class="op">=</span> modularity_change(A, k, m, i, x, y, labels)</span>
<span id="cb9-34"><a aria-hidden="true" href="#cb9-34" tabindex="-1"></a></span>
<span id="cb9-35"><a aria-hidden="true" href="#cb9-35" tabindex="-1"></a>            <span class="co"># if positive, update the labels and store the new modularity for visualization later</span></span>
<span id="cb9-36"><a aria-hidden="true" href="#cb9-36" tabindex="-1"></a>            <span class="cf">if</span> change <span class="op">&gt;</span> <span class="dv">0</span>: </span>
<span id="cb9-37"><a aria-hidden="true" href="#cb9-37" tabindex="-1"></a>                labels[i] <span class="op">=</span> y</span>
<span id="cb9-38"><a aria-hidden="true" href="#cb9-38" tabindex="-1"></a>                progress.append(progress[<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> change)</span>
<span id="cb9-39"><a aria-hidden="true" href="#cb9-39" tabindex="-1"></a>        </span>
<span id="cb9-40"><a aria-hidden="true" href="#cb9-40" tabindex="-1"></a>    <span class="co"># postprocessing: we need to convert the labels into a dict for visualization etc. </span></span>
<span id="cb9-41"><a aria-hidden="true" href="#cb9-41" tabindex="-1"></a>    distinct_labels <span class="op">=</span> np.unique(labels)</span>
<span id="cb9-42"><a aria-hidden="true" href="#cb9-42" tabindex="-1"></a>    label_map <span class="op">=</span> {<span class="bu">int</span>(distinct_label) : i <span class="cf">for</span> i, distinct_label <span class="kw">in</span> <span class="bu">enumerate</span>(distinct_labels)}</span>
<span id="cb9-43"><a aria-hidden="true" href="#cb9-43" tabindex="-1"></a></span>
<span id="cb9-44"><a aria-hidden="true" href="#cb9-44" tabindex="-1"></a>    greedy_clusters <span class="op">=</span> {i : label_map[label] <span class="cf">for</span> i, label <span class="kw">in</span> <span class="bu">enumerate</span>(labels)}</span>
<span id="cb9-45"><a aria-hidden="true" href="#cb9-45" tabindex="-1"></a></span>
<span id="cb9-46"><a aria-hidden="true" href="#cb9-46" tabindex="-1"></a>    <span class="cf">return</span> greedy_clusters, np.array(progress)</span></code><button class="code-copy-button" title="Copy to Clipboard"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s run our algorithm…</p>
<div class="cell" data-execution_count="9" id="7fd8ee6d">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a aria-hidden="true" href="#cb10-1" tabindex="-1"></a>greedy_clusters, progress <span class="op">=</span> greedy_clustering(G, num_steps <span class="op">=</span> <span class="bu">int</span>(<span class="fl">1e5</span>))</span></code><button class="code-copy-button" title="Copy to Clipboard"><i class="bi"></i></button></pre></div>
</div>
<p>…and visualize how we did.</p>
<div class="cell" data-execution_count="10" id="a8cba342">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a aria-hidden="true" href="#cb11-1" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize <span class="op">=</span> (<span class="dv">7</span>, <span class="fl">3.5</span>))</span>
<span id="cb11-2"><a aria-hidden="true" href="#cb11-2" tabindex="-1"></a></span>
<span id="cb11-3"><a aria-hidden="true" href="#cb11-3" tabindex="-1"></a>ax[<span class="dv">0</span>].plot(progress)</span>
<span id="cb11-4"><a aria-hidden="true" href="#cb11-4" tabindex="-1"></a>ax[<span class="dv">0</span>].<span class="bu">set</span>(xlabel <span class="op">=</span> <span class="st">"Number of swaps performed"</span>, ylabel <span class="op">=</span> <span class="st">"Modularity"</span>, title <span class="op">=</span> <span class="st">"Progress over swaps"</span>)</span>
<span id="cb11-5"><a aria-hidden="true" href="#cb11-5" tabindex="-1"></a></span>
<span id="cb11-6"><a aria-hidden="true" href="#cb11-6" tabindex="-1"></a>ax[<span class="dv">1</span>].<span class="bu">set</span>(title <span class="op">=</span> <span class="ss">f"Modularity of greedy partition = </span><span class="sc">{</span>modularity(G, greedy_clusters)<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb11-7"><a aria-hidden="true" href="#cb11-7" tabindex="-1"></a>ax[<span class="dv">1</span>].axis(<span class="st">"off"</span>)</span>
<span id="cb11-8"><a aria-hidden="true" href="#cb11-8" tabindex="-1"></a>draw_graph(G, clusters <span class="op">=</span> greedy_clusters, ax <span class="op">=</span> ax[<span class="dv">1</span>], legend <span class="op">=</span> <span class="va">False</span>)</span></code><button class="code-copy-button" title="Copy to Clipboard"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img class="figure-img" height="331" src="13-modularity-maximization_files/figure-html/cell-11-output-1.png" width="594"/></p>
</figure>
</div>
</div>
</div>
<p>This algorithm required several hundred executed swaps (and thousands of non-executed swaps) in order to achieve the visualized clustering. The clusters shown actually achieve a modularity that is comparable to the original clustering.</p>
</section>
<section class="level2 page-columns page-full" id="validation-of-community-detection-algorithms">
<h2 class="anchored" data-anchor-id="validation-of-community-detection-algorithms">Validation of Community Detection Algorithms</h2>
<div class="page-columns page-full"><p>How do we tell whether a community detection algorithm is “good”? One standard way is to compare the clusters found by that algorithm to the true clusters, when such true clusters are available.  Generally, we’d like to use a function <span class="math inline">\(f(\mathbf{z}, \mathbf{z}')\)</span> which measures the similarity between the two label vectors <span class="math inline">\(\mathbf{z}\)</span> and <span class="math inline">\(\mathbf{z}'\)</span>; we’d have <span class="math inline">\(f(\mathbf{z}, \mathbf{z}') = 1\)</span> when the two vectors are identical (up to permutations of labels) and <span class="math inline">\(f(\mathbf{z}, \mathbf{z}') = 0\)</span> when the two vectors are completely uncorrelated.</p><div class="no-row-height column-margin column-container"><span class="margin-aside">Though see <span class="citation" data-cites="peel2017ground">Peel, Larremore, and Clauset (<a href="#ref-peel2017ground" role="doc-biblioref">2017</a>)</span> for a discussion of the limitations of this approach.</span></div></div>
<p>There are several metrics which are appropriate to this task. We’ll illustrate one standard such vector, the <em>normalized mutual information</em> or NMI. The NMI has formula</p>
<p><span class="math display">\[
\begin{aligned}
    \text{NMI}(\mathbf{z}, \mathbf{z}') = 2 \frac{I(\mathbf{z}, \mathbf{z}')}{H(\mathbf{z}) + H(\mathbf{z}')}\;,
\end{aligned}
\]</span></p>
<p>where <span class="math inline">\(I(\mathbf{z}, \mathbf{z}')\)</span> is the mutual information between the two label vectors and <span class="math inline">\(H(\mathbf{z})\)</span> is the entropy of the label vector.</p>
<p>To define these two quantities, let <span class="math inline">\(p(z,z')\)</span> be proportion of the time that a randomly picked node has label <span class="math inline">\(z\)</span> in <span class="math inline">\(\mathbf{z}\)</span> and <span class="math inline">\(z'\)</span> in <span class="math inline">\(\mathbf{z'}\)</span>: <span class="math display">\[
\begin{aligned}
    p(z,z') = \frac{1}{n} \sum_{i} \delta_{z, z_i}\delta_{z', z_i'}\;.
\end{aligned}
\]</span></p>
<p>Also define <span class="math inline">\(p(z) = \sum_{z' \in \mathcal{Z}} p(z,z')\)</span> and <span class="math inline">\(p(z') = \sum_{z \in \mathcal{Z}} p(z,z')\)</span>. Then,</p>
<p><span class="math display">\[
\begin{aligned}
    H(\mathbf{z}) &amp;= - \sum_{z \in \mathcal{Z}} p(z) \log p(z) \\
    I(\mathbf{z}, \mathbf{z}') &amp;= \sum_{z \in \mathcal{Z}} \sum_{z' \in \mathcal{Z}} p(z,z') \log \frac{p(z,z')}{p(z)p(z')} \;.
\end{aligned}
\]</span></p>
<div class="page-columns page-full"><p>Roughly, <span class="math inline">\(H(\mathbf{z})\)</span> measures the “diversity” of labels represented in <span class="math inline">\(\mathbf{z}\)</span>, while <span class="math inline">\(I(\mathbf{z}, \mathbf{z}')\)</span> measures the extent to which knowing a node’s label in <span class="math inline">\(\mathbf{z}\)</span> helps you guess its label in <span class="math inline">\(\mathbf{z}'\)</span>. </p><div class="no-row-height column-margin column-container"><span class="margin-aside">The entropy and mutual information are both quantities introduced by <span class="citation" data-cites="shannon1948mathematical">Shannon (<a href="#ref-shannon1948mathematical" role="doc-biblioref">1948</a>)</span> in a famous paper that launched the field of <em>information theory</em>. Information theory is widely used in electrical engineering, statistics, statistical physics, and machine learning. See <span class="citation" data-cites="cover2006elements">Cover and Thomas (<a href="#ref-cover2006elements" role="doc-biblioref">2006</a>)</span> for a modern treatment of the topic.</span></div></div>
<p>Here are implementations of the entropy, mutual information, and normalized mutual information:</p>
<div class="cell" data-execution_count="11" id="0712bfdf">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a aria-hidden="true" href="#cb12-1" tabindex="-1"></a><span class="kw">def</span> H(z, G): </span>
<span id="cb12-2"><a aria-hidden="true" href="#cb12-2" tabindex="-1"></a>    z <span class="op">=</span> labels_to_array(z, G)</span>
<span id="cb12-3"><a aria-hidden="true" href="#cb12-3" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(z)</span>
<span id="cb12-4"><a aria-hidden="true" href="#cb12-4" tabindex="-1"></a>    p <span class="op">=</span> np.array([np.mean(z <span class="op">==</span> i) <span class="cf">for</span> i <span class="kw">in</span> np.unique(z)])</span>
<span id="cb12-5"><a aria-hidden="true" href="#cb12-5" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span>np.<span class="bu">sum</span>(p<span class="op">*</span>np.log(p))</span>
<span id="cb12-6"><a aria-hidden="true" href="#cb12-6" tabindex="-1"></a></span>
<span id="cb12-7"><a aria-hidden="true" href="#cb12-7" tabindex="-1"></a><span class="kw">def</span> I(z, z_, G):</span>
<span id="cb12-8"><a aria-hidden="true" href="#cb12-8" tabindex="-1"></a>    z  <span class="op">=</span> labels_to_array(z, G)</span>
<span id="cb12-9"><a aria-hidden="true" href="#cb12-9" tabindex="-1"></a>    z_ <span class="op">=</span> labels_to_array(z_, G)</span>
<span id="cb12-10"><a aria-hidden="true" href="#cb12-10" tabindex="-1"></a></span>
<span id="cb12-11"><a aria-hidden="true" href="#cb12-11" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(z)</span>
<span id="cb12-12"><a aria-hidden="true" href="#cb12-12" tabindex="-1"></a></span>
<span id="cb12-13"><a aria-hidden="true" href="#cb12-13" tabindex="-1"></a>    <span class="co"># we're going to accumulate the joint distribution of labels </span></span>
<span id="cb12-14"><a aria-hidden="true" href="#cb12-14" tabindex="-1"></a>    <span class="co"># in a for-loop. </span></span>
<span id="cb12-15"><a aria-hidden="true" href="#cb12-15" tabindex="-1"></a>    <span class="co"># an alternative would be to form it as an array and then reduce</span></span>
<span id="cb12-16"><a aria-hidden="true" href="#cb12-16" tabindex="-1"></a>    info <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb12-17"><a aria-hidden="true" href="#cb12-17" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> np.unique(z): </span>
<span id="cb12-18"><a aria-hidden="true" href="#cb12-18" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> np.unique(z_): </span>
<span id="cb12-19"><a aria-hidden="true" href="#cb12-19" tabindex="-1"></a>            p <span class="op">=</span> np.mean((z <span class="op">==</span> i) <span class="op">&amp;</span> (z_ <span class="op">==</span> j))</span>
<span id="cb12-20"><a aria-hidden="true" href="#cb12-20" tabindex="-1"></a>            <span class="cf">if</span> p <span class="op">==</span> <span class="dv">0</span>: </span>
<span id="cb12-21"><a aria-hidden="true" href="#cb12-21" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb12-22"><a aria-hidden="true" href="#cb12-22" tabindex="-1"></a>            info <span class="op">+=</span> p<span class="op">*</span>np.log(p<span class="op">/</span>(np.mean(z <span class="op">==</span> i)<span class="op">*</span>np.mean(z_ <span class="op">==</span> j)))</span>
<span id="cb12-23"><a aria-hidden="true" href="#cb12-23" tabindex="-1"></a>    <span class="cf">return</span> info</span>
<span id="cb12-24"><a aria-hidden="true" href="#cb12-24" tabindex="-1"></a></span>
<span id="cb12-25"><a aria-hidden="true" href="#cb12-25" tabindex="-1"></a><span class="kw">def</span> NMI(z, z_, G): </span>
<span id="cb12-26"><a aria-hidden="true" href="#cb12-26" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">2</span><span class="op">*</span>I(z, z_, G)<span class="op">/</span>(H(z, G) <span class="op">+</span> H(z_, G))</span></code><button class="code-copy-button" title="Copy to Clipboard"><i class="bi"></i></button></pre></div>
</div>
<p>Now we can assess the performance of our greedy clustering algorithm against ground truth:</p>
<div class="cell" data-execution_count="12" id="8350a8b4">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a aria-hidden="true" href="#cb13-1" tabindex="-1"></a>NMI(clusters, greedy_clusters, G)</span></code><button class="code-copy-button" title="Copy to Clipboard"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="12">
<pre><code>np.float64(0.957019309678522)</code></pre>
</div>
</div>
<p>Frequently when assessing a clustering method, it’s not really easy to tell out of context whether it’s useful or not. We often assess the method against competing methods, and often on several data sets.</p>
<div class="cell" data-execution_count="13" id="b5abb122">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a aria-hidden="true" href="#cb15-1" tabindex="-1"></a><span class="kw">def</span> test_suite(G, clusters):</span>
<span id="cb15-2"><a aria-hidden="true" href="#cb15-2" tabindex="-1"></a></span>
<span id="cb15-3"><a aria-hidden="true" href="#cb15-3" tabindex="-1"></a>    <span class="co"># retrieve our own greedy clusters and assess</span></span>
<span id="cb15-4"><a aria-hidden="true" href="#cb15-4" tabindex="-1"></a>    greedy_clusters <span class="op">=</span> greedy_clustering(G, num_steps <span class="op">=</span> <span class="bu">int</span>(<span class="fl">1e4</span>))[<span class="dv">0</span>]</span>
<span id="cb15-5"><a aria-hidden="true" href="#cb15-5" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Our greedy agglomeration clustering has NMI = </span><span class="sc">{</span>NMI(clusters, greedy_clusters, G)<span class="sc">:.3f}</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb15-6"><a aria-hidden="true" href="#cb15-6" tabindex="-1"></a></span>
<span id="cb15-7"><a aria-hidden="true" href="#cb15-7" tabindex="-1"></a>    <span class="co"># now compare against an array of built-in methods. </span></span>
<span id="cb15-8"><a aria-hidden="true" href="#cb15-8" tabindex="-1"></a>    <span class="kw">def</span> cluster_from_partition(partition):</span>
<span id="cb15-9"><a aria-hidden="true" href="#cb15-9" tabindex="-1"></a>        <span class="cf">return</span> {node : i <span class="cf">for</span> i, nodes <span class="kw">in</span> <span class="bu">enumerate</span>(partition) <span class="cf">for</span> node <span class="kw">in</span> nodes}</span>
<span id="cb15-10"><a aria-hidden="true" href="#cb15-10" tabindex="-1"></a></span>
<span id="cb15-11"><a aria-hidden="true" href="#cb15-11" tabindex="-1"></a>    methods <span class="op">=</span> [nx.community.greedy_modularity_communities, nx.community.asyn_lpa_communities, nx.community.label_propagation_communities, nx.community.louvain_communities]</span>
<span id="cb15-12"><a aria-hidden="true" href="#cb15-12" tabindex="-1"></a></span>
<span id="cb15-13"><a aria-hidden="true" href="#cb15-13" tabindex="-1"></a>    <span class="cf">for</span> method <span class="kw">in</span> methods:</span>
<span id="cb15-14"><a aria-hidden="true" href="#cb15-14" tabindex="-1"></a>        partition <span class="op">=</span> method(G)</span>
<span id="cb15-15"><a aria-hidden="true" href="#cb15-15" tabindex="-1"></a>        inferred_clusters <span class="op">=</span> cluster_from_partition(partition)</span>
<span id="cb15-16"><a aria-hidden="true" href="#cb15-16" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Method </span><span class="sc">{</span>method<span class="sc">.</span><span class="va">__name__</span><span class="sc">}</span><span class="ss"> has NMI = </span><span class="sc">{</span>NMI(clusters, inferred_clusters, G)<span class="sc">:.3f}</span><span class="ss">"</span>)</span></code><button class="code-copy-button" title="Copy to Clipboard"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s run our test suite:</p>
<div class="cell" data-execution_count="14" id="b0a71e87">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a aria-hidden="true" href="#cb16-1" tabindex="-1"></a>test_suite(G, clusters)</span></code><button class="code-copy-button" title="Copy to Clipboard"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Our greedy agglomeration clustering has NMI = 0.957

Method greedy_modularity_communities has NMI = 0.748
Method asyn_lpa_communities has NMI = 0.800
Method label_propagation_communities has NMI = 0.868
Method louvain_communities has NMI = 0.868</code></pre>
</div>
</div>
<p>Our algorithm appears to be competitive with several of the built-in methods for community detection implemented in Networkx.</p>
<p>Would we get different results on another graph? Let’s load up our friend the Karate Club graph:</p>
<div class="cell" data-execution_count="15" id="649ff235">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a aria-hidden="true" href="#cb18-1" tabindex="-1"></a>G_karate <span class="op">=</span> nx.karate_club_graph()</span>
<span id="cb18-2"><a aria-hidden="true" href="#cb18-2" tabindex="-1"></a>G_karate <span class="op">=</span> nx.convert_node_labels_to_integers(G_karate)</span>
<span id="cb18-3"><a aria-hidden="true" href="#cb18-3" tabindex="-1"></a>clusters_karate <span class="op">=</span> nx.get_node_attributes(G_karate, <span class="st">"club"</span>)</span>
<span id="cb18-4"><a aria-hidden="true" href="#cb18-4" tabindex="-1"></a>clusters_karate <span class="op">=</span> {node : <span class="dv">0</span> <span class="cf">if</span> club <span class="op">==</span> <span class="st">"Mr. Hi"</span> <span class="cf">else</span> <span class="dv">1</span> <span class="cf">for</span> node, club <span class="kw">in</span> clusters_karate.items()}</span></code><button class="code-copy-button" title="Copy to Clipboard"><i class="bi"></i></button></pre></div>
</div>
<p>Now we’ll run our test suite again:</p>
<div class="cell" data-execution_count="16" id="314a158b">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a aria-hidden="true" href="#cb19-1" tabindex="-1"></a>test_suite(G_karate, clusters_karate)</span></code><button class="code-copy-button" title="Copy to Clipboard"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Our greedy agglomeration clustering has NMI = 0.429

Method greedy_modularity_communities has NMI = 0.565
Method asyn_lpa_communities has NMI = 0.569
Method label_propagation_communities has NMI = 0.364
Method louvain_communities has NMI = 0.588</code></pre>
</div>
</div>
<p>Our algorithm appears to be a bit less impressive in this context, although results may vary due to randomness. A full test suite would often involve averaging the NMI over many runs of each algorithm.</p>
</section>
<section class="level2" id="other-approaches">
<h2 class="anchored" data-anchor-id="other-approaches">Other Approaches</h2>
<p>There are many other ways to perform community detection in networks. Sticking to the setting of undirected graphs, we still have lots of choices:</p>
<ol type="1">
<li>We can use a different algorithm to optimize modularity.</li>
<li>We can optimize something other than modularity.</li>
<li>We can decide that optimization-based community detection is not what we want to do at all—instead we can use methods based on statistical inference and sampling (e.g. <span class="citation" data-cites="peixoto2019bayesian">Peixoto (<a href="#ref-peixoto2019bayesian" role="doc-biblioref">2019</a>)</span>).</li>
</ol>
<p>There are additional choices and complications introduced when considering directed graphs or graphs in which edges can include more than two nodes.</p>
</section>
<section class="level2" id="references">
<h2 class="anchored" data-anchor-id="references">References</h2>
<div class="references csl-bib-body hanging-indent" data-entry-spacing="0" id="refs" role="list">
<div class="csl-entry" id="ref-brandes2007modularity" role="listitem">
Brandes, Ulrik, Daniel Delling, Marco Gaertler, Robert Gorke, Martin Hoefer, Zoran Nikoloski, and Dorothea Wagner. 2007. <span>“On Modularity Clustering.”</span> <em>IEEE Transactions on Knowledge and Data Engineering</em> 20 (2): 172–88.
</div>
<div class="csl-entry" id="ref-chodrow2020moments" role="listitem">
Chodrow, Philip S. 2020. <span>“Moments of Uniform Random Multigraphs with Fixed Degree Sequences.”</span> <em>SIAM Journal on Mathematics of Data Science</em> 2 (4): 1034–65.
</div>
<div class="csl-entry" id="ref-cover2006elements" role="listitem">
Cover, Thomas M., and Joy A Thomas. 2006. <em>Elements of Information Theory</em>. Wiley-Interscience.
</div>
<div class="csl-entry" id="ref-delvenne2010stability" role="listitem">
Delvenne, J-C, Sophia N Yaliraki, and Mauricio Barahona. 2010. <span>“Stability of Graph Communities Across Time Scales.”</span> <em>Proceedings Of The National Academy Of Sciences</em> 107 (29): 12755–60.
</div>
<div class="csl-entry" id="ref-fournet2014contact" role="listitem">
Fournet, Julie, and Alain Barrat. 2014. <span>“Contact Patterns Among High School Students.”</span> <em>PloS One</em> 9 (9): e107878.
</div>
<div class="csl-entry" id="ref-girvan2002community" role="listitem">
Girvan, Michelle, and Mark EJ Newman. 2002. <span>“Community Structure in Social and Biological Networks.”</span> <em>Proceedings of the National Academy of Sciences</em> 99 (12): 7821–26.
</div>
<div class="csl-entry" id="ref-newman2004finding" role="listitem">
Newman, Mark E. J., and Michelle Girvan. 2004. <span>“Finding and Evaluating Community Structure in Networks.”</span> <em>Physical Review E</em> 69 (2): 026113.
</div>
<div class="csl-entry" id="ref-newman2016equivalence" role="listitem">
Newman, Mark EJ. 2016. <span>“Equivalence Between Modularity Optimization and Maximum Likelihood Methods for Community Detection.”</span> <em>Physical Review E</em> 94 (5): 052315.
</div>
<div class="csl-entry" id="ref-peel2017ground" role="listitem">
Peel, Leto, Daniel B Larremore, and Aaron Clauset. 2017. <span>“The Ground Truth about Metadata and Community Detection in Networks.”</span> <em>Science Advances</em> 3 (5): e1602548.
</div>
<div class="csl-entry" id="ref-peixoto2019bayesian" role="listitem">
Peixoto, Tiago P. 2019. <span>“Bayesian Stochastic Blockmodeling.”</span> <em>Advances in Network Clustering and Blockmodeling</em>, 289–332.
</div>
<div class="csl-entry" id="ref-shannon1948mathematical" role="listitem">
Shannon, Claude Elwood. 1948. <span>“A Mathematical Theory of Communication.”</span> <em>The Bell System Technical Journal</em> 27 (3): 379–423.
</div>
<div class="csl-entry" id="ref-zhang2014scalable" role="listitem">
Zhang, Pan, and Cristopher Moore. 2014. <span>“Scalable Detection of Statistically Significant Communities and Hierarchies, Using Message Passing for Modularity.”</span> <em>Proceedings of the National Academy of Sciences</em> 111 (51): 18144–49.
</div>
</div>
</section>
<p><br/> <br/> <span style="color:grey;">© Heather Zinn Brooks and Phil Chodrow, 2025</span></p></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
<div class="nav-page nav-page-previous">
<a aria-label="Homophily, Assortativity, and Modularity" class="pagination-link" href="../chapters/06-modularity.html">
<i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">11</span>  <span class="chapter-title">Homophily, Assortativity, and Modularity</span></span>
</a>
</div>
<div class="nav-page nav-page-next">
<a aria-label="Spectral Clustering" class="pagination-link" href="../chapters/19-spectral-clustering.html">
<span class="nav-page-text"><span class="chapter-number">13</span>  <span class="chapter-title">Spectral Clustering</span></span> <i class="bi bi-arrow-right-short"></i>
</a>
</div>
</nav>
</div> <!-- /content -->
</body></html>