<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.10">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>12&nbsp; Community Detection and Modularity Maximization – Network Science: Models, Mathematics, and Computation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../chapters/19-spectral-clustering.html" rel="next">
<link href="../chapters/11-generating-functions.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-2d9718c933debafcce942f9b212640bc.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-c1bdd270c1c0708cd2ff05417efafcc5.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-sidebar floating slimcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../chapters/13-modularity-maximization.html">Network Algorithms</a></li><li class="breadcrumb-item"><a href="../chapters/13-modularity-maximization.html"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Community Detection and Modularity Maximization</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">Network Science: Models, Mathematics, and Computation</a> 
    </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Welcome</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Network Fundamentals</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/01-networkrepresentations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Networks and Their Representations</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/02-degree-walks-paths.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Degree, Walks, and Paths</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/03-components-laplacian.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Components and the Graph Laplacian</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">Measuring Networks</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/04-centrality.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Centrality and Importance</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/05-viz.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Visualizing Networks and Why You Shouldn’t</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/06-modularity.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Homophily, assortativity, and modularity</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true">
 <span class="menu-text">Real-World Networks</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/07-real-world.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Structure of Empirical Networks</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/08-power-laws.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Power Law Degree Distributions</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true">
 <span class="menu-text">Models of Networks</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/09-random-graphs.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Random Graphs: Erdős–Rényi</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/10-configuration-model.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Configuration models</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/11-generating-functions.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Probability Generating Functions</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="true">
 <span class="menu-text">Network Algorithms</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/13-modularity-maximization.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Community Detection and Modularity Maximization</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/19-spectral-clustering.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Spectral Clustering</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/41-link-prediction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Link Prediction and Feedback Loops</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" role="navigation" aria-expanded="true">
 <span class="menu-text">Applications and Extensions</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-6" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/50-random-walks.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Random Walks</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/51-agent-based-modeling.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Agent-Based Modeling on Networks</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/52-epidemiology.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Epidemic Models on Networks</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <span class="sidebar-item-text sidebar-link text-start">
 <span class="menu-text">Appendices</span></span>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Contents</h2>
   
  <ul>
  <li><a href="#recall-measuring-assortativity-with-modularity" id="toc-recall-measuring-assortativity-with-modularity" class="nav-link active" data-scroll-target="#recall-measuring-assortativity-with-modularity">Recall: Measuring Assortativity with Modularity</a></li>
  <li><a href="#the-community-detection-problem" id="toc-the-community-detection-problem" class="nav-link" data-scroll-target="#the-community-detection-problem">The Community Detection Problem</a>
  <ul class="collapse">
  <li><a href="#community-detection-as-optimization" id="toc-community-detection-as-optimization" class="nav-link" data-scroll-target="#community-detection-as-optimization">Community Detection as Optimization</a></li>
  </ul></li>
  <li><a href="#a-community-detection-algorithm-greedy-agglomerative-clustering" id="toc-a-community-detection-algorithm-greedy-agglomerative-clustering" class="nav-link" data-scroll-target="#a-community-detection-algorithm-greedy-agglomerative-clustering">A Community Detection Algorithm: Greedy Agglomerative Clustering</a></li>
  <li><a href="#validation-of-community-detection-algorithms" id="toc-validation-of-community-detection-algorithms" class="nav-link" data-scroll-target="#validation-of-community-detection-algorithms">Validation of Community Detection Algorithms</a></li>
  <li><a href="#other-approaches" id="toc-other-approaches" class="nav-link" data-scroll-target="#other-approaches">Other Approaches</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../chapters/13-modularity-maximization.html">Network Algorithms</a></li><li class="breadcrumb-item"><a href="../chapters/13-modularity-maximization.html"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Community Detection and Modularity Maximization</span></a></li></ol></nav>
<div class="quarto-title">
</div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><em>Open the live notebook in Google Colab <a href="https://colab.research.google.com/github/network-science-notes/network-science-notes.github.io/blob/main/docs/live-notebooks/13-modularity-maximization.ipynb">here</a>.</em></p>
<p>In a <a href="../chapters/06-modularity.html">previous lecture</a>, we introduced the idea of <em>assortativity</em> in networks. Roughly, a network is assortative with respect to some attribute if nodes which share that attribute are more likely to be connected to each other than to nodes without that attribute.</p>
<p>Our data for this set of lecture notes is a data set of social interactions between students at a French high school in 2012. The data was collected by <span class="citation" data-cites="fournet2014contact">Fournet and Barrat (<a href="#ref-fournet2014contact" role="doc-biblioref">2014</a>)</span> as part of the <a href="http://www.sociopatterns.org/">SocioPatterns project</a>. Students were given wearable sensors which would ping when two students were in close proximity and facing each other. Each of these pings is an edge in the raw data, although in our processing for this lecture we simplify the data set down so that there is an edge between each pair of students who interacted at all during the data collection period.</p>
<p>In this high school, students were tracked into one of five classes:</p>
<ol type="1">
<li>MP*1 and MP*2 were two classes focusing on mathematics and physics.</li>
<li>PC and PC* were two classes focusing on physics and chemistry.</li>
<li>PSI* was one class focusing on engineering.</li>
</ol>
<p>We might reasonably expect that students in the same class would interact more with each other than with students in other classes. Let’s acquire the data and visualize the network to begin to develop a feel for this idea.</p>
<div id="100ab1f4" class="cell" data-execution_count="1">
<details class="code-fold">
<summary>Show code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> networkx <span class="im">as</span> nx</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib <span class="im">import</span> pyplot <span class="im">as</span> plt</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib.lines <span class="im">import</span> Line2D <span class="co"># for legend later</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>plt.style.use(<span class="st">'seaborn-v0_8-whitegrid'</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> unweight(G):</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> source, target <span class="kw">in</span> G.edges():</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        G[source][target][<span class="st">'weight'</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> G</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> acquire_contact_data():</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    url <span class="op">=</span> <span class="st">"https://raw.githubusercontent.com/network-science-notes/network-science-notes.github.io/refs/heads/main/data/contact-high-school.csv"</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    contact <span class="op">=</span> pd.read_csv(url, sep <span class="op">=</span> <span class="st">"</span><span class="ch">\t</span><span class="st">"</span>, names <span class="op">=</span> [<span class="st">"time"</span>, <span class="st">"source"</span>, <span class="st">"target"</span>, <span class="st">"class_s"</span>, <span class="st">"class_t"</span>])[[<span class="st">"source"</span>, <span class="st">"target"</span>, <span class="st">"class_s"</span>, <span class="st">"class_t"</span>]]</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    G <span class="op">=</span> nx.from_pandas_edgelist(contact)</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    class_labels <span class="op">=</span> contact[[<span class="st">"source"</span>, <span class="st">"class_s"</span>]].drop_duplicates(subset<span class="op">=</span>[<span class="st">'source'</span>])</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    class_labels <span class="op">=</span> <span class="bu">dict</span>(<span class="bu">zip</span>(class_labels[<span class="st">"source"</span>], class_labels[<span class="st">"class_s"</span>]))</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    more_class_labels <span class="op">=</span> contact[[<span class="st">"target"</span>, <span class="st">"class_t"</span>]].drop_duplicates(subset<span class="op">=</span>[<span class="st">'target'</span>])</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    more_class_labels <span class="op">=</span> <span class="bu">dict</span>(<span class="bu">zip</span>(more_class_labels[<span class="st">"target"</span>], more_class_labels[<span class="st">"class_t"</span>]))</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    class_labels.update(more_class_labels)</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    classes <span class="op">=</span> [<span class="st">"MP*1"</span>, <span class="st">"MP*2"</span>, <span class="st">"PC"</span>, <span class="st">"PC*"</span>, <span class="st">"PSI*"</span>]</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    class_to_int <span class="op">=</span> {class_label : i <span class="cf">for</span> i, class_label <span class="kw">in</span> <span class="bu">enumerate</span>(classes)}</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>    class_labels <span class="op">=</span> {node : class_to_int[label] <span class="cf">for</span> node, label <span class="kw">in</span> class_labels.items()}</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>    nx.set_node_attributes(G, class_labels, <span class="st">"class"</span>)</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>    G <span class="op">=</span> nx.convert_node_labels_to_integers(G)</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>    G <span class="op">=</span> unweight(G)</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> G</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> draw_graph(G, clusters <span class="op">=</span> <span class="va">None</span>, ax <span class="op">=</span> <span class="va">None</span>, legend <span class="op">=</span> <span class="va">True</span>):</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>    node_kwargs <span class="op">=</span> {<span class="st">"node_size"</span> : <span class="dv">50</span>, <span class="st">"edgecolors"</span> : <span class="st">'black'</span>}</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> clusters <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>: </span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>        num_clusters <span class="op">=</span> np.unique(<span class="bu">list</span>(clusters.values())).shape[<span class="dv">0</span>]</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>        cluster_to_color <span class="op">=</span> [plt.cm.Set3(i) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(num_clusters)]</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>        node_kwargs[<span class="st">"node_color"</span>] <span class="op">=</span> [cluster_to_color[clusters[i]] <span class="cf">for</span> i <span class="kw">in</span> G.nodes()]</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>    edge_kwargs <span class="op">=</span> {<span class="st">"edge_color"</span> : <span class="st">"gray"</span>, <span class="st">"alpha"</span> : <span class="fl">0.3</span>}</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>    pos <span class="op">=</span> nx.spring_layout(G)</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>    nx.draw_networkx_edges(G, pos, ax <span class="op">=</span> ax, <span class="op">**</span>edge_kwargs)</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>    nx.draw_networkx_nodes(G, pos, ax <span class="op">=</span> ax, <span class="op">**</span>node_kwargs)</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>    off <span class="op">=</span> ax.axis(<span class="st">"off"</span>)</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (clusters <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>) <span class="kw">and</span> legend: </span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>        classes <span class="op">=</span> [<span class="st">"MP*1"</span>, <span class="st">"MP*2"</span>, <span class="st">"PC"</span>, <span class="st">"PC*"</span>, <span class="st">"PSI*"</span>]</span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>        legend_elements <span class="op">=</span> [Line2D([<span class="dv">0</span>], [<span class="dv">0</span>], marker<span class="op">=</span><span class="st">'o'</span>, color<span class="op">=</span><span class="st">"black"</span>, label<span class="op">=</span>classes[i], lw<span class="op">=</span><span class="dv">0</span>, markerfacecolor<span class="op">=</span>plt.cm.Set3(i), markersize<span class="op">=</span><span class="dv">10</span>) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">5</span>)]</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>        ax.legend(handles<span class="op">=</span>legend_elements, loc<span class="op">=</span><span class="st">'upper right'</span>)</span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> labels_to_array(z, G):</span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(z, <span class="bu">dict</span>):</span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>        z <span class="op">=</span> np.array([z[node] <span class="cf">for</span> node <span class="kw">in</span> G.nodes])</span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> <span class="bu">isinstance</span>(z, <span class="bu">list</span>):</span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>        z <span class="op">=</span> np.array(z)</span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> z</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>

<div class="no-row-height column-margin column-container"><div class="">
<p>This hidden code cell implements a number of utilities for processing and node labels associated with them. It also has a lot of plotting implementations.</p>
</div></div><div id="bf65e8bb" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>G <span class="op">=</span> acquire_contact_data()</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>clusters <span class="op">=</span> nx.get_node_attributes(G, <span class="st">"class"</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>draw_graph(G, clusters <span class="op">=</span> clusters, ax <span class="op">=</span> ax)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="13-modularity-maximization_files/figure-html/cell-3-output-1.png" class="figure-img" width="540" height="389"></p>
</figure>
</div>
</div>
</div>
<p>There are 5 classes in the network: MP*1, MP*2, PC, PC*, and PSI*. Visual inspection of the plot suggests that the network may be assortative with respect to class: there are many edges between nodes of the same class, and fewer edges between nodes of different classes. There is even some <em>nested</em> assortative structure. The MP*1 and MP*2 classes seem to form a distinct subgraph. Students in MP*1 are more likely interact amongst themselves, but if they do interact with anyone outside their own class, it is likely to be with students in MP*2.</p>
<section id="recall-measuring-assortativity-with-modularity" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="recall-measuring-assortativity-with-modularity">Recall: Measuring Assortativity with Modularity</h2>
<p>Recall that we can quantify the extent to which a network is assortative with respect to some attribute by calculating the <em>modularity</em> of the network with respect to that attribute. Let <span class="math inline">\(\mathcal{Z}\)</span> be a finite set of possible node labels, and let <span class="math inline">\(\mathbf{z} \in \mathcal{Z}^n\)</span> be a vector whose <span class="math inline">\(i\)</span>th entry gives the label of the <span class="math inline">\(i\)</span>th node. Then, the modularity functional of <span class="math inline">\(G\)</span> with respect to <span class="math inline">\(\mathbf{z}\)</span> as defined by <span class="citation" data-cites="newman2004finding">Newman and Girvan (<a href="#ref-newman2004finding" role="doc-biblioref">2004</a>)</span> is given by the formula</p>
<p><span class="math display">\[
\begin{aligned}
    Q(G, \mathbf{z}) = \frac{1}{2m} \sum_{i,j \in N} \left[ a_{ij} - \frac{k_i k_j}{2m} \right] \delta_{z_i z_j} \,,
\end{aligned}
\]</span></p>
<p>This formula can be motivated in several ways.</p>
<ol type="1">
<li><strong>Comparison to random graphs</strong>: <span class="math inline">\(Q\)</span> is a comparison of <span class="math inline">\(a_{ij}\)</span> to the expected number of edges between nodes <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> if edges were placed at random while approximately preserving the degree sequence (This point is surprisingly subtle; see <span class="citation" data-cites="chodrow2020moments">Chodrow (<a href="#ref-chodrow2020moments" role="doc-biblioref">2020</a>)</span> for a discussion of some of the difficulties.).</li>
<li><strong>Dynamical stability</strong>: <span class="math inline">\(Q\)</span> is a measure of the tendency of random walks on the graph <span class="math inline">\(G\)</span> to stay within the same community; see <span class="citation" data-cites="delvenne2010stability">Delvenne, Yaliraki, and Barahona (<a href="#ref-delvenne2010stability" role="doc-biblioref">2010</a>)</span>.</li>
<li><strong>Statistical inference</strong>: <span class="math inline">\(Q\)</span> is a term in the objective function for a statistical inference task in which we try to infer the labels <span class="math inline">\(\mathbf{z}\)</span> from the graph structure; see <span class="citation" data-cites="newman2016equivalence">Newman (<a href="#ref-newman2016equivalence" role="doc-biblioref">2016</a>)</span>.</li>
</ol>
<div class="page-columns page-full"><p>We often informally say that the network is <em>assortative</em> or <em>has modular structure</em> when <span class="math inline">\(Q\)</span> is substantially larger than 0. </p><div class="no-row-height column-margin column-container"><span class="margin-aside">The question of what counts as “substantially larger” can be tricky; for example; see discussion in <span class="citation" data-cites="zhang2014scalable">Zhang and Moore (<a href="#ref-zhang2014scalable" role="doc-biblioref">2014</a>)</span> for cases in which Erdős–Rényi random graphs can have high modularity with respect to a carefully-chosen partition.</span></div></div>
<p>Networkx implements a function to compute the modularity, but it’s not difficult to implement our own either. We’ll structure our function to accept a vector of characters giving the class labels.</p>
<div id="031be5c6" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> modularity(G, z):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># converts z from a dict to an array if it isn't one already</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    z <span class="op">=</span> labels_to_array(z, G)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># form the matrices we need</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> nx.to_numpy_array(G)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> A.<span class="bu">sum</span>(axis <span class="op">=</span> <span class="dv">1</span>)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> G.number_of_edges()</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># computes a matrix whose ith entry is delta_{z_i, z_j}</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    delta <span class="op">=</span> z[:, <span class="va">None</span>] <span class="op">==</span> z[<span class="va">None</span>, :] </span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span><span class="op">/</span>(<span class="dv">2</span><span class="op">*</span>m)<span class="op">*</span>((A <span class="op">-</span> np.outer(k, k) <span class="op">/</span> (<span class="dv">2</span> <span class="op">*</span> m))<span class="op">*</span>delta).<span class="bu">sum</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now let’s try calling our function to find the modularity of the graph and its labels:</p>
<div id="10db7a9a" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>modularity(G, clusters)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="4">
<pre><code>np.float64(0.5039115128642156)</code></pre>
</div>
</div>
<p>Let’s do a quick check against the built-in implementation of modularity in Networkx. This implementation works just a bit differently: we need to pass a list of sets in which each set represents a community.</p>
<div id="ad0cebd1" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>communities <span class="op">=</span> [{node <span class="cf">for</span> node <span class="kw">in</span> G.nodes() <span class="cf">if</span> clusters[node] <span class="op">==</span> i} <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">5</span>)]</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>nx.community.modularity(G, communities)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="5">
<pre><code>0.5039115128642155</code></pre>
</div>
</div>
<p>Our answers agree!</p>
</section>
<section id="the-community-detection-problem" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="the-community-detection-problem">The Community Detection Problem</h2>
<div class="page-columns page-full"><p>In the community detection problem, we consider a graph <span class="math inline">\(G\)</span> which we <em>suspect</em> to have some interesting modular structure, but we do not have access to the label vector <span class="math inline">\(\mathbf{z}\)</span>. Instead, we attempt to <em>find</em> a good label vector based on the graph structure itself. </p><div class="no-row-height column-margin column-container"><span class="margin-aside">This kind of task is also often called “graph clustering” or “graph partitioning.” The idea that networks have community structure and that algorithms can find this structure was popularized by <span class="citation" data-cites="girvan2002community">Girvan and Newman (<a href="#ref-girvan2002community" role="doc-biblioref">2002</a>)</span>.</span></div></div>

<div class="no-row-height column-margin column-container"><div class="">
<p>So, in the community detection problem, we have access to an <em>unlabeled graph</em> like this one.</p>
<div id="9f618075" class="cell" data-execution_count="6">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="13-modularity-maximization_files/figure-html/cell-7-output-1.png" class="figure-img img-fluid" width="540" height="389"></p>
</figure>
</div>
</div>
</div>
<p>We’d like to find a “good” partition of the nodes.</p>
</div></div><section id="community-detection-as-optimization" class="level3">
<h3 class="anchored" data-anchor-id="community-detection-as-optimization">Community Detection as Optimization</h3>
<p>Many algorithms for community detection are based on the idea of optimization. The goal is to formulate a function <span class="math inline">\(R(G, \mathbf{z})\)</span> with two main properties:</p>
<ol type="1">
<li><span class="math inline">\(R(G, \mathbf{z})\)</span> is large when <span class="math inline">\(\mathbf{z}\)</span> is a “good” partition of the graph.</li>
<li>It is feasible to find a partition of <span class="math inline">\(\mathbf{z}\)</span> which gives a large value of <span class="math inline">\(R(G, \mathbf{z})\)</span> in practical computational time.</li>
</ol>
<p>Roughly, criterion 1 says that we are “optimizing the right thing,” while criterion 2 says that “optimizing the right thing” is in fact computationally feasible. Due to its many useful interpretations, the modularity <span class="math inline">\(Q\)</span> has been a very popular choice of objective functions for community detection. In <a href="../chapters/19-spectral-clustering.html">later notes</a>, we’ll explore an alternative objective function.</p>
</section>
</section>
<section id="a-community-detection-algorithm-greedy-agglomerative-clustering" class="level2">
<h2 class="anchored" data-anchor-id="a-community-detection-algorithm-greedy-agglomerative-clustering">A Community Detection Algorithm: Greedy Agglomerative Clustering</h2>
<p>Unfortunately, exactly maximizing the modularity is NP-hard <span class="citation" data-cites="brandes2007modularity">(<a href="#ref-brandes2007modularity" role="doc-biblioref">Brandes et al. 2007</a>)</span>, and so we need to consider tractable heuristic algorithms that we hope may lead us to solutions which are close to optimal.</p>
<p>One simple algorithm for heuristic modularity maximization is the <em>greedy agglomerative clustering</em> algorithm. The idea is to start with each node in its own community, and then iteratively swap the labels of nodes until no improvement in the modularity can be obtained. An important computational feature of this algorithm is that we don’t need to always recalculate the modularity from scratch. Instead, we can simply <em>update</em> the modularity with the change that results from swapping a node <span class="math inline">\(h\)</span> from community <span class="math inline">\(x\)</span> to community <span class="math inline">\(y\)</span>. Let <span class="math inline">\(\mathbf{z}\)</span> be the label vector before the swap and let <span class="math inline">\(\mathbf{z}'\)</span> be the label vector after the swap. Then,</p>
<p><span class="math display">\[
\begin{aligned}
    Q(G, \mathbf{z}') - Q(G, \mathbf{z}) &amp;=  \frac{1}{2m}\sum_{i\neq j} \left[ a_{ij} - \frac{k_ik_j}{2m} \right] \delta_{z_i', z_j'} - \frac{1}{2m}\sum_{i\neq j} \left[ a_{ij} - \frac{k_ik_j}{2m} \right] \delta_{z_i, z_j} \\
    &amp;= \frac{1}{2m}\sum_{i\neq j} \left[ a_{ij} - \frac{k_ik_j}{2m} \right] \left(\delta_{z_i', z_j'} - \delta_{z_i, z_j}\right)\;.
\end{aligned}
\]</span></p>
<p>We only have <span class="math inline">\(\delta_{z_i', z_j'} - \delta_{z_i, z_j} \neq 0\)</span> when either <span class="math inline">\(i\)</span> or <span class="math inline">\(j\)</span> is equal to <span class="math inline">\(h\)</span>. If <span class="math inline">\(i = h\)</span>, then <span class="math inline">\(z_i = x\)</span>, <span class="math inline">\(z_i' = y\)</span>, and <span class="math inline">\(z_j' = z_j\)</span> for all <span class="math inline">\(j \neq h\)</span>. So,</p>
<p><span class="math display">\[
\begin{aligned}
    Q(G, \mathbf{z}') - Q(G, \mathbf{z}) &amp;= \frac{1}{2m}\left(\sum_{j\neq h} \left[ a_{hj} - \frac{k_hk_j}{2m} \right] \left(\delta_{y, z_j} - \delta_{x, z_j}\right) + \sum_{i\neq h} \left[ a_{ih} - \frac{k_ik_h}{2m} \right] \left(\delta_{z_i, y} - \delta_{z_i, x}\right) \right) \\
    &amp;= \frac{1}{m}\left(\sum_{j\neq h} \left[ a_{hj} - \frac{k_hk_j}{2m} \right] \left(\delta_{y, z_j} - \delta_{x, z_j}\right)  \right)\;,
\end{aligned}
\]</span></p>
<p>where in the second line we have used the fact that the two sums appearing are just re-indexed copies of each other. Here’s our implementation:</p>
<div id="42e12dfa" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> greedy_clustering(G, num_steps <span class="op">=</span> <span class="bu">int</span>(<span class="fl">1e4</span>)):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># initialize every node in its own cluster</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    labels <span class="op">=</span> np.arange(G.number_of_nodes()) </span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># compute the modularity initially -- we'll update it as we go</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    progress <span class="op">=</span> [modularity(G, labels)]</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># matrices and vectors we'll need</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> G.number_of_edges()</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> nx.to_numpy_array(G)</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> A.<span class="bu">sum</span>(axis <span class="op">=</span> <span class="dv">1</span>)</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># main loop</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(num_steps):</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>        <span class="co"># pick two nodes at random and retrieve their labels</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>        i, j <span class="op">=</span> np.random.choice(G.number_of_nodes(), <span class="dv">2</span>, replace <span class="op">=</span> <span class="va">False</span>)</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>        <span class="co"># prospective swap is that i will change its label from x to y</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> labels[i]</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> labels[j]</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> x <span class="op">==</span> y: </span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>: </span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>            <span class="co"># compute the change in modularity of the prospective swap</span></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>            change_vec <span class="op">=</span> <span class="dv">1</span><span class="op">/</span>m <span class="op">*</span>  ((A[i] <span class="op">-</span> k[i]<span class="op">*</span>k<span class="op">/</span>(<span class="dv">2</span><span class="op">*</span>m))<span class="op">*</span>(<span class="dv">1</span><span class="op">*</span>(y <span class="op">==</span> labels) <span class="op">-</span> <span class="dv">1</span><span class="op">*</span>(x <span class="op">==</span> labels)))</span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>            change_vec[i] <span class="op">=</span> <span class="dv">0</span> <span class="co"># zero out the term corresponding to i</span></span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>            change <span class="op">=</span> change_vec.<span class="bu">sum</span>()</span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>            <span class="co"># if positive, update the labels and store the new modularity for visualization later</span></span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> change <span class="op">&gt;</span> <span class="dv">0</span>: </span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a>                labels[i] <span class="op">=</span> y</span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a>                progress.append(progress[<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> change)</span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a>    <span class="co"># postprocessing: we need to convert the labels into a dict for visualization etc. </span></span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a>    distinct_labels <span class="op">=</span> np.unique(labels)</span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a>    label_map <span class="op">=</span> {<span class="bu">int</span>(distinct_label) : i <span class="cf">for</span> i, distinct_label <span class="kw">in</span> <span class="bu">enumerate</span>(distinct_labels)}</span>
<span id="cb8-42"><a href="#cb8-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-43"><a href="#cb8-43" aria-hidden="true" tabindex="-1"></a>    greedy_clusters <span class="op">=</span> {i : label_map[label] <span class="cf">for</span> i, label <span class="kw">in</span> <span class="bu">enumerate</span>(labels)}</span>
<span id="cb8-44"><a href="#cb8-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-45"><a href="#cb8-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> greedy_clusters, np.array(progress)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s run our algorithm…</p>
<div id="6f6f0cb1" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>greedy_clusters, progress <span class="op">=</span> greedy_clustering(G, num_steps <span class="op">=</span> <span class="bu">int</span>(<span class="fl">1e5</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>…and visualize how we did.</p>
<div id="223a0858" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize <span class="op">=</span> (<span class="dv">7</span>, <span class="fl">3.5</span>))</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].plot(progress)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].<span class="bu">set</span>(xlabel <span class="op">=</span> <span class="st">"Number of swaps performed"</span>, ylabel <span class="op">=</span> <span class="st">"Modularity"</span>, title <span class="op">=</span> <span class="st">"Progress over swaps"</span>)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].<span class="bu">set</span>(title <span class="op">=</span> <span class="ss">f"Modularity of greedy partition = </span><span class="sc">{</span>modularity(G, greedy_clusters)<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].axis(<span class="st">"off"</span>)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>draw_graph(G, clusters <span class="op">=</span> greedy_clusters, ax <span class="op">=</span> ax[<span class="dv">1</span>], legend <span class="op">=</span> <span class="va">False</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="13-modularity-maximization_files/figure-html/cell-10-output-1.png" class="figure-img" width="594" height="331"></p>
</figure>
</div>
</div>
</div>
<p>This algorithm required several hundred executed swaps (and thousands of non-executed swaps) in order to achieve the visualized clustering. The clusters shown actually achieve a modularity that is comparable to the original clustering.</p>
</section>
<section id="validation-of-community-detection-algorithms" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="validation-of-community-detection-algorithms">Validation of Community Detection Algorithms</h2>
<div class="page-columns page-full"><p>How do we tell whether a community detection algorithm is “good”? One standard way is to compare the clusters found by that algorithm to the true clusters, when such true clusters are available.  Generally, we’d like to use a function <span class="math inline">\(f(\mathbf{z}, \mathbf{z}')\)</span> which measures the similarity between the two label vectors <span class="math inline">\(\mathbf{z}\)</span> and <span class="math inline">\(\mathbf{z}'\)</span>; we’d have <span class="math inline">\(f(\mathbf{z}, \mathbf{z}') = 1\)</span> when the two vectors are identical (up to permutations of labels) and <span class="math inline">\(f(\mathbf{z}, \mathbf{z}') = 0\)</span> when the two vectors are completely uncorrelated.</p><div class="no-row-height column-margin column-container"><span class="margin-aside">Though see <span class="citation" data-cites="peel2017ground">Peel, Larremore, and Clauset (<a href="#ref-peel2017ground" role="doc-biblioref">2017</a>)</span> for a discussion of the limitations of this approach.</span></div></div>
<p>There are several metrics which are appropriate to this task. We’ll illustrate one standard such vector, the <em>normalized mutual information</em> or NMI. The NMI has formula</p>
<p><span class="math display">\[
\begin{aligned}
    \text{NMI}(\mathbf{z}, \mathbf{z}') = 2 \frac{I(\mathbf{z}, \mathbf{z}')}{H(\mathbf{z}) + H(\mathbf{z}')}\;,
\end{aligned}
\]</span></p>
<p>where <span class="math inline">\(I(\mathbf{z}, \mathbf{z}')\)</span> is the mutual information between the two label vectors and <span class="math inline">\(H(\mathbf{z})\)</span> is the entropy of the label vector.</p>
<p>To define these two quantities, let <span class="math inline">\(p(z,z')\)</span> be proportion of the time that a randomly picked node has label <span class="math inline">\(z\)</span> in <span class="math inline">\(\mathbf{z}\)</span> and <span class="math inline">\(z'\)</span> in <span class="math inline">\(\mathbf{z'}\)</span>: <span class="math display">\[
\begin{aligned}
    p(z,z') = \frac{1}{n} \sum_{i} \delta_{z, z_i}\delta_{z', z_i'}\;.
\end{aligned}
\]</span></p>
<p>Also define <span class="math inline">\(p(z) = \sum_{z' \in \mathcal{Z}} p(z,z')\)</span> and <span class="math inline">\(p(z') = \sum_{z \in \mathcal{Z}} p(z,z')\)</span>. Then,</p>
<p><span class="math display">\[
\begin{aligned}
    H(\mathbf{z}) &amp;= - \sum_{z \in \mathcal{Z}} p(z) \log p(z) \\
    I(\mathbf{z}, \mathbf{z}') &amp;= \sum_{z \in \mathcal{Z}} \sum_{z' \in \mathcal{Z}} p(z,z') \log \frac{p(z,z')}{p(z)p(z')} \;.
\end{aligned}
\]</span></p>
<div class="page-columns page-full"><p>Roughly, <span class="math inline">\(H(\mathbf{z})\)</span> measures the “diversity” of labels represented in <span class="math inline">\(\mathbf{z}\)</span>, while <span class="math inline">\(I(\mathbf{z}, \mathbf{z}')\)</span> measures the extent to which knowing a node’s label in <span class="math inline">\(\mathbf{z}\)</span> helps you guess its label in <span class="math inline">\(\mathbf{z}'\)</span>. </p><div class="no-row-height column-margin column-container"><span class="margin-aside">The entropy and mutual information are both quantities introduced by <span class="citation" data-cites="shannon1948mathematical">Shannon (<a href="#ref-shannon1948mathematical" role="doc-biblioref">1948</a>)</span> in a famous paper that launched the field of <em>information theory</em>. Information theory is widely used in electrical engineering, statistics, statistical physics, and machine learning. See <span class="citation" data-cites="cover2006elements">Cover and Thomas (<a href="#ref-cover2006elements" role="doc-biblioref">2006</a>)</span> for a modern treatment of the topic.</span></div></div>
<p>Here are implementations of the entropy, mutual information, and normalized mutual information:</p>
<div id="884a7879" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> H(z, G): </span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    z <span class="op">=</span> labels_to_array(z, G)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(z)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> np.array([np.mean(z <span class="op">==</span> i) <span class="cf">for</span> i <span class="kw">in</span> np.unique(z)])</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span>np.<span class="bu">sum</span>(p<span class="op">*</span>np.log(p))</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> I(z, z_, G):</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    z  <span class="op">=</span> labels_to_array(z, G)</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    z_ <span class="op">=</span> labels_to_array(z_, G)</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(z)</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># we're going to accumulate the joint distribution of labels </span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># in a for-loop. </span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># an alternative would be to form it as an array and then reduce</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    info <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> np.unique(z): </span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> np.unique(z_): </span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>            p <span class="op">=</span> np.mean((z <span class="op">==</span> i) <span class="op">&amp;</span> (z_ <span class="op">==</span> j))</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> p <span class="op">==</span> <span class="dv">0</span>: </span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>            info <span class="op">+=</span> p<span class="op">*</span>np.log(p<span class="op">/</span>(np.mean(z <span class="op">==</span> i)<span class="op">*</span>np.mean(z_ <span class="op">==</span> j)))</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> info</span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> NMI(z, z_, G): </span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">2</span><span class="op">*</span>I(z, z_, G)<span class="op">/</span>(H(z, G) <span class="op">+</span> H(z_, G))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we can assess the performance of our greedy clustering algorithm against ground truth:</p>
<div id="27a572ef" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>NMI(clusters, greedy_clusters, G)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="11">
<pre><code>np.float64(0.8675176242030571)</code></pre>
</div>
</div>
<p>Frequently when assessing a clustering method, it’s not really easy to tell out of context whether it’s useful or not. We often assess the method against competing methods, and often on several data sets.</p>
<div id="d3ef4b76" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_suite(G, clusters):</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># retrieve our own greedy clusters and assess</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    greedy_clusters <span class="op">=</span> greedy_clustering(G, num_steps <span class="op">=</span> <span class="bu">int</span>(<span class="fl">1e4</span>))[<span class="dv">0</span>]</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Our greedy agglomeration clustering has NMI = </span><span class="sc">{</span>NMI(clusters, greedy_clusters, G)<span class="sc">:.3f}</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># now compare against an array of built-in methods. </span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> cluster_from_partition(partition):</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> {node : i <span class="cf">for</span> i, nodes <span class="kw">in</span> <span class="bu">enumerate</span>(partition) <span class="cf">for</span> node <span class="kw">in</span> nodes}</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    methods <span class="op">=</span> [nx.community.greedy_modularity_communities, nx.community.asyn_lpa_communities, nx.community.label_propagation_communities, nx.community.louvain_communities]</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> method <span class="kw">in</span> methods:</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>        partition <span class="op">=</span> method(G)</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>        inferred_clusters <span class="op">=</span> cluster_from_partition(partition)</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Method </span><span class="sc">{</span>method<span class="sc">.</span><span class="va">__name__</span><span class="sc">}</span><span class="ss"> has NMI = </span><span class="sc">{</span>NMI(clusters, inferred_clusters, G)<span class="sc">:.3f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s run our test suite:</p>
<div id="07372504" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>test_suite(G, clusters)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Our greedy agglomeration clustering has NMI = 0.855

Method greedy_modularity_communities has NMI = 0.748
Method asyn_lpa_communities has NMI = 0.581
Method label_propagation_communities has NMI = 0.868
Method louvain_communities has NMI = 0.868</code></pre>
</div>
</div>
<p>Our algorithm appears to be competitive with several of the built-in methods for community detection implemented in Networkx.</p>
<p>Would we get different results on another graph? Let’s load up our friend the Karate Club graph:</p>
<div id="5cc82f35" class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>G_karate <span class="op">=</span> nx.karate_club_graph()</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>G_karate <span class="op">=</span> nx.convert_node_labels_to_integers(G_karate)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>clusters_karate <span class="op">=</span> nx.get_node_attributes(G_karate, <span class="st">"club"</span>)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>clusters_karate <span class="op">=</span> {node : <span class="dv">0</span> <span class="cf">if</span> club <span class="op">==</span> <span class="st">"Mr. Hi"</span> <span class="cf">else</span> <span class="dv">1</span> <span class="cf">for</span> node, club <span class="kw">in</span> clusters_karate.items()}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we’ll run our test suite again:</p>
<div id="6e42fb1e" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>test_suite(G_karate, clusters_karate)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Our greedy agglomeration clustering has NMI = 0.434

Method greedy_modularity_communities has NMI = 0.565
Method asyn_lpa_communities has NMI = 0.481
Method label_propagation_communities has NMI = 0.364
Method louvain_communities has NMI = 0.588</code></pre>
</div>
</div>
<p>Our algorithm appears to be a bit less impressive in this context, although results may vary due to randomness. A full test suite would often involve averaging the NMI over many runs of each algorithm.</p>
</section>
<section id="other-approaches" class="level2">
<h2 class="anchored" data-anchor-id="other-approaches">Other Approaches</h2>
<p>There are many other ways to perform community detection in networks. Sticking to the setting of undirected graphs, we still have lots of choices:</p>
<ol type="1">
<li>We can use a different algorithm to optimize modularity.</li>
<li>We can optimize something other than modularity.</li>
<li>We can decide that optimization-based community detection is not what we want to do at all—instead we can use methods based on statistical inference and sampling (e.g. <span class="citation" data-cites="peixoto2019bayesian">Peixoto (<a href="#ref-peixoto2019bayesian" role="doc-biblioref">2019</a>)</span>).</li>
</ol>
<p>There are additional choices and complications introduced when considering directed graphs or graphs in which edges can include more than two nodes.</p>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>


<!-- -->

<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-brandes2007modularity" class="csl-entry" role="listitem">
Brandes, Ulrik, Daniel Delling, Marco Gaertler, Robert Gorke, Martin Hoefer, Zoran Nikoloski, and Dorothea Wagner. 2007. <span>“On Modularity Clustering.”</span> <em>IEEE Transactions on Knowledge and Data Engineering</em> 20 (2): 172–88.
</div>
<div id="ref-chodrow2020moments" class="csl-entry" role="listitem">
Chodrow, Philip S. 2020. <span>“Moments of Uniform Random Multigraphs with Fixed Degree Sequences.”</span> <em>SIAM Journal on Mathematics of Data Science</em> 2 (4): 1034–65.
</div>
<div id="ref-cover2006elements" class="csl-entry" role="listitem">
Cover, Thomas M., and Joy A Thomas. 2006. <em>Elements of Information Theory</em>. Wiley-Interscience.
</div>
<div id="ref-delvenne2010stability" class="csl-entry" role="listitem">
Delvenne, J-C, Sophia N Yaliraki, and Mauricio Barahona. 2010. <span>“Stability of Graph Communities Across Time Scales.”</span> <em>Proceedings Of The National Academy Of Sciences</em> 107 (29): 12755–60.
</div>
<div id="ref-fournet2014contact" class="csl-entry" role="listitem">
Fournet, Julie, and Alain Barrat. 2014. <span>“Contact Patterns Among High School Students.”</span> <em>PloS One</em> 9 (9): e107878.
</div>
<div id="ref-girvan2002community" class="csl-entry" role="listitem">
Girvan, Michelle, and Mark EJ Newman. 2002. <span>“Community Structure in Social and Biological Networks.”</span> <em>Proceedings of the National Academy of Sciences</em> 99 (12): 7821–26.
</div>
<div id="ref-newman2016equivalence" class="csl-entry" role="listitem">
Newman, Mark EJ. 2016. <span>“Equivalence Between Modularity Optimization and Maximum Likelihood Methods for Community Detection.”</span> <em>Physical Review E</em> 94 (5): 052315.
</div>
<div id="ref-newman2004finding" class="csl-entry" role="listitem">
Newman, Mark EJ, and Michelle Girvan. 2004. <span>“Finding and Evaluating Community Structure in Networks.”</span> <em>Physical Review E</em> 69 (2): 026113.
</div>
<div id="ref-peel2017ground" class="csl-entry" role="listitem">
Peel, Leto, Daniel B Larremore, and Aaron Clauset. 2017. <span>“The Ground Truth about Metadata and Community Detection in Networks.”</span> <em>Science Advances</em> 3 (5): e1602548.
</div>
<div id="ref-peixoto2019bayesian" class="csl-entry" role="listitem">
Peixoto, Tiago P. 2019. <span>“Bayesian Stochastic Blockmodeling.”</span> <em>Advances in Network Clustering and Blockmodeling</em>, 289–332.
</div>
<div id="ref-shannon1948mathematical" class="csl-entry" role="listitem">
Shannon, Claude Elwood. 1948. <span>“A Mathematical Theory of Communication.”</span> <em>The Bell System Technical Journal</em> 27 (3): 379–423.
</div>
<div id="ref-zhang2014scalable" class="csl-entry" role="listitem">
Zhang, Pan, and Cristopher Moore. 2014. <span>“Scalable Detection of Statistically Significant Communities and Hierarchies, Using Message Passing for Modularity.”</span> <em>Proceedings of the National Academy of Sciences</em> 111 (51): 18144–49.
</div>
</div>
</section>

<p><br> <br> <span style="color:grey;">© Heather Zinn Brooks and Phil Chodrow, 2025</span></p></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../chapters/11-generating-functions.html" class="pagination-link" aria-label="Probability Generating Functions">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Probability Generating Functions</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../chapters/19-spectral-clustering.html" class="pagination-link" aria-label="Spectral Clustering">
        <span class="nav-page-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Spectral Clustering</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb20" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="an">code-fold:</span><span class="co"> false</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="an">code-summary:</span><span class="co"> "Show code"</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="an">bibliography:</span><span class="co"> ../refs.bib</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="fu"># Community Detection and Modularity Maximization</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>*Open the live notebook in Google Colab [here](https://colab.research.google.com/github/network-science-notes/network-science-notes.github.io/blob/main/docs/live-notebooks/13-modularity-maximization.ipynb).* </span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>In a <span class="co">[</span><span class="ot">previous lecture</span><span class="co">](06-modularity.qmd)</span>, we introduced the idea of *assortativity* in networks. Roughly, a network is assortative with respect to some attribute if nodes which share that attribute are more likely to be connected to each other than to nodes without that attribute.</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>Our data for this set of lecture notes is a data set of social interactions between students at a French high school in 2012. The data was collected by @fournet2014contact as part of the <span class="co">[</span><span class="ot">SocioPatterns project</span><span class="co">](http://www.sociopatterns.org/)</span>. Students were given wearable sensors which would ping when two students were in close proximity and facing each other. Each of these pings is an edge in the raw data, although in our processing for this lecture we simplify the data set down so that there is an edge between each pair of students who interacted at all during the data collection period. </span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>In this high school, students were tracked into one of five classes: </span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>MP<span class="sc">\*</span>1 and MP<span class="sc">\*</span>2 were two classes focusing on mathematics and physics. </span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>PC and PC<span class="sc">\*</span> were two classes focusing on physics and chemistry. </span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>PSI<span class="sc">\*</span> was one class focusing on engineering. </span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a>We might reasonably expect that students in the same class would interact more with each other than with students in other classes. Let's acquire the data and visualize the network to begin to develop a feel for this idea. </span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a><span class="co">#|code-fold: true</span></span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> networkx <span class="im">as</span> nx</span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib <span class="im">import</span> pyplot <span class="im">as</span> plt</span>
<span id="cb20-32"><a href="#cb20-32" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib.lines <span class="im">import</span> Line2D <span class="co"># for legend later</span></span>
<span id="cb20-33"><a href="#cb20-33" aria-hidden="true" tabindex="-1"></a>plt.style.use(<span class="st">'seaborn-v0_8-whitegrid'</span>)</span>
<span id="cb20-34"><a href="#cb20-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-35"><a href="#cb20-35" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> unweight(G):</span>
<span id="cb20-36"><a href="#cb20-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> source, target <span class="kw">in</span> G.edges():</span>
<span id="cb20-37"><a href="#cb20-37" aria-hidden="true" tabindex="-1"></a>        G[source][target][<span class="st">'weight'</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb20-38"><a href="#cb20-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> G</span>
<span id="cb20-39"><a href="#cb20-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-40"><a href="#cb20-40" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> acquire_contact_data():</span>
<span id="cb20-41"><a href="#cb20-41" aria-hidden="true" tabindex="-1"></a>    url <span class="op">=</span> <span class="st">"https://raw.githubusercontent.com/network-science-notes/network-science-notes.github.io/refs/heads/main/data/contact-high-school.csv"</span></span>
<span id="cb20-42"><a href="#cb20-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-43"><a href="#cb20-43" aria-hidden="true" tabindex="-1"></a>    contact <span class="op">=</span> pd.read_csv(url, sep <span class="op">=</span> <span class="st">"</span><span class="ch">\t</span><span class="st">"</span>, names <span class="op">=</span> [<span class="st">"time"</span>, <span class="st">"source"</span>, <span class="st">"target"</span>, <span class="st">"class_s"</span>, <span class="st">"class_t"</span>])[[<span class="st">"source"</span>, <span class="st">"target"</span>, <span class="st">"class_s"</span>, <span class="st">"class_t"</span>]]</span>
<span id="cb20-44"><a href="#cb20-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-45"><a href="#cb20-45" aria-hidden="true" tabindex="-1"></a>    G <span class="op">=</span> nx.from_pandas_edgelist(contact)</span>
<span id="cb20-46"><a href="#cb20-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-47"><a href="#cb20-47" aria-hidden="true" tabindex="-1"></a>    class_labels <span class="op">=</span> contact[[<span class="st">"source"</span>, <span class="st">"class_s"</span>]].drop_duplicates(subset<span class="op">=</span>[<span class="st">'source'</span>])</span>
<span id="cb20-48"><a href="#cb20-48" aria-hidden="true" tabindex="-1"></a>    class_labels <span class="op">=</span> <span class="bu">dict</span>(<span class="bu">zip</span>(class_labels[<span class="st">"source"</span>], class_labels[<span class="st">"class_s"</span>]))</span>
<span id="cb20-49"><a href="#cb20-49" aria-hidden="true" tabindex="-1"></a>    more_class_labels <span class="op">=</span> contact[[<span class="st">"target"</span>, <span class="st">"class_t"</span>]].drop_duplicates(subset<span class="op">=</span>[<span class="st">'target'</span>])</span>
<span id="cb20-50"><a href="#cb20-50" aria-hidden="true" tabindex="-1"></a>    more_class_labels <span class="op">=</span> <span class="bu">dict</span>(<span class="bu">zip</span>(more_class_labels[<span class="st">"target"</span>], more_class_labels[<span class="st">"class_t"</span>]))</span>
<span id="cb20-51"><a href="#cb20-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-52"><a href="#cb20-52" aria-hidden="true" tabindex="-1"></a>    class_labels.update(more_class_labels)</span>
<span id="cb20-53"><a href="#cb20-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-54"><a href="#cb20-54" aria-hidden="true" tabindex="-1"></a>    classes <span class="op">=</span> [<span class="st">"MP*1"</span>, <span class="st">"MP*2"</span>, <span class="st">"PC"</span>, <span class="st">"PC*"</span>, <span class="st">"PSI*"</span>]</span>
<span id="cb20-55"><a href="#cb20-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-56"><a href="#cb20-56" aria-hidden="true" tabindex="-1"></a>    class_to_int <span class="op">=</span> {class_label : i <span class="cf">for</span> i, class_label <span class="kw">in</span> <span class="bu">enumerate</span>(classes)}</span>
<span id="cb20-57"><a href="#cb20-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-58"><a href="#cb20-58" aria-hidden="true" tabindex="-1"></a>    class_labels <span class="op">=</span> {node : class_to_int[label] <span class="cf">for</span> node, label <span class="kw">in</span> class_labels.items()}</span>
<span id="cb20-59"><a href="#cb20-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-60"><a href="#cb20-60" aria-hidden="true" tabindex="-1"></a>    nx.set_node_attributes(G, class_labels, <span class="st">"class"</span>)</span>
<span id="cb20-61"><a href="#cb20-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-62"><a href="#cb20-62" aria-hidden="true" tabindex="-1"></a>    G <span class="op">=</span> nx.convert_node_labels_to_integers(G)</span>
<span id="cb20-63"><a href="#cb20-63" aria-hidden="true" tabindex="-1"></a>    G <span class="op">=</span> unweight(G)</span>
<span id="cb20-64"><a href="#cb20-64" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> G</span>
<span id="cb20-65"><a href="#cb20-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-66"><a href="#cb20-66" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> draw_graph(G, clusters <span class="op">=</span> <span class="va">None</span>, ax <span class="op">=</span> <span class="va">None</span>, legend <span class="op">=</span> <span class="va">True</span>):</span>
<span id="cb20-67"><a href="#cb20-67" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-68"><a href="#cb20-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-69"><a href="#cb20-69" aria-hidden="true" tabindex="-1"></a>    node_kwargs <span class="op">=</span> {<span class="st">"node_size"</span> : <span class="dv">50</span>, <span class="st">"edgecolors"</span> : <span class="st">'black'</span>}</span>
<span id="cb20-70"><a href="#cb20-70" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> clusters <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>: </span>
<span id="cb20-71"><a href="#cb20-71" aria-hidden="true" tabindex="-1"></a>        num_clusters <span class="op">=</span> np.unique(<span class="bu">list</span>(clusters.values())).shape[<span class="dv">0</span>]</span>
<span id="cb20-72"><a href="#cb20-72" aria-hidden="true" tabindex="-1"></a>        cluster_to_color <span class="op">=</span> [plt.cm.Set3(i) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(num_clusters)]</span>
<span id="cb20-73"><a href="#cb20-73" aria-hidden="true" tabindex="-1"></a>        node_kwargs[<span class="st">"node_color"</span>] <span class="op">=</span> [cluster_to_color[clusters[i]] <span class="cf">for</span> i <span class="kw">in</span> G.nodes()]</span>
<span id="cb20-74"><a href="#cb20-74" aria-hidden="true" tabindex="-1"></a>    edge_kwargs <span class="op">=</span> {<span class="st">"edge_color"</span> : <span class="st">"gray"</span>, <span class="st">"alpha"</span> : <span class="fl">0.3</span>}</span>
<span id="cb20-75"><a href="#cb20-75" aria-hidden="true" tabindex="-1"></a>    pos <span class="op">=</span> nx.spring_layout(G)</span>
<span id="cb20-76"><a href="#cb20-76" aria-hidden="true" tabindex="-1"></a>    nx.draw_networkx_edges(G, pos, ax <span class="op">=</span> ax, <span class="op">**</span>edge_kwargs)</span>
<span id="cb20-77"><a href="#cb20-77" aria-hidden="true" tabindex="-1"></a>    nx.draw_networkx_nodes(G, pos, ax <span class="op">=</span> ax, <span class="op">**</span>node_kwargs)</span>
<span id="cb20-78"><a href="#cb20-78" aria-hidden="true" tabindex="-1"></a>    off <span class="op">=</span> ax.axis(<span class="st">"off"</span>)</span>
<span id="cb20-79"><a href="#cb20-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-80"><a href="#cb20-80" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (clusters <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>) <span class="kw">and</span> legend: </span>
<span id="cb20-81"><a href="#cb20-81" aria-hidden="true" tabindex="-1"></a>        classes <span class="op">=</span> [<span class="st">"MP*1"</span>, <span class="st">"MP*2"</span>, <span class="st">"PC"</span>, <span class="st">"PC*"</span>, <span class="st">"PSI*"</span>]</span>
<span id="cb20-82"><a href="#cb20-82" aria-hidden="true" tabindex="-1"></a>        legend_elements <span class="op">=</span> [Line2D([<span class="dv">0</span>], [<span class="dv">0</span>], marker<span class="op">=</span><span class="st">'o'</span>, color<span class="op">=</span><span class="st">"black"</span>, label<span class="op">=</span>classes[i], lw<span class="op">=</span><span class="dv">0</span>, markerfacecolor<span class="op">=</span>plt.cm.Set3(i), markersize<span class="op">=</span><span class="dv">10</span>) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">5</span>)]</span>
<span id="cb20-83"><a href="#cb20-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-84"><a href="#cb20-84" aria-hidden="true" tabindex="-1"></a>        ax.legend(handles<span class="op">=</span>legend_elements, loc<span class="op">=</span><span class="st">'upper right'</span>)</span>
<span id="cb20-85"><a href="#cb20-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-86"><a href="#cb20-86" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> labels_to_array(z, G):</span>
<span id="cb20-87"><a href="#cb20-87" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(z, <span class="bu">dict</span>):</span>
<span id="cb20-88"><a href="#cb20-88" aria-hidden="true" tabindex="-1"></a>        z <span class="op">=</span> np.array([z[node] <span class="cf">for</span> node <span class="kw">in</span> G.nodes])</span>
<span id="cb20-89"><a href="#cb20-89" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> <span class="bu">isinstance</span>(z, <span class="bu">list</span>):</span>
<span id="cb20-90"><a href="#cb20-90" aria-hidden="true" tabindex="-1"></a>        z <span class="op">=</span> np.array(z)</span>
<span id="cb20-91"><a href="#cb20-91" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> z</span>
<span id="cb20-92"><a href="#cb20-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-93"><a href="#cb20-93" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-94"><a href="#cb20-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-95"><a href="#cb20-95" aria-hidden="true" tabindex="-1"></a>::: {.column-margin}</span>
<span id="cb20-96"><a href="#cb20-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-97"><a href="#cb20-97" aria-hidden="true" tabindex="-1"></a>This hidden code cell implements a number of utilities for processing and node labels associated with them. It also has a lot of plotting implementations. </span>
<span id="cb20-98"><a href="#cb20-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-99"><a href="#cb20-99" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb20-100"><a href="#cb20-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-103"><a href="#cb20-103" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb20-104"><a href="#cb20-104" aria-hidden="true" tabindex="-1"></a>G <span class="op">=</span> acquire_contact_data()</span>
<span id="cb20-105"><a href="#cb20-105" aria-hidden="true" tabindex="-1"></a>clusters <span class="op">=</span> nx.get_node_attributes(G, <span class="st">"class"</span>)</span>
<span id="cb20-106"><a href="#cb20-106" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb20-107"><a href="#cb20-107" aria-hidden="true" tabindex="-1"></a>draw_graph(G, clusters <span class="op">=</span> clusters, ax <span class="op">=</span> ax)</span>
<span id="cb20-108"><a href="#cb20-108" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-109"><a href="#cb20-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-110"><a href="#cb20-110" aria-hidden="true" tabindex="-1"></a>There are 5 classes in the network: MP<span class="sc">\*</span>1, MP<span class="sc">\*</span>2, PC, PC<span class="sc">\*</span>, and PSI<span class="sc">\*</span>. Visual inspection of the plot suggests that the network may be assortative with respect to class: there are many edges between nodes of the same class, and fewer edges between nodes of different classes. There is even some *nested* assortative structure. The MP<span class="sc">\*</span>1 and MP<span class="sc">\*</span>2 classes seem to form a distinct subgraph. Students in MP<span class="sc">\*</span>1 are more likely interact amongst themselves, but if they do interact with anyone outside their own class, it is likely to be with students in MP<span class="sc">\*</span>2. </span>
<span id="cb20-111"><a href="#cb20-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-112"><a href="#cb20-112" aria-hidden="true" tabindex="-1"></a><span class="fu">## Recall: Measuring Assortativity with Modularity</span></span>
<span id="cb20-113"><a href="#cb20-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-114"><a href="#cb20-114" aria-hidden="true" tabindex="-1"></a>Recall that we can quantify the extent to which a network is assortative with respect to some attribute by calculating the *modularity* of the network with respect to that attribute. Let $\mathcal{Z}$ be a finite set of possible node labels, and let $\mathbf{z} \in \mathcal{Z}^n$ be a vector whose $i$th entry gives the label of the $i$th node. Then, the modularity functional of $G$ with respect to $\mathbf{z}$ as defined by @newman2004finding is given by the formula </span>
<span id="cb20-115"><a href="#cb20-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-116"><a href="#cb20-116" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb20-117"><a href="#cb20-117" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb20-118"><a href="#cb20-118" aria-hidden="true" tabindex="-1"></a>    Q(G, \mathbf{z}) = \frac{1}{2m} \sum_{i,j \in N} \left<span class="co">[</span><span class="ot"> a_{ij} - \frac{k_i k_j}{2m} \right</span><span class="co">]</span> \delta_{z_i z_j} \,,</span>
<span id="cb20-119"><a href="#cb20-119" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb20-120"><a href="#cb20-120" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb20-121"><a href="#cb20-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-122"><a href="#cb20-122" aria-hidden="true" tabindex="-1"></a>This formula can be motivated in several ways. </span>
<span id="cb20-123"><a href="#cb20-123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-124"><a href="#cb20-124" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**Comparison to random graphs**: $Q$ is a comparison of $a_{ij}$ to the expected number of edges between nodes $i$ and $j$ if edges were placed at random while approximately preserving the degree sequence (This point is surprisingly subtle; see @chodrow2020moments for a discussion of some of the difficulties.). </span>
<span id="cb20-125"><a href="#cb20-125" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Dynamical stability**: $Q$ is a measure of the tendency of random walks on the graph $G$ to stay within the same community; see @delvenne2010stability. </span>
<span id="cb20-126"><a href="#cb20-126" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**Statistical inference**: $Q$ is a term in the objective function for a statistical inference task in which we try to infer the labels $\mathbf{z}$ from the graph structure; see @newman2016equivalence.</span>
<span id="cb20-127"><a href="#cb20-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-128"><a href="#cb20-128" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-129"><a href="#cb20-129" aria-hidden="true" tabindex="-1"></a>We often informally say that the network is *assortative* or *has modular structure* when $Q$ is substantially larger than 0. <span class="co">[</span><span class="ot">The question of what counts as "substantially larger" can be tricky; for example; see discussion in @zhang2014scalable for cases in which Erdős–Rényi random graphs can have high modularity with respect to a carefully-chosen partition.</span><span class="co">]</span>{.aside} </span>
<span id="cb20-130"><a href="#cb20-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-131"><a href="#cb20-131" aria-hidden="true" tabindex="-1"></a>Networkx implements a function to compute the modularity, but it's not difficult to implement our own either. We'll structure our function to accept a vector of characters giving the class labels.  </span>
<span id="cb20-132"><a href="#cb20-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-135"><a href="#cb20-135" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb20-136"><a href="#cb20-136" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> modularity(G, z):</span>
<span id="cb20-137"><a href="#cb20-137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-138"><a href="#cb20-138" aria-hidden="true" tabindex="-1"></a>    <span class="co"># converts z from a dict to an array if it isn't one already</span></span>
<span id="cb20-139"><a href="#cb20-139" aria-hidden="true" tabindex="-1"></a>    z <span class="op">=</span> labels_to_array(z, G)</span>
<span id="cb20-140"><a href="#cb20-140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-141"><a href="#cb20-141" aria-hidden="true" tabindex="-1"></a>    <span class="co"># form the matrices we need</span></span>
<span id="cb20-142"><a href="#cb20-142" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> nx.to_numpy_array(G)</span>
<span id="cb20-143"><a href="#cb20-143" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> A.<span class="bu">sum</span>(axis <span class="op">=</span> <span class="dv">1</span>)</span>
<span id="cb20-144"><a href="#cb20-144" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> G.number_of_edges()</span>
<span id="cb20-145"><a href="#cb20-145" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-146"><a href="#cb20-146" aria-hidden="true" tabindex="-1"></a>    <span class="co"># computes a matrix whose ith entry is delta_{z_i, z_j}</span></span>
<span id="cb20-147"><a href="#cb20-147" aria-hidden="true" tabindex="-1"></a>    delta <span class="op">=</span> z[:, <span class="va">None</span>] <span class="op">==</span> z[<span class="va">None</span>, :] </span>
<span id="cb20-148"><a href="#cb20-148" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-149"><a href="#cb20-149" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span><span class="op">/</span>(<span class="dv">2</span><span class="op">*</span>m)<span class="op">*</span>((A <span class="op">-</span> np.outer(k, k) <span class="op">/</span> (<span class="dv">2</span> <span class="op">*</span> m))<span class="op">*</span>delta).<span class="bu">sum</span>()</span>
<span id="cb20-150"><a href="#cb20-150" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-151"><a href="#cb20-151" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-152"><a href="#cb20-152" aria-hidden="true" tabindex="-1"></a>Now let's try calling our function to find the modularity of the graph and its labels: </span>
<span id="cb20-155"><a href="#cb20-155" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb20-156"><a href="#cb20-156" aria-hidden="true" tabindex="-1"></a>modularity(G, clusters)</span>
<span id="cb20-157"><a href="#cb20-157" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-158"><a href="#cb20-158" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-159"><a href="#cb20-159" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-160"><a href="#cb20-160" aria-hidden="true" tabindex="-1"></a>Let's do a quick check against the built-in implementation of modularity in Networkx. This implementation works just a bit differently: we need to pass a list of sets in which each set represents a community. </span>
<span id="cb20-161"><a href="#cb20-161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-164"><a href="#cb20-164" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb20-165"><a href="#cb20-165" aria-hidden="true" tabindex="-1"></a>communities <span class="op">=</span> [{node <span class="cf">for</span> node <span class="kw">in</span> G.nodes() <span class="cf">if</span> clusters[node] <span class="op">==</span> i} <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">5</span>)]</span>
<span id="cb20-166"><a href="#cb20-166" aria-hidden="true" tabindex="-1"></a>nx.community.modularity(G, communities)</span>
<span id="cb20-167"><a href="#cb20-167" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-168"><a href="#cb20-168" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-169"><a href="#cb20-169" aria-hidden="true" tabindex="-1"></a>Our answers agree! </span>
<span id="cb20-170"><a href="#cb20-170" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-171"><a href="#cb20-171" aria-hidden="true" tabindex="-1"></a><span class="fu">## The Community Detection Problem</span></span>
<span id="cb20-172"><a href="#cb20-172" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-173"><a href="#cb20-173" aria-hidden="true" tabindex="-1"></a>In the community detection problem, we consider a graph $G$ which we *suspect* to have some interesting modular structure, but we do not have access to the label vector $\mathbf{z}$. Instead, we attempt to *find* a good label vector based on the graph structure itself. <span class="co">[</span><span class="ot">This kind of task is also often called "graph clustering" or "graph partitioning." The idea that networks have community structure and that algorithms can find this structure was popularized by @girvan2002community.</span><span class="co">]</span>{.aside} </span>
<span id="cb20-174"><a href="#cb20-174" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-175"><a href="#cb20-175" aria-hidden="true" tabindex="-1"></a>::: {.column-margin}</span>
<span id="cb20-176"><a href="#cb20-176" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-177"><a href="#cb20-177" aria-hidden="true" tabindex="-1"></a>So, in the community detection problem, we have access to an *unlabeled graph* like this one. </span>
<span id="cb20-180"><a href="#cb20-180" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb20-181"><a href="#cb20-181" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb20-182"><a href="#cb20-182" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb20-183"><a href="#cb20-183" aria-hidden="true" tabindex="-1"></a>draw_graph(G, ax <span class="op">=</span> ax)</span>
<span id="cb20-184"><a href="#cb20-184" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-185"><a href="#cb20-185" aria-hidden="true" tabindex="-1"></a>We'd like to find a "good" partition of the nodes. </span>
<span id="cb20-186"><a href="#cb20-186" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-187"><a href="#cb20-187" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb20-188"><a href="#cb20-188" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-189"><a href="#cb20-189" aria-hidden="true" tabindex="-1"></a><span class="fu">### Community Detection as Optimization</span></span>
<span id="cb20-190"><a href="#cb20-190" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-191"><a href="#cb20-191" aria-hidden="true" tabindex="-1"></a>Many algorithms for community detection are based on the idea of optimization. The goal is to formulate a function $R(G, \mathbf{z})$ with two main properties: </span>
<span id="cb20-192"><a href="#cb20-192" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-193"><a href="#cb20-193" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>$R(G, \mathbf{z})$ is large when $\mathbf{z}$ is a "good" partition of the graph. </span>
<span id="cb20-194"><a href="#cb20-194" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>It is feasible to find a partition of $\mathbf{z}$ which gives a large value of $R(G, \mathbf{z})$ in practical computational time. </span>
<span id="cb20-195"><a href="#cb20-195" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-196"><a href="#cb20-196" aria-hidden="true" tabindex="-1"></a>Roughly, criterion 1 says that we are "optimizing the right thing," while criterion 2 says that "optimizing the right thing" is in fact computationally feasible. Due to its many useful interpretations, the modularity $Q$ has been a very popular choice of objective functions for community detection. In <span class="co">[</span><span class="ot">later notes</span><span class="co">](19-spectral-clustering.qmd)</span>, we'll explore an alternative objective function.  </span>
<span id="cb20-197"><a href="#cb20-197" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-198"><a href="#cb20-198" aria-hidden="true" tabindex="-1"></a><span class="fu">## A Community Detection Algorithm: Greedy Agglomerative Clustering</span></span>
<span id="cb20-199"><a href="#cb20-199" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-200"><a href="#cb20-200" aria-hidden="true" tabindex="-1"></a>Unfortunately, exactly maximizing the modularity is NP-hard <span class="co">[</span><span class="ot">@brandes2007modularity</span><span class="co">]</span>, and so we need to consider tractable heuristic algorithms that we hope may lead us to solutions which are close to optimal. </span>
<span id="cb20-201"><a href="#cb20-201" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-202"><a href="#cb20-202" aria-hidden="true" tabindex="-1"></a>One simple algorithm for heuristic modularity maximization is the *greedy agglomerative clustering* algorithm. The idea is to start with each node in its own community, and then iteratively swap the labels of nodes until no improvement in the modularity can be obtained. An important computational feature of this algorithm is that we don't need to always recalculate the modularity from scratch. Instead, we can simply *update* the modularity with the change that results from swapping a node $h$ from community $x$ to community $y$. Let $\mathbf{z}$ be the label vector before the swap and let $\mathbf{z}'$ be the label vector after the swap. Then, </span>
<span id="cb20-203"><a href="#cb20-203" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-204"><a href="#cb20-204" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb20-205"><a href="#cb20-205" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb20-206"><a href="#cb20-206" aria-hidden="true" tabindex="-1"></a>    Q(G, \mathbf{z}') - Q(G, \mathbf{z}) &amp;=  \frac{1}{2m}\sum_{i\neq j} \left<span class="co">[</span><span class="ot"> a_{ij} - \frac{k_ik_j}{2m} \right</span><span class="co">]</span> \delta_{z_i', z_j'} - \frac{1}{2m}\sum_{i\neq j} \left<span class="co">[</span><span class="ot"> a_{ij} - \frac{k_ik_j}{2m} \right</span><span class="co">]</span> \delta_{z_i, z_j} <span class="sc">\\</span> </span>
<span id="cb20-207"><a href="#cb20-207" aria-hidden="true" tabindex="-1"></a>    &amp;= \frac{1}{2m}\sum_{i\neq j} \left<span class="co">[</span><span class="ot"> a_{ij} - \frac{k_ik_j}{2m} \right</span><span class="co">]</span> \left(\delta_{z_i', z_j'} - \delta_{z_i, z_j}\right)\;.</span>
<span id="cb20-208"><a href="#cb20-208" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb20-209"><a href="#cb20-209" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb20-210"><a href="#cb20-210" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-211"><a href="#cb20-211" aria-hidden="true" tabindex="-1"></a>We only have $\delta_{z_i', z_j'} - \delta_{z_i, z_j} \neq 0$ when either $i$ or $j$ is equal to $h$. If $i = h$, then $z_i = x$, $z_i' = y$, and $z_j' = z_j$ for all $j \neq h$. So, </span>
<span id="cb20-212"><a href="#cb20-212" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-213"><a href="#cb20-213" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb20-214"><a href="#cb20-214" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb20-215"><a href="#cb20-215" aria-hidden="true" tabindex="-1"></a>    Q(G, \mathbf{z}') - Q(G, \mathbf{z}) &amp;= \frac{1}{2m}\left(\sum_{j\neq h} \left<span class="co">[</span><span class="ot"> a_{hj} - \frac{k_hk_j}{2m} \right</span><span class="co">]</span> \left(\delta_{y, z_j} - \delta_{x, z_j}\right) + \sum_{i\neq h} \left<span class="co">[</span><span class="ot"> a_{ih} - \frac{k_ik_h}{2m} \right</span><span class="co">]</span> \left(\delta_{z_i, y} - \delta_{z_i, x}\right) \right) <span class="sc">\\</span></span>
<span id="cb20-216"><a href="#cb20-216" aria-hidden="true" tabindex="-1"></a>    &amp;= \frac{1}{m}\left(\sum_{j\neq h} \left<span class="co">[</span><span class="ot"> a_{hj} - \frac{k_hk_j}{2m} \right</span><span class="co">]</span> \left(\delta_{y, z_j} - \delta_{x, z_j}\right)  \right)\;,</span>
<span id="cb20-217"><a href="#cb20-217" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb20-218"><a href="#cb20-218" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb20-219"><a href="#cb20-219" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-220"><a href="#cb20-220" aria-hidden="true" tabindex="-1"></a>where in the second line we have used the fact that the two sums appearing are just re-indexed copies of each other. Here's our implementation: </span>
<span id="cb20-221"><a href="#cb20-221" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-224"><a href="#cb20-224" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb20-225"><a href="#cb20-225" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> greedy_clustering(G, num_steps <span class="op">=</span> <span class="bu">int</span>(<span class="fl">1e4</span>)):</span>
<span id="cb20-226"><a href="#cb20-226" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-227"><a href="#cb20-227" aria-hidden="true" tabindex="-1"></a>    <span class="co"># initialize every node in its own cluster</span></span>
<span id="cb20-228"><a href="#cb20-228" aria-hidden="true" tabindex="-1"></a>    labels <span class="op">=</span> np.arange(G.number_of_nodes()) </span>
<span id="cb20-229"><a href="#cb20-229" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-230"><a href="#cb20-230" aria-hidden="true" tabindex="-1"></a>    <span class="co"># compute the modularity initially -- we'll update it as we go</span></span>
<span id="cb20-231"><a href="#cb20-231" aria-hidden="true" tabindex="-1"></a>    progress <span class="op">=</span> [modularity(G, labels)]</span>
<span id="cb20-232"><a href="#cb20-232" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-233"><a href="#cb20-233" aria-hidden="true" tabindex="-1"></a>    <span class="co"># matrices and vectors we'll need</span></span>
<span id="cb20-234"><a href="#cb20-234" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> G.number_of_edges()</span>
<span id="cb20-235"><a href="#cb20-235" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> nx.to_numpy_array(G)</span>
<span id="cb20-236"><a href="#cb20-236" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> A.<span class="bu">sum</span>(axis <span class="op">=</span> <span class="dv">1</span>)</span>
<span id="cb20-237"><a href="#cb20-237" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-238"><a href="#cb20-238" aria-hidden="true" tabindex="-1"></a>    <span class="co"># main loop</span></span>
<span id="cb20-239"><a href="#cb20-239" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(num_steps):</span>
<span id="cb20-240"><a href="#cb20-240" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-241"><a href="#cb20-241" aria-hidden="true" tabindex="-1"></a>        <span class="co"># pick two nodes at random and retrieve their labels</span></span>
<span id="cb20-242"><a href="#cb20-242" aria-hidden="true" tabindex="-1"></a>        i, j <span class="op">=</span> np.random.choice(G.number_of_nodes(), <span class="dv">2</span>, replace <span class="op">=</span> <span class="va">False</span>)</span>
<span id="cb20-243"><a href="#cb20-243" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-244"><a href="#cb20-244" aria-hidden="true" tabindex="-1"></a>        <span class="co"># prospective swap is that i will change its label from x to y</span></span>
<span id="cb20-245"><a href="#cb20-245" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> labels[i]</span>
<span id="cb20-246"><a href="#cb20-246" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> labels[j]</span>
<span id="cb20-247"><a href="#cb20-247" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-248"><a href="#cb20-248" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> x <span class="op">==</span> y: </span>
<span id="cb20-249"><a href="#cb20-249" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb20-250"><a href="#cb20-250" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-251"><a href="#cb20-251" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>: </span>
<span id="cb20-252"><a href="#cb20-252" aria-hidden="true" tabindex="-1"></a>            <span class="co"># compute the change in modularity of the prospective swap</span></span>
<span id="cb20-253"><a href="#cb20-253" aria-hidden="true" tabindex="-1"></a>            change_vec <span class="op">=</span> <span class="dv">1</span><span class="op">/</span>m <span class="op">*</span>  ((A[i] <span class="op">-</span> k[i]<span class="op">*</span>k<span class="op">/</span>(<span class="dv">2</span><span class="op">*</span>m))<span class="op">*</span>(<span class="dv">1</span><span class="op">*</span>(y <span class="op">==</span> labels) <span class="op">-</span> <span class="dv">1</span><span class="op">*</span>(x <span class="op">==</span> labels)))</span>
<span id="cb20-254"><a href="#cb20-254" aria-hidden="true" tabindex="-1"></a>            change_vec[i] <span class="op">=</span> <span class="dv">0</span> <span class="co"># zero out the term corresponding to i</span></span>
<span id="cb20-255"><a href="#cb20-255" aria-hidden="true" tabindex="-1"></a>            change <span class="op">=</span> change_vec.<span class="bu">sum</span>()</span>
<span id="cb20-256"><a href="#cb20-256" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-257"><a href="#cb20-257" aria-hidden="true" tabindex="-1"></a>            <span class="co"># if positive, update the labels and store the new modularity for visualization later</span></span>
<span id="cb20-258"><a href="#cb20-258" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> change <span class="op">&gt;</span> <span class="dv">0</span>: </span>
<span id="cb20-259"><a href="#cb20-259" aria-hidden="true" tabindex="-1"></a>                labels[i] <span class="op">=</span> y</span>
<span id="cb20-260"><a href="#cb20-260" aria-hidden="true" tabindex="-1"></a>                progress.append(progress[<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> change)</span>
<span id="cb20-261"><a href="#cb20-261" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb20-262"><a href="#cb20-262" aria-hidden="true" tabindex="-1"></a>    <span class="co"># postprocessing: we need to convert the labels into a dict for visualization etc. </span></span>
<span id="cb20-263"><a href="#cb20-263" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-264"><a href="#cb20-264" aria-hidden="true" tabindex="-1"></a>    distinct_labels <span class="op">=</span> np.unique(labels)</span>
<span id="cb20-265"><a href="#cb20-265" aria-hidden="true" tabindex="-1"></a>    label_map <span class="op">=</span> {<span class="bu">int</span>(distinct_label) : i <span class="cf">for</span> i, distinct_label <span class="kw">in</span> <span class="bu">enumerate</span>(distinct_labels)}</span>
<span id="cb20-266"><a href="#cb20-266" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-267"><a href="#cb20-267" aria-hidden="true" tabindex="-1"></a>    greedy_clusters <span class="op">=</span> {i : label_map[label] <span class="cf">for</span> i, label <span class="kw">in</span> <span class="bu">enumerate</span>(labels)}</span>
<span id="cb20-268"><a href="#cb20-268" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-269"><a href="#cb20-269" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> greedy_clusters, np.array(progress)</span>
<span id="cb20-270"><a href="#cb20-270" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-271"><a href="#cb20-271" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-272"><a href="#cb20-272" aria-hidden="true" tabindex="-1"></a>Let's run our algorithm...</span>
<span id="cb20-273"><a href="#cb20-273" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-276"><a href="#cb20-276" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb20-277"><a href="#cb20-277" aria-hidden="true" tabindex="-1"></a>greedy_clusters, progress <span class="op">=</span> greedy_clustering(G, num_steps <span class="op">=</span> <span class="bu">int</span>(<span class="fl">1e5</span>))</span>
<span id="cb20-278"><a href="#cb20-278" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-279"><a href="#cb20-279" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-280"><a href="#cb20-280" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-281"><a href="#cb20-281" aria-hidden="true" tabindex="-1"></a>...and visualize how we did. </span>
<span id="cb20-284"><a href="#cb20-284" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb20-285"><a href="#cb20-285" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize <span class="op">=</span> (<span class="dv">7</span>, <span class="fl">3.5</span>))</span>
<span id="cb20-286"><a href="#cb20-286" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-287"><a href="#cb20-287" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].plot(progress)</span>
<span id="cb20-288"><a href="#cb20-288" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].<span class="bu">set</span>(xlabel <span class="op">=</span> <span class="st">"Number of swaps performed"</span>, ylabel <span class="op">=</span> <span class="st">"Modularity"</span>, title <span class="op">=</span> <span class="st">"Progress over swaps"</span>)</span>
<span id="cb20-289"><a href="#cb20-289" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-290"><a href="#cb20-290" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].<span class="bu">set</span>(title <span class="op">=</span> <span class="ss">f"Modularity of greedy partition = </span><span class="sc">{</span>modularity(G, greedy_clusters)<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb20-291"><a href="#cb20-291" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].axis(<span class="st">"off"</span>)</span>
<span id="cb20-292"><a href="#cb20-292" aria-hidden="true" tabindex="-1"></a>draw_graph(G, clusters <span class="op">=</span> greedy_clusters, ax <span class="op">=</span> ax[<span class="dv">1</span>], legend <span class="op">=</span> <span class="va">False</span>)</span>
<span id="cb20-293"><a href="#cb20-293" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-294"><a href="#cb20-294" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-295"><a href="#cb20-295" aria-hidden="true" tabindex="-1"></a>This algorithm required several hundred executed swaps (and thousands of non-executed swaps) in order to achieve the visualized clustering. The clusters shown actually achieve a modularity that is comparable to the original clustering.</span>
<span id="cb20-296"><a href="#cb20-296" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-297"><a href="#cb20-297" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-298"><a href="#cb20-298" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-299"><a href="#cb20-299" aria-hidden="true" tabindex="-1"></a><span class="fu">## Validation of Community Detection Algorithms</span></span>
<span id="cb20-300"><a href="#cb20-300" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-301"><a href="#cb20-301" aria-hidden="true" tabindex="-1"></a>How do we tell whether a community detection algorithm is "good"? One standard way is to compare the clusters found by that algorithm to the true clusters, when such true clusters are available. <span class="co">[</span><span class="ot">Though see @peel2017ground for a discussion of the limitations of this approach.</span><span class="co">]</span>{.aside} Generally, we'd like to use a function $f(\mathbf{z}, \mathbf{z}')$ which measures the similarity between the two label vectors $\mathbf{z}$ and $\mathbf{z}'$; we'd have $f(\mathbf{z}, \mathbf{z}') = 1$ when the two vectors are identical (up to permutations of labels) and $f(\mathbf{z}, \mathbf{z}') = 0$ when the two vectors are completely uncorrelated.  </span>
<span id="cb20-302"><a href="#cb20-302" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-303"><a href="#cb20-303" aria-hidden="true" tabindex="-1"></a>There are several metrics which are appropriate to this task. We'll illustrate one standard such vector, the *normalized mutual information* or NMI. The NMI has formula </span>
<span id="cb20-304"><a href="#cb20-304" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-305"><a href="#cb20-305" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb20-306"><a href="#cb20-306" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb20-307"><a href="#cb20-307" aria-hidden="true" tabindex="-1"></a>    \text{NMI}(\mathbf{z}, \mathbf{z}') = 2 \frac{I(\mathbf{z}, \mathbf{z}')}{H(\mathbf{z}) + H(\mathbf{z}')}\;,</span>
<span id="cb20-308"><a href="#cb20-308" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb20-309"><a href="#cb20-309" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb20-310"><a href="#cb20-310" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-311"><a href="#cb20-311" aria-hidden="true" tabindex="-1"></a>where $I(\mathbf{z}, \mathbf{z}')$ is the mutual information between the two label vectors and $H(\mathbf{z})$ is the entropy of the label vector.</span>
<span id="cb20-312"><a href="#cb20-312" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-313"><a href="#cb20-313" aria-hidden="true" tabindex="-1"></a>To define these two quantities, let $p(z,z')$ be proportion of the time that a randomly picked node has label $z$ in $\mathbf{z}$ and $z'$ in $\mathbf{z'}$: </span>
<span id="cb20-314"><a href="#cb20-314" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb20-315"><a href="#cb20-315" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb20-316"><a href="#cb20-316" aria-hidden="true" tabindex="-1"></a>    p(z,z') = \frac{1}{n} \sum_{i} \delta_{z, z_i}\delta_{z', z_i'}\;.</span>
<span id="cb20-317"><a href="#cb20-317" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb20-318"><a href="#cb20-318" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb20-319"><a href="#cb20-319" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-320"><a href="#cb20-320" aria-hidden="true" tabindex="-1"></a>Also define $p(z) = \sum_{z' \in \mathcal{Z}} p(z,z')$ and $p(z') = \sum_{z \in \mathcal{Z}} p(z,z')$. Then, </span>
<span id="cb20-321"><a href="#cb20-321" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-322"><a href="#cb20-322" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb20-323"><a href="#cb20-323" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb20-324"><a href="#cb20-324" aria-hidden="true" tabindex="-1"></a>    H(\mathbf{z}) &amp;= - \sum_{z \in \mathcal{Z}} p(z) \log p(z) <span class="sc">\\</span> </span>
<span id="cb20-325"><a href="#cb20-325" aria-hidden="true" tabindex="-1"></a>    I(\mathbf{z}, \mathbf{z}') &amp;= \sum_{z \in \mathcal{Z}} \sum_{z' \in \mathcal{Z}} p(z,z') \log \frac{p(z,z')}{p(z)p(z')} \;.</span>
<span id="cb20-326"><a href="#cb20-326" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb20-327"><a href="#cb20-327" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb20-328"><a href="#cb20-328" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-329"><a href="#cb20-329" aria-hidden="true" tabindex="-1"></a>Roughly, $H(\mathbf{z})$ measures the "diversity" of labels represented in $\mathbf{z}$, while $I(\mathbf{z}, \mathbf{z}')$ measures the extent to which knowing a node's label in $\mathbf{z}$ helps you guess its label in $\mathbf{z}'$. <span class="co">[</span><span class="ot">The entropy and mutual information are both quantities introduced by @shannon1948mathematical in a famous paper that launched the field of *information theory*. Information theory is widely used in electrical engineering, statistics, statistical physics, and machine learning. See @cover2006elements for a modern treatment of the topic.</span><span class="co">]</span>{.aside}</span>
<span id="cb20-330"><a href="#cb20-330" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-331"><a href="#cb20-331" aria-hidden="true" tabindex="-1"></a>Here are implementations of the entropy, mutual information, and normalized mutual information:</span>
<span id="cb20-334"><a href="#cb20-334" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb20-335"><a href="#cb20-335" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> H(z, G): </span>
<span id="cb20-336"><a href="#cb20-336" aria-hidden="true" tabindex="-1"></a>    z <span class="op">=</span> labels_to_array(z, G)</span>
<span id="cb20-337"><a href="#cb20-337" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(z)</span>
<span id="cb20-338"><a href="#cb20-338" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> np.array([np.mean(z <span class="op">==</span> i) <span class="cf">for</span> i <span class="kw">in</span> np.unique(z)])</span>
<span id="cb20-339"><a href="#cb20-339" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span>np.<span class="bu">sum</span>(p<span class="op">*</span>np.log(p))</span>
<span id="cb20-340"><a href="#cb20-340" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-341"><a href="#cb20-341" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> I(z, z_, G):</span>
<span id="cb20-342"><a href="#cb20-342" aria-hidden="true" tabindex="-1"></a>    z  <span class="op">=</span> labels_to_array(z, G)</span>
<span id="cb20-343"><a href="#cb20-343" aria-hidden="true" tabindex="-1"></a>    z_ <span class="op">=</span> labels_to_array(z_, G)</span>
<span id="cb20-344"><a href="#cb20-344" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-345"><a href="#cb20-345" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(z)</span>
<span id="cb20-346"><a href="#cb20-346" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-347"><a href="#cb20-347" aria-hidden="true" tabindex="-1"></a>    <span class="co"># we're going to accumulate the joint distribution of labels </span></span>
<span id="cb20-348"><a href="#cb20-348" aria-hidden="true" tabindex="-1"></a>    <span class="co"># in a for-loop. </span></span>
<span id="cb20-349"><a href="#cb20-349" aria-hidden="true" tabindex="-1"></a>    <span class="co"># an alternative would be to form it as an array and then reduce</span></span>
<span id="cb20-350"><a href="#cb20-350" aria-hidden="true" tabindex="-1"></a>    info <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb20-351"><a href="#cb20-351" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> np.unique(z): </span>
<span id="cb20-352"><a href="#cb20-352" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> np.unique(z_): </span>
<span id="cb20-353"><a href="#cb20-353" aria-hidden="true" tabindex="-1"></a>            p <span class="op">=</span> np.mean((z <span class="op">==</span> i) <span class="op">&amp;</span> (z_ <span class="op">==</span> j))</span>
<span id="cb20-354"><a href="#cb20-354" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> p <span class="op">==</span> <span class="dv">0</span>: </span>
<span id="cb20-355"><a href="#cb20-355" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb20-356"><a href="#cb20-356" aria-hidden="true" tabindex="-1"></a>            info <span class="op">+=</span> p<span class="op">*</span>np.log(p<span class="op">/</span>(np.mean(z <span class="op">==</span> i)<span class="op">*</span>np.mean(z_ <span class="op">==</span> j)))</span>
<span id="cb20-357"><a href="#cb20-357" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> info</span>
<span id="cb20-358"><a href="#cb20-358" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-359"><a href="#cb20-359" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> NMI(z, z_, G): </span>
<span id="cb20-360"><a href="#cb20-360" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">2</span><span class="op">*</span>I(z, z_, G)<span class="op">/</span>(H(z, G) <span class="op">+</span> H(z_, G))</span>
<span id="cb20-361"><a href="#cb20-361" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-362"><a href="#cb20-362" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-363"><a href="#cb20-363" aria-hidden="true" tabindex="-1"></a>Now we can assess the performance of our greedy clustering algorithm against ground truth: </span>
<span id="cb20-364"><a href="#cb20-364" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-367"><a href="#cb20-367" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb20-368"><a href="#cb20-368" aria-hidden="true" tabindex="-1"></a>NMI(clusters, greedy_clusters, G)</span>
<span id="cb20-369"><a href="#cb20-369" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-370"><a href="#cb20-370" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-371"><a href="#cb20-371" aria-hidden="true" tabindex="-1"></a>Frequently when assessing a clustering method, it's not really easy to tell out of context whether it's useful or not. We often assess the method against competing methods, and often on several data sets. </span>
<span id="cb20-372"><a href="#cb20-372" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-373"><a href="#cb20-373" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-376"><a href="#cb20-376" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb20-377"><a href="#cb20-377" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_suite(G, clusters):</span>
<span id="cb20-378"><a href="#cb20-378" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-379"><a href="#cb20-379" aria-hidden="true" tabindex="-1"></a>    <span class="co"># retrieve our own greedy clusters and assess</span></span>
<span id="cb20-380"><a href="#cb20-380" aria-hidden="true" tabindex="-1"></a>    greedy_clusters <span class="op">=</span> greedy_clustering(G, num_steps <span class="op">=</span> <span class="bu">int</span>(<span class="fl">1e4</span>))[<span class="dv">0</span>]</span>
<span id="cb20-381"><a href="#cb20-381" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Our greedy agglomeration clustering has NMI = </span><span class="sc">{</span>NMI(clusters, greedy_clusters, G)<span class="sc">:.3f}</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb20-382"><a href="#cb20-382" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-383"><a href="#cb20-383" aria-hidden="true" tabindex="-1"></a>    <span class="co"># now compare against an array of built-in methods. </span></span>
<span id="cb20-384"><a href="#cb20-384" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> cluster_from_partition(partition):</span>
<span id="cb20-385"><a href="#cb20-385" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> {node : i <span class="cf">for</span> i, nodes <span class="kw">in</span> <span class="bu">enumerate</span>(partition) <span class="cf">for</span> node <span class="kw">in</span> nodes}</span>
<span id="cb20-386"><a href="#cb20-386" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-387"><a href="#cb20-387" aria-hidden="true" tabindex="-1"></a>    methods <span class="op">=</span> [nx.community.greedy_modularity_communities, nx.community.asyn_lpa_communities, nx.community.label_propagation_communities, nx.community.louvain_communities]</span>
<span id="cb20-388"><a href="#cb20-388" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-389"><a href="#cb20-389" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> method <span class="kw">in</span> methods:</span>
<span id="cb20-390"><a href="#cb20-390" aria-hidden="true" tabindex="-1"></a>        partition <span class="op">=</span> method(G)</span>
<span id="cb20-391"><a href="#cb20-391" aria-hidden="true" tabindex="-1"></a>        inferred_clusters <span class="op">=</span> cluster_from_partition(partition)</span>
<span id="cb20-392"><a href="#cb20-392" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Method </span><span class="sc">{</span>method<span class="sc">.</span><span class="va">__name__</span><span class="sc">}</span><span class="ss"> has NMI = </span><span class="sc">{</span>NMI(clusters, inferred_clusters, G)<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb20-393"><a href="#cb20-393" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-394"><a href="#cb20-394" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-395"><a href="#cb20-395" aria-hidden="true" tabindex="-1"></a>Let's run our test suite: </span>
<span id="cb20-398"><a href="#cb20-398" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb20-399"><a href="#cb20-399" aria-hidden="true" tabindex="-1"></a>test_suite(G, clusters)</span>
<span id="cb20-400"><a href="#cb20-400" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-401"><a href="#cb20-401" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-402"><a href="#cb20-402" aria-hidden="true" tabindex="-1"></a>Our algorithm appears to be competitive with several of the built-in methods for community detection implemented in Networkx.</span>
<span id="cb20-403"><a href="#cb20-403" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-404"><a href="#cb20-404" aria-hidden="true" tabindex="-1"></a>Would we get different results on another graph? Let's load up our friend the Karate Club graph: </span>
<span id="cb20-405"><a href="#cb20-405" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-408"><a href="#cb20-408" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb20-409"><a href="#cb20-409" aria-hidden="true" tabindex="-1"></a>G_karate <span class="op">=</span> nx.karate_club_graph()</span>
<span id="cb20-410"><a href="#cb20-410" aria-hidden="true" tabindex="-1"></a>G_karate <span class="op">=</span> nx.convert_node_labels_to_integers(G_karate)</span>
<span id="cb20-411"><a href="#cb20-411" aria-hidden="true" tabindex="-1"></a>clusters_karate <span class="op">=</span> nx.get_node_attributes(G_karate, <span class="st">"club"</span>)</span>
<span id="cb20-412"><a href="#cb20-412" aria-hidden="true" tabindex="-1"></a>clusters_karate <span class="op">=</span> {node : <span class="dv">0</span> <span class="cf">if</span> club <span class="op">==</span> <span class="st">"Mr. Hi"</span> <span class="cf">else</span> <span class="dv">1</span> <span class="cf">for</span> node, club <span class="kw">in</span> clusters_karate.items()}</span>
<span id="cb20-413"><a href="#cb20-413" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-414"><a href="#cb20-414" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-415"><a href="#cb20-415" aria-hidden="true" tabindex="-1"></a>Now we'll run our test suite again: </span>
<span id="cb20-416"><a href="#cb20-416" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-419"><a href="#cb20-419" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb20-420"><a href="#cb20-420" aria-hidden="true" tabindex="-1"></a>test_suite(G_karate, clusters_karate)</span>
<span id="cb20-421"><a href="#cb20-421" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-422"><a href="#cb20-422" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-423"><a href="#cb20-423" aria-hidden="true" tabindex="-1"></a>Our algorithm appears to be a bit less impressive in this context, although results may vary due to randomness. A full test suite would often involve averaging the NMI over many runs of each algorithm.  </span>
<span id="cb20-424"><a href="#cb20-424" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-425"><a href="#cb20-425" aria-hidden="true" tabindex="-1"></a><span class="fu">## Other Approaches</span></span>
<span id="cb20-426"><a href="#cb20-426" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-427"><a href="#cb20-427" aria-hidden="true" tabindex="-1"></a>There are many other ways to perform community detection in networks. Sticking to the setting of undirected graphs, we still have lots of choices: </span>
<span id="cb20-428"><a href="#cb20-428" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-429"><a href="#cb20-429" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>We can use a different algorithm to optimize modularity. </span>
<span id="cb20-430"><a href="#cb20-430" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>We can optimize something other than modularity. </span>
<span id="cb20-431"><a href="#cb20-431" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>We can decide that optimization-based community detection is not what we want to do at all---instead we can use methods based on statistical inference and sampling (e.g. @peixoto2019bayesian).</span>
<span id="cb20-432"><a href="#cb20-432" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-433"><a href="#cb20-433" aria-hidden="true" tabindex="-1"></a>There are additional choices and complications introduced when considering directed graphs or graphs in which edges can include more than two nodes. </span>
<span id="cb20-434"><a href="#cb20-434" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-435"><a href="#cb20-435" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-436"><a href="#cb20-436" aria-hidden="true" tabindex="-1"></a><span class="fu">## References</span></span>
</code><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->




</body></html>