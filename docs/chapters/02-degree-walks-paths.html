<!DOCTYPE html>

<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><head>
<meta charset="utf-8"/>
<meta content="quarto-1.6.10" name="generator"/>
<meta content="width=device-width, initial-scale=1.0, user-scalable=yes" name="viewport"/>
<title>2  Degree, Walks, and Paths – Network Science: Models, Mathematics, and Computation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>
<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta content="../" name="quarto:offset"/>
<link href="../chapters/03-components-laplacian.html" rel="next"/>
<link href="../chapters/01-networkrepresentations.html" rel="prev"/>
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet"/>
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-2d9718c933debafcce942f9b212640bc.css" id="quarto-text-highlighting-styles" rel="stylesheet"/>
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet"/>
<link append-hash="true" data-mode="light" href="../site_libs/bootstrap/bootstrap-c1bdd270c1c0708cd2ff05417efafcc5.min.css" id="quarto-bootstrap" rel="stylesheet"/>
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-80H959492S"></script>
<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-80H959492S', { 'anonymize_ip': true});
</script>
<script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>
<link href="../styles.css" rel="stylesheet"/>
</head>
<body class="nav-sidebar floating slimcontent">
<div id="quarto-search-results"></div>
<header class="headroom fixed-top" id="quarto-header">
<nav class="quarto-secondary-nav">
<div class="container-fluid d-flex">
<button aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" class="quarto-btn-toggle btn" data-bs-target=".quarto-sidebar-collapse-item" data-bs-toggle="collapse" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }" role="button" type="button">
<i class="bi bi-layout-text-sidebar-reverse"></i>
</button>
<nav aria-label="breadcrumb" class="quarto-page-breadcrumbs"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../chapters/01-networkrepresentations.html">Network Fundamentals</a></li><li class="breadcrumb-item"><a href="../chapters/02-degree-walks-paths.html"><span class="chapter-number">2</span>  <span class="chapter-title">Degree, Walks, and Paths</span></a></li></ol></nav>
<a aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" class="flex-grow-1" data-bs-target=".quarto-sidebar-collapse-item" data-bs-toggle="collapse" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }" role="navigation">
</a>
</div>
</nav>
</header>
<!-- content -->
<div class="quarto-container page-columns page-rows-contents page-layout-article" id="quarto-content">
<!-- sidebar -->
<nav class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto" id="quarto-sidebar">
<div class="pt-lg-2 mt-2 text-left sidebar-header">
<div class="sidebar-title mb-0 py-0">
<a href="../">Network Science: Models, Mathematics, and Computation</a>
</div>
</div>
<div class="sidebar-menu-container">
<ul class="list-unstyled mt-1">
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../index.html">
<span class="menu-text">Welcome</span></a>
</div>
</li>
<li class="sidebar-item sidebar-item-section">
<div class="sidebar-item-container">
<a aria-expanded="true" class="sidebar-item-text sidebar-link text-start" data-bs-target="#quarto-sidebar-section-1" data-bs-toggle="collapse" role="navigation">
<span class="menu-text">Network Fundamentals</span></a>
<a aria-expanded="true" aria-label="Toggle section" class="sidebar-item-toggle text-start" data-bs-target="#quarto-sidebar-section-1" data-bs-toggle="collapse" role="navigation">
<i class="bi bi-chevron-right ms-2"></i>
</a>
</div>
<ul class="collapse list-unstyled sidebar-section depth1 show" id="quarto-sidebar-section-1">
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/01-networkrepresentations.html">
<span class="menu-text"><span class="chapter-number">1</span>  <span class="chapter-title">Networks and Their Representations</span></span></a>
</div>
</li>
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link active" href="../chapters/02-degree-walks-paths.html">
<span class="menu-text"><span class="chapter-number">2</span>  <span class="chapter-title">Degree, Walks, and Paths</span></span></a>
</div>
</li>
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/03-components-laplacian.html">
<span class="menu-text"><span class="chapter-number">3</span>  <span class="chapter-title">Components and the Graph Laplacian</span></span></a>
</div>
</li>
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/04-centrality.html">
<span class="menu-text"><span class="chapter-number">4</span>  <span class="chapter-title">Centrality and Importance</span></span></a>
</div>
</li>
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/05-viz.html">
<span class="menu-text"><span class="chapter-number">5</span>  <span class="chapter-title">Visualizing Networks and Why You Shouldn’t</span></span></a>
</div>
</li>
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/07-real-world.html">
<span class="menu-text"><span class="chapter-number">6</span>  <span class="chapter-title">Structure of Empirical Networks</span></span></a>
</div>
</li>
</ul>
</li>
<li class="sidebar-item sidebar-item-section">
<div class="sidebar-item-container">
<a aria-expanded="true" class="sidebar-item-text sidebar-link text-start" data-bs-target="#quarto-sidebar-section-2" data-bs-toggle="collapse" role="navigation">
<span class="menu-text">Models of Networks</span></a>
<a aria-expanded="true" aria-label="Toggle section" class="sidebar-item-toggle text-start" data-bs-target="#quarto-sidebar-section-2" data-bs-toggle="collapse" role="navigation">
<i class="bi bi-chevron-right ms-2"></i>
</a>
</div>
<ul class="collapse list-unstyled sidebar-section depth1 show" id="quarto-sidebar-section-2">
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/09-random-graphs.html">
<span class="menu-text"><span class="chapter-number">7</span>  <span class="chapter-title">Random Graphs: Erdős–Rényi</span></span></a>
</div>
</li>
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/10-configuration-model.html">
<span class="menu-text"><span class="chapter-number">8</span>  <span class="chapter-title">Degree-Preserving Random Graphs</span></span></a>
</div>
</li>
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/11-generating-functions.html">
<span class="menu-text"><span class="chapter-number">9</span>  <span class="chapter-title">Probability Generating Functions</span></span></a>
</div>
</li>
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/120-preferential-attachment.html">
<span class="menu-text"><span class="chapter-number">10</span>  <span class="chapter-title">Preferential Attachment and Power Laws</span></span></a>
</div>
</li>
</ul>
</li>
<li class="sidebar-item sidebar-item-section">
<div class="sidebar-item-container">
<a aria-expanded="true" class="sidebar-item-text sidebar-link text-start" data-bs-target="#quarto-sidebar-section-3" data-bs-toggle="collapse" role="navigation">
<span class="menu-text">Network Algorithms</span></a>
<a aria-expanded="true" aria-label="Toggle section" class="sidebar-item-toggle text-start" data-bs-target="#quarto-sidebar-section-3" data-bs-toggle="collapse" role="navigation">
<i class="bi bi-chevron-right ms-2"></i>
</a>
</div>
<ul class="collapse list-unstyled sidebar-section depth1 show" id="quarto-sidebar-section-3">
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/06-modularity.html">
<span class="menu-text"><span class="chapter-number">11</span>  <span class="chapter-title">Homophily, Assortativity, and Modularity</span></span></a>
</div>
</li>
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/13-modularity-maximization.html">
<span class="menu-text"><span class="chapter-number">12</span>  <span class="chapter-title">Community Detection and Modularity Maximization</span></span></a>
</div>
</li>
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/19-spectral-clustering.html">
<span class="menu-text"><span class="chapter-number">13</span>  <span class="chapter-title">Spectral Clustering</span></span></a>
</div>
</li>
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/41-link-prediction.html">
<span class="menu-text"><span class="chapter-number">14</span>  <span class="chapter-title">Link Prediction and Feedback Loops</span></span></a>
</div>
</li>
</ul>
</li>
<li class="sidebar-item sidebar-item-section">
<div class="sidebar-item-container">
<a aria-expanded="true" class="sidebar-item-text sidebar-link text-start" data-bs-target="#quarto-sidebar-section-4" data-bs-toggle="collapse" role="navigation">
<span class="menu-text">Applications and Extensions</span></a>
<a aria-expanded="true" aria-label="Toggle section" class="sidebar-item-toggle text-start" data-bs-target="#quarto-sidebar-section-4" data-bs-toggle="collapse" role="navigation">
<i class="bi bi-chevron-right ms-2"></i>
</a>
</div>
<ul class="collapse list-unstyled sidebar-section depth1 show" id="quarto-sidebar-section-4">
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/50-random-walks.html">
<span class="menu-text"><span class="chapter-number">15</span>  <span class="chapter-title">Random Walks</span></span></a>
</div>
</li>
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/51-agent-based-modeling.html">
<span class="menu-text"><span class="chapter-number">16</span>  <span class="chapter-title">Agent-Based Modeling on Networks</span></span></a>
</div>
</li>
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/53-epidemiology-computational.html">
<span class="menu-text"><span class="chapter-number">17</span>  <span class="chapter-title">Agent-Based Models of Epidemics on Networks</span></span></a>
</div>
</li>
<li class="sidebar-item">
<div class="sidebar-item-container">
<a class="sidebar-item-text sidebar-link" href="../chapters/52-epidemiology.html">
<span class="menu-text"><span class="chapter-number">18</span>  <span class="chapter-title">Epidemic Models on Networks</span></span></a>
</div>
</li>
</ul>
</li>
<li class="sidebar-item sidebar-item-section">
<span class="sidebar-item-text sidebar-link text-start">
<span class="menu-text">Appendices</span></span>
</li>
</ul>
</div>
</nav>
<div class="quarto-sidebar-collapse-item" data-bs-target=".quarto-sidebar-collapse-item" data-bs-toggle="collapse" id="quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
<div class="sidebar margin-sidebar" id="quarto-margin-sidebar">
<nav class="toc-active" id="TOC" role="doc-toc">
<h2 id="toc-title">Contents</h2>
<ul>
<li><a class="nav-link active" data-scroll-target="#degree-of-a-node" href="#degree-of-a-node" id="toc-degree-of-a-node">Degree of a Node</a>
<ul class="collapse">
<li><a class="nav-link" data-scroll-target="#computing-with-degrees" href="#computing-with-degrees" id="toc-computing-with-degrees">Computing with Degrees</a></li>
<li><a class="nav-link" data-scroll-target="#degree-in-directed-graphs" href="#degree-in-directed-graphs" id="toc-degree-in-directed-graphs">Degree in directed graphs</a></li>
<li><a class="nav-link" data-scroll-target="#regular-graphs" href="#regular-graphs" id="toc-regular-graphs">Regular Graphs</a></li>
</ul></li>
<li><a class="nav-link" data-scroll-target="#density-and-sparsity" href="#density-and-sparsity" id="toc-density-and-sparsity">Density and Sparsity</a></li>
<li><a class="nav-link" data-scroll-target="#walks-and-paths" href="#walks-and-paths" id="toc-walks-and-paths">Walks and Paths</a>
<ul class="collapse">
<li><a class="nav-link" data-scroll-target="#connected-graphs" href="#connected-graphs" id="toc-connected-graphs">Connected Graphs</a></li>
<li><a class="nav-link" data-scroll-target="#counting-walks" href="#counting-walks" id="toc-counting-walks">Counting Walks</a></li>
<li><a class="nav-link" data-scroll-target="#paths" href="#paths" id="toc-paths">Paths</a></li>
</ul></li>
<li><a class="nav-link" data-scroll-target="#cyclic-and-acyclic-graphs" href="#cyclic-and-acyclic-graphs" id="toc-cyclic-and-acyclic-graphs">Cyclic and Acyclic graphs</a>
<ul class="collapse">
<li><a class="nav-link" data-scroll-target="#trees" href="#trees" id="toc-trees">Trees</a></li>
</ul></li>
<li><a class="nav-link" data-scroll-target="#references" href="#references" id="toc-references">References</a></li>
</ul>
</nav>
</div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">
<header class="quarto-title-block default" id="title-block-header"><nav aria-label="breadcrumb" class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../chapters/01-networkrepresentations.html">Network Fundamentals</a></li><li class="breadcrumb-item"><a href="../chapters/02-degree-walks-paths.html"><span class="chapter-number">2</span>  <span class="chapter-title">Degree, Walks, and Paths</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">2</span>  <span class="chapter-title">Degree, Walks, and Paths</span></h1>
</div>
<div class="quarto-title-meta">
</div>
</header>
<p><em>Open the live notebook in Google Colab <a href="https://colab.research.google.com/github/network-science-notes/network-science-notes.github.io/blob/main/docs/live-notebooks/02-degree-walks-paths.ipynb">here</a>.</em></p>
<p>In our previous lecture we introduced the fundamentals of different representations of networks: mathematically through graphs and their matrix representations, and computationally through the Python package NetworkX. We’re now ready to start defining and measuring some more complex properties of networks.</p>
<p>The fundamental <em>point</em> of networks is that they are connected – we can “move along the edges” in order to understand the network structure. Our unifying theme in this set of lecture notes is how the idea of “taking steps in the network” unifies some important ideas: node degrees, walks between nodes, and paths between nodes.</p>
<section class="level2 page-columns page-full" id="degree-of-a-node">
<h2 class="anchored" data-anchor-id="degree-of-a-node">Degree of a Node</h2>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div class="theorem definition" id="def-degree">
<p><span class="theorem-title"><strong>Definition 2.1</strong></span> The <em>degree</em> of a node in an undirected network is the number of edges connected to it:  <span class="math display">\[
    k_i = \sum_{j=1}^n A_{ij} \,.
\]</span></p>
<p>We can collect all the node degrees together into the <em>degree sequence</em> <span class="math inline">\(\mathbf{k} \in \mathbb{R}^n\)</span> whose <span class="math inline">\(i\)</span>th entry is <span class="math inline">\(k_i\)</span>, the degree of node <span class="math inline">\(i\)</span>.</p>
</div>
</div>
</div>
</div>
<div class="no-row-height column-margin column-container"><span class="margin-aside callout-margin-content callout-margin-content-simple">A small complication in this definition is that, if there is a self-loop on node <span class="math inline">\(i\)</span>, then <span class="math inline">\(A_{ii} = 2\)</span>. So, when we say that the degree is the number of connected edges, we need to remember that self-loops count twice!</span></div><p>There is an important relationship between the degree sequence and the total number of edges <span class="math inline">\(m\)</span> in the network:</p>
<div class="callout callout-style-simple callout-important no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercise
</div>
</div>
<div class="callout-body-container callout-body">
<p>Give a formula for <span class="math inline">\(m\)</span> in terms of the degree sequence <span class="math inline">\(\mathbf{k}\)</span>.</p>
</div>
</div>

<div class="callout callout-style-simple callout-important no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercise
</div>
</div>
<div class="callout-body-container callout-body">
<p>The <em>mean degree</em> of a network is the average of the degree sequence: <span class="math inline">\(c = \frac{1}{n} \sum_{i = 1}^n k_i\)</span>. Give a formula for the mean degree in terms of <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> alone.</p>
</div>
</div>

<section class="level3 page-columns page-full" id="computing-with-degrees">
<h3 class="anchored" data-anchor-id="computing-with-degrees">Computing with Degrees</h3>
<div class="page-columns page-full"><p>Let’s grab some sample data. We’ll use the <em>Les Miserables</em> network, which is a network of coappearances of characters in the book <em>Les Miserables</em> by Victor Hugo. Nodes represent characters and edges represent characters who appear within the same chapter. This data set is supplied as a built-in example in NetworkX, and for this reason we’ll use it several times throughout these notes. </p><div class="no-row-height column-margin column-container"><span class="margin-aside">This hidden code cell imports several packages and defines an <code>unweight</code> function which we’ll use to convert the network from its native weighted format to an unweighted format.</span></div></div>
<div class="cell" data-execution_count="1" id="d93eaafd">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" data-lst-cap="hidden code ahoy!" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a aria-hidden="true" href="#cb1-1" tabindex="-1"></a><span class="im">from</span> matplotlib <span class="im">import</span> pyplot <span class="im">as</span> plt</span>
<span id="cb1-2"><a aria-hidden="true" href="#cb1-2" tabindex="-1"></a><span class="im">import</span> networkx <span class="im">as</span> nx</span>
<span id="cb1-3"><a aria-hidden="true" href="#cb1-3" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-4"><a aria-hidden="true" href="#cb1-4" tabindex="-1"></a>plt.style.use(<span class="st">'seaborn-v0_8-whitegrid'</span>)</span>
<span id="cb1-5"><a aria-hidden="true" href="#cb1-5" tabindex="-1"></a></span>
<span id="cb1-6"><a aria-hidden="true" href="#cb1-6" tabindex="-1"></a>plot_kwargs <span class="op">=</span> {<span class="st">"node_size"</span> : <span class="dv">100</span>, <span class="st">"edgecolors"</span> : <span class="st">'white'</span>, <span class="st">"node_color"</span> : <span class="st">"steelblue"</span>, <span class="st">"width"</span> : <span class="fl">0.5</span>, <span class="st">"edge_color"</span> : <span class="st">"darkgrey"</span>}</span>
<span id="cb1-7"><a aria-hidden="true" href="#cb1-7" tabindex="-1"></a><span class="co"># This is a coding exercise in the live notes.</span></span>
<span id="cb1-8"><a aria-hidden="true" href="#cb1-8" tabindex="-1"></a></span>
<span id="cb1-9"><a aria-hidden="true" href="#cb1-9" tabindex="-1"></a><span class="kw">def</span> unweight(G):</span>
<span id="cb1-10"><a aria-hidden="true" href="#cb1-10" tabindex="-1"></a>    <span class="cf">for</span> source, target <span class="kw">in</span> G.edges():</span>
<span id="cb1-11"><a aria-hidden="true" href="#cb1-11" tabindex="-1"></a>        G[source][target][<span class="st">'weight'</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb1-12"><a aria-hidden="true" href="#cb1-12" tabindex="-1"></a>    <span class="cf">return</span> G</span></code><button class="code-copy-button" title="Copy to Clipboard"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Here’s how this network looks:</p>
<div class="cell page-columns page-full" data-execution_count="2" data-out.width="80%" id="cell-fig-lesmis">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" data-cap-location="margin" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a aria-hidden="true" href="#cb2-1" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>, figsize <span class="op">=</span> (<span class="dv">7</span>, <span class="dv">4</span>))</span>
<span id="cb2-2"><a aria-hidden="true" href="#cb2-2" tabindex="-1"></a>G_LesMis <span class="op">=</span> unweight(nx.les_miserables_graph())</span>
<span id="cb2-3"><a aria-hidden="true" href="#cb2-3" tabindex="-1"></a>nx.draw(G_LesMis, <span class="op">**</span>plot_kwargs)</span></code><button class="code-copy-button" title="Copy to Clipboard"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display page-columns page-full">
<div class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full" data-cap-location="margin" id="fig-lesmis">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-lesmis-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img class="figure-img" height="315" src="02-degree-walks-paths_files/figure-html/fig-lesmis-output-1.png" width="540"/>
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-fig margin-caption" id="fig-lesmis-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure 2.1: A network of coappearances of characters in the book Les Miserables by Victor Hugo. Nodes represent characters and edges represent characters who appear within the same chapter.
</figcaption>
</figure>
</div>
</div>
</div>
<p>Now let’s compute the degree of each node. There are multiple ways to achieve this task: we can work directly using the adjacency matrix, or we can use the built-in NetworkX function <code>nx.degree()</code>.</p>
<div class="page-columns page-full"><p>One way to compute the degrees of the nodes in a graph is to use the adjacency matrix, as directly described by <a class="quarto-xref" href="#def-degree">Definition <span>2.1</span></a>. With convenient functions from NetworkX and NumPy, this is a two-liner: </p><div class="no-row-height column-margin column-container"><span class="margin-aside">For undirected graphs, we could equally do <code>np.sum(A, axis = 0)</code> because <span class="math inline">\(\mathbf{A}\)</span> is a symmetric matrix. When we discuss directed graphs soon, it will become necessary to be careful!</span></div></div>
<div class="cell" data-execution_count="3" id="571a7b85">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a aria-hidden="true" href="#cb3-1" tabindex="-1"></a><span class="co"># computing degrees directly from the adjacency matrix</span></span>
<span id="cb3-2"><a aria-hidden="true" href="#cb3-2" tabindex="-1"></a></span>
<span id="cb3-3"><a aria-hidden="true" href="#cb3-3" tabindex="-1"></a>A <span class="op">=</span> nx.adjacency_matrix(G_LesMis)   <span class="co"># extract the adjacency matrix</span></span>
<span id="cb3-4"><a aria-hidden="true" href="#cb3-4" tabindex="-1"></a>degree_vector <span class="op">=</span> np.<span class="bu">sum</span>(A, axis <span class="op">=</span> <span class="dv">1</span>) <span class="co"># sum the adjacency matrix over rows</span></span>
<span id="cb3-5"><a aria-hidden="true" href="#cb3-5" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The degree vector has shape </span><span class="sc">{</span>degree_vector<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span></code><button class="code-copy-button" title="Copy to Clipboard"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>The degree vector has shape (77,)</code></pre>
</div>
</div>
<p>Networkx also has a helpful built-in function to calculate the complete set of degrees:</p>
<div class="cell" data-execution_count="4" id="60fbcd6d">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a aria-hidden="true" href="#cb5-1" tabindex="-1"></a>degree_view <span class="op">=</span> G_LesMis.degree()</span></code><button class="code-copy-button" title="Copy to Clipboard"><i class="bi"></i></button></pre></div>
</div>
<p>The result is a <code>DegreeView</code> object which behaves much like a Python dictionary (and which can be easily converted to a dictionary using the <code>dict</code> constructor).</p>
<p>Let’s take a moment to compare the first few nodes to make sure that our two methods agree:</p>
<div class="cell" data-execution_count="5" id="19b2b177">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a aria-hidden="true" href="#cb6-1" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb6-2"><a aria-hidden="true" href="#cb6-2" tabindex="-1"></a><span class="cf">for</span> name, degree <span class="kw">in</span> <span class="bu">dict</span>(degree_view).items():</span>
<span id="cb6-3"><a aria-hidden="true" href="#cb6-3" tabindex="-1"></a>    <span class="cf">if</span> i <span class="op">&lt;</span> <span class="dv">5</span>:</span>
<span id="cb6-4"><a aria-hidden="true" href="#cb6-4" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>name<span class="sc">}</span><span class="ss"> has degree: </span><span class="sc">{</span>degree<span class="sc">}</span><span class="ss"> (networkx) and </span><span class="sc">{</span>degree_vector[i]<span class="sc">}</span><span class="ss"> (adjacency matrix)"</span>)</span>
<span id="cb6-5"><a aria-hidden="true" href="#cb6-5" tabindex="-1"></a>        i <span class="op">+=</span> <span class="dv">1</span></span></code><button class="code-copy-button" title="Copy to Clipboard"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Napoleon has degree: 1 (networkx) and 1 (adjacency matrix)
Myriel has degree: 10 (networkx) and 10 (adjacency matrix)
MlleBaptistine has degree: 3 (networkx) and 3 (adjacency matrix)
MmeMagloire has degree: 3 (networkx) and 3 (adjacency matrix)
CountessDeLo has degree: 1 (networkx) and 1 (adjacency matrix)</code></pre>
</div>
</div>
</section>
<section class="level3 page-columns page-full" id="degree-in-directed-graphs">
<h3 class="anchored" data-anchor-id="degree-in-directed-graphs">Degree in directed graphs</h3>
<p>We have to be a little more subtle in how we define degree in a directed network because there is a distinction between in-edges and out-edges in these networks.</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div class="theorem definition" id="def-directeddegree">
<p><span class="theorem-title"><strong>Definition 2.2</strong></span> In a directed network, the <strong>in-degree</strong> is the number of ingoing edges to a node and the <strong>out-degree</strong> is the number of outgoing edges. These are defined by the formulas <span class="math display">\[
    k_i^{\text{in}} = \sum_{j=1}^n A_{ij}
\]</span> and the out-degree is <span class="math display">\[
    k_j^{\text{out}} = \sum_{i=1}^n A_{ij}
\]</span></p>
<p>Just as before, we can also define the in-degree sequence <span class="math inline">\(\mathbf{k}^{\mathrm{in}}\)</span> and out-degree sequence <span class="math inline">\(\mathbf{k}^{\mathrm{out}}\)</span>.</p>
</div>
</div>
</div>
</div>
<p>We will repeat the exercises above for directed networks.</p>
<div class="callout callout-style-simple callout-important no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercise
</div>
</div>
<div class="callout-body-container callout-body">
<ol type="1">
<li>Express the total number of edges <span class="math inline">\(m\)</span> in a directed graph in terms of the degree sequences <span class="math inline">\(\mathbf{k}^{\text{in}}\)</span> and <span class="math inline">\(\mathbf{k}^{\text{out}}\)</span>.</li>
<li>Determine the mean in-degree and mean out-degree of a directed graph in terms of <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span>.</li>
</ol>
</div>
</div>

<p>Let’s see these definitions in action on a directed graph. This time, we’ll use the <em>mention graph</em> from the musical <em>Hamilton</em>. Each node in this graph is a character. There is a directed edge from character <span class="math inline">\(i\)</span> to character <span class="math inline">\(j\)</span> if character <span class="math inline">\(i\)</span> mentions character <span class="math inline">\(j\)</span> in a song.</p>
<div class="cell page-columns page-full" data-execution_count="6" data-out.width="80%" id="cell-fig-hamilton">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" data-cap-location="margin" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a aria-hidden="true" href="#cb8-1" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb8-2"><a aria-hidden="true" href="#cb8-2" tabindex="-1"></a></span>
<span id="cb8-3"><a aria-hidden="true" href="#cb8-3" tabindex="-1"></a><span class="co"># import data for our directed network</span></span>
<span id="cb8-4"><a aria-hidden="true" href="#cb8-4" tabindex="-1"></a>df <span class="op">=</span> pd.read_csv(<span class="st">"https://philchodrow.github.io/PIC16A/homework/HW3-hamilton-data.csv"</span>, </span>
<span id="cb8-5"><a aria-hidden="true" href="#cb8-5" tabindex="-1"></a>names <span class="op">=</span> [<span class="st">"mentioner"</span>, <span class="st">"mentioned"</span>])</span>
<span id="cb8-6"><a aria-hidden="true" href="#cb8-6" tabindex="-1"></a></span>
<span id="cb8-7"><a aria-hidden="true" href="#cb8-7" tabindex="-1"></a>df <span class="op">=</span> df[df[<span class="st">"mentioner"</span>] <span class="op">!=</span> df[<span class="st">"mentioned"</span>]]</span>
<span id="cb8-8"><a aria-hidden="true" href="#cb8-8" tabindex="-1"></a></span>
<span id="cb8-9"><a aria-hidden="true" href="#cb8-9" tabindex="-1"></a>G_Hamilton <span class="op">=</span> nx.from_pandas_edgelist(df, </span>
<span id="cb8-10"><a aria-hidden="true" href="#cb8-10" tabindex="-1"></a>                            source <span class="op">=</span> <span class="st">"mentioner"</span>, </span>
<span id="cb8-11"><a aria-hidden="true" href="#cb8-11" tabindex="-1"></a>                            target <span class="op">=</span> <span class="st">"mentioned"</span>, </span>
<span id="cb8-12"><a aria-hidden="true" href="#cb8-12" tabindex="-1"></a>                            edge_attr<span class="op">=</span><span class="va">None</span>, </span>
<span id="cb8-13"><a aria-hidden="true" href="#cb8-13" tabindex="-1"></a>                            create_using<span class="op">=</span>nx.DiGraph())</span>
<span id="cb8-14"><a aria-hidden="true" href="#cb8-14" tabindex="-1"></a></span>
<span id="cb8-15"><a aria-hidden="true" href="#cb8-15" tabindex="-1"></a>layout <span class="op">=</span> nx.arf_layout(G_Hamilton)</span>
<span id="cb8-16"><a aria-hidden="true" href="#cb8-16" tabindex="-1"></a></span>
<span id="cb8-17"><a aria-hidden="true" href="#cb8-17" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>, figsize <span class="op">=</span> (<span class="dv">10</span>, <span class="dv">7</span>))</span>
<span id="cb8-18"><a aria-hidden="true" href="#cb8-18" tabindex="-1"></a>nx.draw(G_Hamilton, pos <span class="op">=</span> layout,  with_labels <span class="op">=</span> <span class="va">True</span>, edge_color <span class="op">=</span> <span class="st">"darkgrey"</span>, width <span class="op">=</span> <span class="fl">0.5</span>, node_color <span class="op">=</span> <span class="st">"lavender"</span>, edgecolors <span class="op">=</span> <span class="st">"white"</span>)</span>
<span id="cb8-19"><a aria-hidden="true" href="#cb8-19" tabindex="-1"></a></span>
<span id="cb8-20"><a aria-hidden="true" href="#cb8-20" tabindex="-1"></a><span class="co"># This is a coding exercise in the live notes.</span></span>
<span id="cb8-21"><a aria-hidden="true" href="#cb8-21" tabindex="-1"></a></span>
<span id="cb8-22"><a aria-hidden="true" href="#cb8-22" tabindex="-1"></a><span class="co"># Create and print a numpy array of node in-degrees and out-degrees directly from the adjacency matrix</span></span></code><button class="code-copy-button" title="Copy to Clipboard"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display page-columns page-full">
<div class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full" data-cap-location="margin" id="fig-hamilton">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-hamilton-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img class="figure-img" height="537" src="02-degree-walks-paths_files/figure-html/fig-hamilton-output-1.png" width="763"/>
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-fig margin-caption" id="fig-hamilton-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure 2.2: A network of mentions in the musical Hamilton. Nodes represent characters; there is an edge from character <span class="math inline">\(i\)</span> to character <span class="math inline">\(j\)</span> if <span class="math inline">\(i\)</span> mentions <span class="math inline">\(j\)</span>. This data set was collected and publicly shared by <a href="https://newtfire.org/hamilton/">The Hamilton Project</a>.
</figcaption>
</figure>
</div>
</div>
</div>
<p>Let’s calculate the in-degrees of the nodes in the Hamilton network using the adjacency matrix and compare to the networkx built-ins.</p>
<div class="cell" data-execution_count="7" id="5804f864">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a aria-hidden="true" href="#cb9-1" tabindex="-1"></a>A <span class="op">=</span> nx.adjacency_matrix(G_Hamilton)       <span class="co"># grab the adjacency matrix</span></span>
<span id="cb9-2"><a aria-hidden="true" href="#cb9-2" tabindex="-1"></a>in_degree_vector <span class="op">=</span> np.<span class="bu">sum</span>(A, axis <span class="op">=</span> <span class="dv">0</span>)    <span class="co"># manual in-degrees from A</span></span>
<span id="cb9-3"><a aria-hidden="true" href="#cb9-3" tabindex="-1"></a>in_degree_view   <span class="op">=</span> G_Hamilton.in_degree() <span class="co"># networkx builtin</span></span>
<span id="cb9-4"><a aria-hidden="true" href="#cb9-4" tabindex="-1"></a></span>
<span id="cb9-5"><a aria-hidden="true" href="#cb9-5" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb9-6"><a aria-hidden="true" href="#cb9-6" tabindex="-1"></a><span class="cf">for</span> name, degree <span class="kw">in</span> <span class="bu">dict</span>(in_degree_view).items():</span>
<span id="cb9-7"><a aria-hidden="true" href="#cb9-7" tabindex="-1"></a>    <span class="cf">if</span> i <span class="op">&lt;</span> <span class="dv">5</span>:</span>
<span id="cb9-8"><a aria-hidden="true" href="#cb9-8" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>name<span class="sc">}</span><span class="ss"> has degree: </span><span class="sc">{</span>degree<span class="sc">}</span><span class="ss"> (networkx) and </span><span class="sc">{</span>in_degree_vector[i]<span class="sc">}</span><span class="ss"> (adjacency matrix)"</span>)</span>
<span id="cb9-9"><a aria-hidden="true" href="#cb9-9" tabindex="-1"></a>        i <span class="op">+=</span> <span class="dv">1</span></span></code><button class="code-copy-button" title="Copy to Clipboard"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>burr has degree: 13 (networkx) and 13 (adjacency matrix)
hamilton has degree: 14 (networkx) and 14 (adjacency matrix)
weeks has degree: 1 (networkx) and 1 (adjacency matrix)
madison has degree: 4 (networkx) and 4 (adjacency matrix)
jay has degree: 1 (networkx) and 1 (adjacency matrix)</code></pre>
</div>
</div>
<div class="callout callout-style-simple callout-important no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercise
</div>
</div>
<div class="callout-body-container callout-body">
<p>Repeat this calculation and check that you can also compute <em>out</em>-degrees, with a matching result.</p>
</div>
</div>
</section>
<section class="level3 page-columns page-full" id="regular-graphs">
<h3 class="anchored" data-anchor-id="regular-graphs">Regular Graphs</h3>
<p>The degree sequence can contain a lot of information about the graph structure. One important class of graphs has constant degree:</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div class="theorem definition" id="def-regulargraph">
<p><span class="theorem-title"><strong>Definition 2.3</strong></span> A network in which all nodes have the same degree is called a <strong>regular graph</strong> or <strong>regular network</strong>. A regular graph where all nodes have degree <span class="math inline">\(k\)</span> is called <strong><span class="math inline">\(k\)</span>-regular</strong>.</p>
</div>
</div>
</div>
</div>
<p>Some special cases of regular graphs are <strong>lattices</strong> (e.g., a square lattice is 4-regular) and the <strong>complete graph</strong> where every node is connected to every other node (which is <span class="math inline">\((n-1)\)</span>-regular).</p>
<div class="cell page-columns page-full" data-execution_count="8" id="c6bf3fc6">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a aria-hidden="true" href="#cb11-1" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>, figsize <span class="op">=</span> (<span class="dv">2</span>, <span class="dv">2</span>))</span>
<span id="cb11-2"><a aria-hidden="true" href="#cb11-2" tabindex="-1"></a>G <span class="op">=</span> nx.complete_graph(<span class="dv">5</span>)</span>
<span id="cb11-3"><a aria-hidden="true" href="#cb11-3" tabindex="-1"></a>nx.draw(G, <span class="op">**</span>plot_kwargs)</span></code><button class="code-copy-button" title="Copy to Clipboard"><i class="bi"></i></button></pre></div>
</details>
<div class="no-row-height column-margin column-container"><div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img class="figure-img" height="167" src="02-degree-walks-paths_files/figure-html/cell-9-output-1.png" width="168"/></p>
<figcaption>A complete graph on 5 nodes. Each node has degree exactly equal to <span class="math inline">\(5-1 = 4\)</span>.</figcaption>
</figure>
</div>
</div></div></div>
<p>Regular graphs are of great interst in theoretical mathematics and computer science. We don’t <em>usually</em> spend a lot of time studying them in network science because most interesting systems and data sets are not regular.</p>
</section>
</section>
<section class="level2 page-columns page-full" id="density-and-sparsity">
<h2 class="anchored" data-anchor-id="density-and-sparsity">Density and Sparsity</h2>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div class="theorem definition" id="def-density">
<p><span class="theorem-title"><strong>Definition 2.4</strong></span> The <strong>density</strong> or <strong>connectance</strong> <span class="math inline">\(\rho\)</span> of a simple network is the fraction of possible edges that are actually present. That is,</p>
<p><span class="math display">\[
    \rho = \frac{\text{number of edges}}{\text{possible edges}} = \frac{m}{\binom{n}{2}} \,.
\]</span></p>
</div>
</div>
</div>
</div>
<p>One way to interpret density is to think of it as a probability that a pair of nodes picked uniformly at random is connected by an edge.</p>
<div class="page-columns page-full"><p>We can rewrite density in terms of expected degree using our earlier exercises :</p><div class="no-row-height column-margin column-container"><span class="margin-aside">This simplification comes from the binomial coefficient formula <span class="math inline">\(\binom{n}{k} = \frac{n!}{k!(n-k)!}\)</span>. Also, we can notice the cool fact that <span class="math inline">\(n \choose 2\)</span> is equivalent to the sum of the first <span class="math inline">\(n-1\)</span> integers!</span></div></div>
<p><span class="math display">\[
\begin{align}
    \rho &amp;= \frac{m}{\binom{n}{2}} \\
    &amp;= \frac{m}{\frac{1}{2}n(n-1)} \\
    &amp;= \frac{2m}{n(n-1)} \\
    &amp;= \frac{c}{n-1} \,.
\end{align}
\]</span></p>
<p>If a network is sufficiently large, you can approximate the density as <span class="math inline">\(\rho \approx \frac{c}{n}.\)</span></p>
<p>Let’s compute density in network below using three different strategies:</p>
<ul>
<li>Calculating directly using number of edges and number of nodes;</li>
<li>Calculating directly using mean degree and number of nodes;</li>
<li>Using the built-in NetworkX function <code>nx.density()</code>.</li>
</ul>
<div class="cell" data-execution_count="9" id="6e8566b4">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a aria-hidden="true" href="#cb12-1" tabindex="-1"></a><span class="im">from</span> matplotlib <span class="im">import</span> pyplot <span class="im">as</span> plt</span>
<span id="cb12-2"><a aria-hidden="true" href="#cb12-2" tabindex="-1"></a><span class="im">import</span> networkx <span class="im">as</span> nx</span>
<span id="cb12-3"><a aria-hidden="true" href="#cb12-3" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb12-4"><a aria-hidden="true" href="#cb12-4" tabindex="-1"></a>plt.style.use(<span class="st">'seaborn-v0_8-whitegrid'</span>)</span>
<span id="cb12-5"><a aria-hidden="true" href="#cb12-5" tabindex="-1"></a></span>
<span id="cb12-6"><a aria-hidden="true" href="#cb12-6" tabindex="-1"></a><span class="co"># Create an unweighted version of the Les Mis network</span></span>
<span id="cb12-7"><a aria-hidden="true" href="#cb12-7" tabindex="-1"></a>G <span class="op">=</span> G_LesMis</span>
<span id="cb12-8"><a aria-hidden="true" href="#cb12-8" tabindex="-1"></a></span>
<span id="cb12-9"><a aria-hidden="true" href="#cb12-9" tabindex="-1"></a><span class="co"># This is a coding exercise in the live notes.</span></span>
<span id="cb12-10"><a aria-hidden="true" href="#cb12-10" tabindex="-1"></a></span>
<span id="cb12-11"><a aria-hidden="true" href="#cb12-11" tabindex="-1"></a><span class="co"># Calculate density directly using number of edges and number of nodes</span></span>
<span id="cb12-12"><a aria-hidden="true" href="#cb12-12" tabindex="-1"></a></span>
<span id="cb12-13"><a aria-hidden="true" href="#cb12-13" tabindex="-1"></a>n <span class="op">=</span> G.number_of_nodes()</span>
<span id="cb12-14"><a aria-hidden="true" href="#cb12-14" tabindex="-1"></a>m <span class="op">=</span> G.number_of_edges()</span>
<span id="cb12-15"><a aria-hidden="true" href="#cb12-15" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Density using nodes and edges: </span><span class="sc">{</span><span class="dv">2</span><span class="op">*</span>m<span class="op">/</span>(n<span class="op">*</span>(n<span class="op">-</span><span class="dv">1</span>))<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb12-16"><a aria-hidden="true" href="#cb12-16" tabindex="-1"></a></span>
<span id="cb12-17"><a aria-hidden="true" href="#cb12-17" tabindex="-1"></a><span class="co"># Calculate density directly using mean degree and number of nodes</span></span>
<span id="cb12-18"><a aria-hidden="true" href="#cb12-18" tabindex="-1"></a><span class="co"># Hint: you may want to calculate degree from the adjacency matrix so that you can calculate mean using numpy</span></span>
<span id="cb12-19"><a aria-hidden="true" href="#cb12-19" tabindex="-1"></a></span>
<span id="cb12-20"><a aria-hidden="true" href="#cb12-20" tabindex="-1"></a>A <span class="op">=</span> nx.adjacency_matrix(G)</span>
<span id="cb12-21"><a aria-hidden="true" href="#cb12-21" tabindex="-1"></a>degree <span class="op">=</span> np.<span class="bu">sum</span>(A, axis <span class="op">=</span> <span class="dv">1</span>)</span>
<span id="cb12-22"><a aria-hidden="true" href="#cb12-22" tabindex="-1"></a>c <span class="op">=</span> np.mean(degree)</span>
<span id="cb12-23"><a aria-hidden="true" href="#cb12-23" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Calculating using mean degree </span><span class="sc">{</span>c<span class="op">/</span>(n<span class="op">-</span><span class="dv">1</span>)<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb12-24"><a aria-hidden="true" href="#cb12-24" tabindex="-1"></a><span class="co">#----</span></span>
<span id="cb12-25"><a aria-hidden="true" href="#cb12-25" tabindex="-1"></a></span>
<span id="cb12-26"><a aria-hidden="true" href="#cb12-26" tabindex="-1"></a><span class="co"># Use the built-in NetworkX function nx.density()</span></span>
<span id="cb12-27"><a aria-hidden="true" href="#cb12-27" tabindex="-1"></a></span>
<span id="cb12-28"><a aria-hidden="true" href="#cb12-28" tabindex="-1"></a>density <span class="op">=</span> nx.density(G)</span>
<span id="cb12-29"><a aria-hidden="true" href="#cb12-29" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Density with NetworkX built-in: </span><span class="sc">{</span>density<span class="sc">:.4f}</span><span class="ss">"</span>)</span></code><button class="code-copy-button" title="Copy to Clipboard"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Density using nodes and edges: 0.0868
Calculating using mean degree 0.0868
Density with NetworkX built-in: 0.0868</code></pre>
</div>
</div>
<p>Informally, we call a network <em>sparse</em> when it has low density. This is pretty tricky to formally define: how low is “low enough?” There isn’t a universally agreed upon threshold for density below which a real-world network would be considered sparse. However, we can create a definition which applies for certain theoretical models of networks. Many models are defined for graphs on <span class="math inline">\(n\)</span> nodes. If we have a model where we can take a formal limit as <span class="math inline">\(n\)</span> grows large, then such a network is <em>sparse</em> if <span class="math inline">\(\rho \to 0\)</span> as <span class="math inline">\(n \to \infty\)</span>. In this scenario, the mean degree grows (much) more slowly than the number of nodes. We’ll study limiting arguments about sparse graphs much more when we discuss <a href="../chapters/09-random-graphs.html">random graphs</a>.</p>
<div class="callout callout-style-simple callout-important no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercise
</div>
</div>
<div class="callout-body-container callout-body">
<p>Let <span class="math inline">\(\{G_n\}\)</span> be a sequence of networks on <span class="math inline">\(n\)</span> nodes which are <span class="math inline">\(k\)</span>-regular for some fixed constant <span class="math inline">\(k\)</span>. Show that this sequence is sparse in the sense defined above. </p>
</div>
</div>
<div class="no-row-height column-margin column-container"><span class="margin-aside callout-margin-content callout-margin-content-simple">There is a small cheat in this problem statement, since if <span class="math inline">\(k\)</span> and <span class="math inline">\(n\)</span> are both odd then it is not possible to form a valid network (since <span class="math inline">\(kn = 2m\)</span>, <span class="math inline">\(kn\)</span> must always ben even). This kind of detail does not usually pose difficulties in the study of sparse network.</span></div>
</section>
<section class="level2 page-columns page-full" id="walks-and-paths">
<h2 class="anchored" data-anchor-id="walks-and-paths">Walks and Paths</h2>
<p>We may like to know if it it is possible to reach one node from another by traversing edges. For this task, we introduce the notion of a <em>walk</em>.</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div class="theorem definition" id="def-walk">
<p><span class="theorem-title"><strong>Definition 2.5</strong></span> A <strong>walk</strong> of length <span class="math inline">\(k \geq 2\)</span> is a set of edges <span class="math inline">\(\{ (i_1,j_1), (i_2, j_2), \dots, (i_k, j_k)\}\)</span> with the property that <span class="math inline">\(i_l = j_{l-1}\)</span> for each <span class="math inline">\(2 \leq l \leq k\)</span>. We say this is a walk from node <span class="math inline">\(i_1\)</span> to node <span class="math inline">\(j_k.\)</span></p>
<p>The <strong>length</strong> of a walk is the number of edges it contains.</p>
<p>A single edge <span class="math inline">\((i,j)\)</span> is always considered a walk of length 1 from <span class="math inline">\(i\)</span> to <span class="math inline">\(j\)</span>.</p>
</div>
</div>
</div>
</div>
<div class="cell page-columns page-full" data-execution_count="10" data-out.width="80%" id="cell-fig-walk-nonexample">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" data-cap-location="margin" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a aria-hidden="true" href="#cb14-1" tabindex="-1"></a><span class="im">from</span> matplotlib <span class="im">import</span> pyplot <span class="im">as</span> plt</span>
<span id="cb14-2"><a aria-hidden="true" href="#cb14-2" tabindex="-1"></a><span class="im">import</span> networkx <span class="im">as</span> nx</span>
<span id="cb14-3"><a aria-hidden="true" href="#cb14-3" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb14-4"><a aria-hidden="true" href="#cb14-4" tabindex="-1"></a>plt.style.use(<span class="st">'seaborn-v0_8-whitegrid'</span>)</span>
<span id="cb14-5"><a aria-hidden="true" href="#cb14-5" tabindex="-1"></a></span>
<span id="cb14-6"><a aria-hidden="true" href="#cb14-6" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>, figsize <span class="op">=</span> (<span class="dv">3</span>, <span class="dv">3</span>))</span>
<span id="cb14-7"><a aria-hidden="true" href="#cb14-7" tabindex="-1"></a></span>
<span id="cb14-8"><a aria-hidden="true" href="#cb14-8" tabindex="-1"></a>graph_dict <span class="op">=</span> {<span class="dv">1</span>: [<span class="dv">2</span>], <span class="dv">2</span>: [<span class="dv">1</span>, <span class="dv">3</span>], <span class="dv">3</span>:[<span class="dv">2</span>], <span class="dv">4</span>:[<span class="dv">5</span>,<span class="dv">6</span>], <span class="dv">7</span>: [<span class="dv">4</span>]}</span>
<span id="cb14-9"><a aria-hidden="true" href="#cb14-9" tabindex="-1"></a>G <span class="op">=</span> nx.Graph(graph_dict) </span>
<span id="cb14-10"><a aria-hidden="true" href="#cb14-10" tabindex="-1"></a>nx.draw(G, with_labels <span class="op">=</span> <span class="va">True</span>, font_color <span class="op">=</span> <span class="st">'white'</span>, font_weight <span class="op">=</span> <span class="st">'bold'</span>, edgecolors <span class="op">=</span> <span class="st">"white"</span>, ax <span class="op">=</span> ax, node_size <span class="op">=</span> <span class="dv">200</span>, font_size <span class="op">=</span> <span class="dv">10</span>, edge_color <span class="op">=</span> <span class="st">"darkgrey"</span>)</span></code><button class="code-copy-button" title="Copy to Clipboard"><i class="bi"></i></button></pre></div>
</details>
<div class="no-row-height column-margin column-container"><div class="cell-output cell-output-display">
<div class="quarto-float quarto-figure quarto-figure-center anchored" data-cap-location="margin" id="fig-walk-nonexample">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-walk-nonexample-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img class="figure-img" height="241" src="02-degree-walks-paths_files/figure-html/fig-walk-nonexample-output-1.png" width="242"/>
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-fig" id="fig-walk-nonexample-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure 2.3: Not all pairs of nodes in this network have a walk between them.
</figcaption>
</figure>
</div>
</div></div></div>
<section class="level3" id="connected-graphs">
<h3 class="anchored" data-anchor-id="connected-graphs">Connected Graphs</h3>
<p>It is not always the case that there exists a walk between two specified nodes, as shown in <a class="quarto-xref" href="#fig-walk-nonexample">Figure <span>2.3</span></a>. In many networks, it’s very important that there exist a walk between any two nodes (think, for example, of a power grid!), and we have a special definition to reflect this:</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div class="theorem definition" id="def-tree">
<p><span class="theorem-title"><strong>Definition 2.6</strong></span> A <strong>connected graph</strong> is a graph with the property that, between every pair of nodes <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>, there exists a walk from <span class="math inline">\(i\)</span> to <span class="math inline">\(j\)</span>.</p>
</div>
</div>
</div>
</div>
<p>There are several ways to determine computationally whether a graph is connected.</p>
<div class="callout callout-style-simple callout-important no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercise
</div>
</div>
<div class="callout-body-container callout-body">
<p>Outline an algorithm for determining whether a simple undirected graph is connected by progressively querying node neighbors. Assume that you know ahead of time how many total nodes exist in the network.</p>
</div>
</div>
</section>
<section class="level3" id="counting-walks">
<h3 class="anchored" data-anchor-id="counting-walks">Counting Walks</h3>
<p>A question that pops up a lot in network analysis is “How many walks of length <span class="math inline">\(r\)</span> exist between nodes <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>?” The adjacency matrix gives a concise way to address this question. First, let’s consider <span class="math inline">\(r=1\)</span>. That’s just the number of edges from node <span class="math inline">\(j\)</span> to <span class="math inline">\(i\)</span>, which is exactly <span class="math inline">\(A_{ij}\)</span>. Said in a slightly more cumbersome way,</p>
<blockquote class="blockquote">
<p>The <span class="math inline">\(ij\)</span>th entry of <span class="math inline">\({\bf A}^1\)</span> counts the number of walks of length 1 from node <span class="math inline">\(j\)</span> to node <span class="math inline">\(i\)</span>.</p>
</blockquote>
<p>This observation generalizes by induction.</p>
<div class="callout callout-style-simple callout-tip no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div class="theorem" id="thm-walks">
<p><span class="theorem-title"><strong>Theorem 2.1 (Counting Walks with Powers of <span class="math inline">\(\mathbf{A}\)</span>)</strong></span> The <span class="math inline">\(ij\)</span>th entry of the matrix <span class="math inline">\({\bf A}^r\)</span> contains the number of walks of length <span class="math inline">\(r\)</span> from <span class="math inline">\(j\)</span> to <span class="math inline">\(i\)</span>.</p>
</div>
</div>
</div>
</div>

<p>There are many applications of this idea:</p>
<div class="callout callout-style-simple callout-important no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercise
</div>
</div>
<div class="callout-body-container callout-body">
<p>What is <span class="math inline">\(\frac{1}{2}\mathrm{trace} \; \mathbf{A}^2\)</span>, in terms of quantities we’ve seen before?</p>
</div>
</div>

<div class="callout callout-style-simple callout-important no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercise
</div>
</div>
<div class="callout-body-container callout-body">
<p>Give a mathematical criterion for a graph to be connected by considering the matrix</p>
<p><span class="math display">\[
\mathbf{M} = \sum_{i = 1}^{n-1} \mathbf{A}^i \,.
\]</span></p>
</div>
</div>

</section>
<section class="level3 page-columns page-full" id="paths">
<h3 class="anchored" data-anchor-id="paths">Paths</h3>
<p>Paths are special walks which do not repeat any edges.</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div class="theorem definition" id="def-path">
<p><span class="theorem-title"><strong>Definition 2.7</strong></span> A <strong>path</strong> is a walk that is not self-intersecting. That is, any edge <span class="math inline">\((i,j)\)</span> shows up in a path at most once.</p>
<p>A <strong>geodesic path</strong> or <strong>shortest path</strong> is from <span class="math inline">\(i\)</span> to <span class="math inline">\(j\)</span> is a path fom <span class="math inline">\(i\)</span> to <span class="math inline">\(j\)</span> of minimum length; i.e. a path such that no other path has shorter length.</p>
<p>The length of a geodesic path is called the <strong>(geodesic) distance</strong> between <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>. If two nodes are not path-connected, their geodesic distance is undefined.</p>
</div>
</div>
</div>
</div>
<p>Here is an example of a geodesic path between two nodes in Zachary’s Karate Club network. The geodesic distance between these two nodes is 5.</p>
<div class="cell page-columns page-full" data-execution_count="11" id="4910670d">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a aria-hidden="true" href="#cb15-1" tabindex="-1"></a><span class="co"># code example adapted from: https://stackoverflow.com/questions/24024411/highlighting-the-shortest-path-in-a-networkx-graph</span></span>
<span id="cb15-2"><a aria-hidden="true" href="#cb15-2" tabindex="-1"></a></span>
<span id="cb15-3"><a aria-hidden="true" href="#cb15-3" tabindex="-1"></a>np.random.seed(<span class="dv">123</span>)</span>
<span id="cb15-4"><a aria-hidden="true" href="#cb15-4" tabindex="-1"></a></span>
<span id="cb15-5"><a aria-hidden="true" href="#cb15-5" tabindex="-1"></a>G <span class="op">=</span> nx.karate_club_graph()</span>
<span id="cb15-6"><a aria-hidden="true" href="#cb15-6" tabindex="-1"></a>pos <span class="op">=</span> nx.spring_layout(G)</span>
<span id="cb15-7"><a aria-hidden="true" href="#cb15-7" tabindex="-1"></a>nx.draw(G,pos, <span class="op">**</span>plot_kwargs)</span>
<span id="cb15-8"><a aria-hidden="true" href="#cb15-8" tabindex="-1"></a></span>
<span id="cb15-9"><a aria-hidden="true" href="#cb15-9" tabindex="-1"></a>path <span class="op">=</span> nx.shortest_path(G, source <span class="op">=</span> <span class="dv">14</span>, target <span class="op">=</span> <span class="dv">16</span>)</span>
<span id="cb15-10"><a aria-hidden="true" href="#cb15-10" tabindex="-1"></a>pos_path <span class="op">=</span> {i: pos[i] <span class="cf">for</span> i <span class="kw">in</span> path}</span>
<span id="cb15-11"><a aria-hidden="true" href="#cb15-11" tabindex="-1"></a>path_edges <span class="op">=</span> <span class="bu">list</span>(<span class="bu">zip</span>(path,path[<span class="dv">1</span>:]))</span>
<span id="cb15-12"><a aria-hidden="true" href="#cb15-12" tabindex="-1"></a>nx.draw_networkx_nodes(G,pos_path,nodelist<span class="op">=</span>path,node_color<span class="op">=</span><span class="st">'steelblue'</span>, node_size <span class="op">=</span> <span class="dv">100</span>, edgecolors <span class="op">=</span> <span class="st">"black"</span>)</span>
<span id="cb15-13"><a aria-hidden="true" href="#cb15-13" tabindex="-1"></a>nx.draw_networkx_edges(G,pos_path,edgelist<span class="op">=</span>path_edges,edge_color<span class="op">=</span><span class="st">'k'</span>,width<span class="op">=</span><span class="dv">1</span>)</span></code><button class="code-copy-button" title="Copy to Clipboard"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display page-columns page-full">
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img class="figure-img" height="499" src="02-degree-walks-paths_files/figure-html/cell-12-output-1.png" width="691"/></p>
<figcaption class="margin-caption">A geodesic path between two nodes in the Karate Club network.</figcaption>
</figure>
</div>
</div>
</div>
<p>Shortest paths are not necessarily unique; there may be more than one path of the same length between two nodes. There exist several algorithms for computing the shortest path between a pair of nodes or between every pair of nodes in a graph.</p>
<ul>
<li>Dijkstra’s algorithm <span class="citation" data-cites="dijkstra2022note">(<a href="#ref-dijkstra2022note" role="doc-biblioref">Dijkstra 1956</a>)</span> is frequently used to compute shortest paths with a single fixed node as the point of origin.</li>
<li>The Floyd-Warshall algorithm <span class="citation" data-cites="rosen2011discrete">(<a href="#ref-rosen2011discrete" role="doc-biblioref">Rosen 2011</a>)</span> is a common choice for computing the shortest path between all pairs of nodes in a graph.</li>
</ul>
<div class="callout callout-style-simple callout-important no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p>Explain briefly why shortest paths are <em>self-avoiding</em>: the same node cannot appear twice in a shortest path.</p>
</div>
</div>
</div>

</section>
</section>
<section class="level2 page-columns page-full" id="cyclic-and-acyclic-graphs">
<h2 class="anchored" data-anchor-id="cyclic-and-acyclic-graphs">Cyclic and Acyclic graphs</h2>
<p>Many algorithms and measures of graph structure reflect the existence of <em>cycles</em> within a graph.</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div class="theorem definition" id="def-cycle">
<p><span class="theorem-title"><strong>Definition 2.8 (Cycles)</strong></span> A <strong>cycle</strong> is a path from a node <span class="math inline">\(i\)</span> to itself.</p>
<p>A network with no cycles is <strong>acyclic</strong>.</p>
</div>
</div>
</div>
</div>
<div class="page-columns page-full"><p></p><div class="no-row-height column-margin column-container"><span class="margin-aside">By definition, self-edges are cycles of length 1. Multigraphs without self-edges can have cycles of length 2. Cycles in simple graphs are always of length 3 or more.</span></div></div>
<div class="callout callout-style-simple callout-important no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercise
</div>
</div>
<div class="callout-body-container callout-body">
<p>How could we use the adjacency matrix <span class="math inline">\(\mathbf{A}\)</span> to compute the number of cycles of length <span class="math inline">\(r\)</span> in a network starting and ending at node <span class="math inline">\(i\)</span>?</p>
</div>
</div>

<p>In some cases, it is useful to check a network to determine whether it contains <em>any</em> cycles. While the adjacency matrix can be used to count cycles of a specific length, it could be quite inefficient to use to detect whether we have a cycle of any length (because we may have to check the diagonal entries of <span class="math inline">\({\bf A}^r\)</span> for all possible cycle lengths <span class="math inline">\(r\)</span>). We can construct a simple algorithm to determine computationally whether a network is cyclic or acyclic. For the purposes of this algorithm, we’ll consider directed graphs; the algorithm can be easily adapted to undirected graphs. Here it is:</p>
<p>While <span class="math inline">\(n &gt; 0\)</span>:</p>
<ul>
<li>Find a node <span class="math inline">\(i\)</span> with no out-edges (i.e. <span class="math inline">\(k_i^{\mathrm{out}} = 0\)</span>).
<ul>
<li>If no such node exists, <em>then the network is cyclic</em>.</li>
</ul></li>
<li>Remove node <span class="math inline">\(i\)</span> and all its edges.</li>
</ul>
<p>If all nodes can be removed this way, <em>then the network is acyclic</em>.</p>
<div class="callout callout-style-simple callout-important no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercise
</div>
</div>
<div class="callout-body-container callout-body">
<p>Give a simple argument for why the algorithm above works. In particular:</p>
<ol type="1">
<li>Why is this algorithm guaranteed to terminate?</li>
<li>Why is this algorithm guaranteed to give the correct answer upon termination?</li>
</ol>
</div>
</div>
<p>Now that we’re convinced that the algorithm works, let’s go ahead and implement it in Python. Our implementation accepts a NetworkX <code>DiGraph</code> object as an argument, returning <code>True</code> if the network is cyclic and <code>False</code> if the network is acyclic.</p>
<div class="cell" data-execution_count="12" id="45875bab">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a aria-hidden="true" href="#cb16-1" tabindex="-1"></a><span class="kw">def</span> is_cyclic(G):</span>
<span id="cb16-2"><a aria-hidden="true" href="#cb16-2" tabindex="-1"></a>    <span class="cf">while</span> G.number_of_nodes() <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb16-3"><a aria-hidden="true" href="#cb16-3" tabindex="-1"></a>        zero_out_degree <span class="op">=</span> [node <span class="cf">for</span> node <span class="kw">in</span> G.nodes <span class="cf">if</span> G.out_degree(node) <span class="op">==</span> <span class="dv">0</span>]</span>
<span id="cb16-4"><a aria-hidden="true" href="#cb16-4" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(zero_out_degree) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb16-5"><a aria-hidden="true" href="#cb16-5" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb16-6"><a aria-hidden="true" href="#cb16-6" tabindex="-1"></a>        G.remove_nodes_from(zero_out_degree)</span>
<span id="cb16-7"><a aria-hidden="true" href="#cb16-7" tabindex="-1"></a>    <span class="cf">else</span>: </span>
<span id="cb16-8"><a aria-hidden="true" href="#cb16-8" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span></code><button class="code-copy-button" title="Copy to Clipboard"><i class="bi"></i></button></pre></div>
</div>
<p>Now let’s test our algorithm on a few examples. First, we’ll construct a random toy directed graph that we know does not possess any cycles by its construction. Indeed, our implemented cycle detector indicates that no cycles are present.</p>
<div class="cell page-columns page-full" data-execution_count="13" data-out.width="80%" id="cell-fig-check-acyclic">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" data-cap-location="margin" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a aria-hidden="true" href="#cb17-1" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Binomial Tree:'</span>, end <span class="op">=</span> <span class="st">" "</span>)</span>
<span id="cb17-2"><a aria-hidden="true" href="#cb17-2" tabindex="-1"></a></span>
<span id="cb17-3"><a aria-hidden="true" href="#cb17-3" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>, figsize <span class="op">=</span> (<span class="dv">3</span>, <span class="dv">3</span>))</span>
<span id="cb17-4"><a aria-hidden="true" href="#cb17-4" tabindex="-1"></a>G_Tree <span class="op">=</span> nx.binomial_tree(<span class="dv">4</span>, create_using <span class="op">=</span> nx.DiGraph)</span>
<span id="cb17-5"><a aria-hidden="true" href="#cb17-5" tabindex="-1"></a>nx.draw(G_Tree,  <span class="op">**</span>plot_kwargs)</span>
<span id="cb17-6"><a aria-hidden="true" href="#cb17-6" tabindex="-1"></a><span class="cf">if</span> is_cyclic(G_Tree): </span>
<span id="cb17-7"><a aria-hidden="true" href="#cb17-7" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"cyclic."</span>)</span>
<span id="cb17-8"><a aria-hidden="true" href="#cb17-8" tabindex="-1"></a><span class="cf">else</span>: </span>
<span id="cb17-9"><a aria-hidden="true" href="#cb17-9" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"acyclic."</span>)</span></code><button class="code-copy-button" title="Copy to Clipboard"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre data-cap-location="margin"><code>Binomial Tree: acyclic.</code></pre>
</div>
<div class="no-row-height column-margin column-container"><div class="cell-output cell-output-display">
<div class="quarto-float quarto-figure quarto-figure-center anchored" data-cap-location="margin" id="fig-check-acyclic">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-check-acyclic-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img class="figure-img" height="241" src="02-degree-walks-paths_files/figure-html/fig-check-acyclic-output-2.png" width="242"/>
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-fig" id="fig-check-acyclic-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure 2.4: The binomial tree, a directed network containing no cycles.
</figcaption>
</figure>
</div>
</div></div></div>
<p>On the other hand, the Hamilton mentions network contains at least one cycle:</p>
<div class="cell page-columns page-full" data-execution_count="14" data-out.width="80%" id="cell-fig-hamilton-again">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" data-cap-location="margin" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a aria-hidden="true" href="#cb19-1" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Hamilton Network:'</span>, end <span class="op">=</span> <span class="st">" "</span>)</span>
<span id="cb19-2"><a aria-hidden="true" href="#cb19-2" tabindex="-1"></a>layout <span class="op">=</span> nx.arf_layout(G_Hamilton)</span>
<span id="cb19-3"><a aria-hidden="true" href="#cb19-3" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>, figsize <span class="op">=</span> (<span class="dv">3</span>, <span class="dv">3</span>))</span>
<span id="cb19-4"><a aria-hidden="true" href="#cb19-4" tabindex="-1"></a>nx.draw(G_Hamilton, layout, <span class="op">**</span>plot_kwargs)</span>
<span id="cb19-5"><a aria-hidden="true" href="#cb19-5" tabindex="-1"></a>is_cyclic(G_Hamilton)</span>
<span id="cb19-6"><a aria-hidden="true" href="#cb19-6" tabindex="-1"></a><span class="cf">if</span> is_cyclic(G_Hamilton): </span>
<span id="cb19-7"><a aria-hidden="true" href="#cb19-7" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"cyclic."</span>)</span>
<span id="cb19-8"><a aria-hidden="true" href="#cb19-8" tabindex="-1"></a><span class="cf">else</span>: </span>
<span id="cb19-9"><a aria-hidden="true" href="#cb19-9" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"acyclic."</span>)</span></code><button class="code-copy-button" title="Copy to Clipboard"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre data-cap-location="margin"><code>Hamilton Network: cyclic.</code></pre>
</div>
<div class="no-row-height column-margin column-container"><div class="cell-output cell-output-display">
<div class="quarto-float quarto-figure quarto-figure-center anchored" data-cap-location="margin" id="fig-hamilton-again">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-hamilton-again-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img class="figure-img" height="241" src="02-degree-walks-paths_files/figure-html/fig-hamilton-again-output-2.png" width="242"/>
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-fig" id="fig-hamilton-again-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure 2.5: The Hamilton mention network, a directed network which contains many cycles.
</figcaption>
</figure>
</div>
</div></div></div>
<p>This algorithm has a nice mathematical consequence. If we label the nodes in an acyclic network according to the order we removed them, we will end up with an adjacency matrix that is <em>strictly upper triangular</em>. This is because each node that is removed could only have out-edges that were already removed previously, i.e., nonzero entries of the <span class="math inline">\(i\)</span>th column could only occur between columns 1 and <span class="math inline">\(i-1\)</span>. There exists at least one such labeling for any acyclic network.</p>
<section class="level3 page-columns page-full" id="trees">
<h3 class="anchored" data-anchor-id="trees">Trees</h3>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div class="theorem definition" id="def-tree">
<p><span class="theorem-title"><strong>Definition 2.9</strong></span> A <strong>tree</strong> is a connected, acyclic network. By “connected”, we mean every node is reachable from every other node by traversing a sequence of edges, i.e., there exists a walk between any two nodes.</p>
<p>Trees can be both directed and undirected. When we refer to <em>trees</em> with no further descriptors, we usually mean undirected trees.</p>
</div>
</div>
</div>
</div>
<p>All trees are necessarily simple graphs, because self- and multiedges would create cycles. Trees always have exactly <span class="math inline">\(n-1\)</span> edges, as can be proven via induction. Furthermore, any connected graph with <span class="math inline">\(n-1\)</span> edges is a tree.</p>
<p>Trees are often drawn as <em>rooted trees</em> with a <em>root node</em> at the top and <em>leaf nodes</em> below. Any node can be chosen as the root of a tree.</p>
<div class="cell page-columns page-full" data-execution_count="15" data-out.width="80%" id="a9afb7b6">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a aria-hidden="true" href="#cb21-1" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">1</span>), (<span class="dv">0</span>,<span class="dv">2</span>), (<span class="dv">1</span>,<span class="dv">3</span>), (<span class="dv">1</span>,<span class="dv">4</span>), (<span class="dv">2</span>,<span class="dv">5</span>), (<span class="dv">2</span>,<span class="dv">6</span>), (<span class="dv">2</span>, <span class="dv">7</span>), (<span class="dv">7</span>, <span class="dv">8</span>)]</span>
<span id="cb21-2"><a aria-hidden="true" href="#cb21-2" tabindex="-1"></a></span>
<span id="cb21-3"><a aria-hidden="true" href="#cb21-3" tabindex="-1"></a>pos <span class="op">=</span> {</span>
<span id="cb21-4"><a aria-hidden="true" href="#cb21-4" tabindex="-1"></a>    <span class="dv">0</span> : (<span class="dv">0</span>, <span class="dv">0</span>),</span>
<span id="cb21-5"><a aria-hidden="true" href="#cb21-5" tabindex="-1"></a>    <span class="dv">1</span> : (<span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>),</span>
<span id="cb21-6"><a aria-hidden="true" href="#cb21-6" tabindex="-1"></a>    <span class="dv">2</span> : (<span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>),</span>
<span id="cb21-7"><a aria-hidden="true" href="#cb21-7" tabindex="-1"></a>    <span class="dv">3</span> : (<span class="op">-</span><span class="fl">1.5</span>, <span class="op">-</span><span class="dv">2</span>),</span>
<span id="cb21-8"><a aria-hidden="true" href="#cb21-8" tabindex="-1"></a>    <span class="dv">4</span> : (<span class="op">-</span><span class="fl">0.5</span>, <span class="op">-</span><span class="dv">2</span>),</span>
<span id="cb21-9"><a aria-hidden="true" href="#cb21-9" tabindex="-1"></a>    <span class="dv">5</span> : (<span class="fl">0.5</span>, <span class="op">-</span><span class="dv">2</span>),</span>
<span id="cb21-10"><a aria-hidden="true" href="#cb21-10" tabindex="-1"></a>    <span class="dv">6</span> : (<span class="fl">1.0</span>, <span class="op">-</span><span class="dv">2</span>), </span>
<span id="cb21-11"><a aria-hidden="true" href="#cb21-11" tabindex="-1"></a>    <span class="dv">7</span> : (<span class="fl">1.5</span>, <span class="op">-</span><span class="dv">2</span>), </span>
<span id="cb21-12"><a aria-hidden="true" href="#cb21-12" tabindex="-1"></a>    <span class="dv">8</span>:  (<span class="fl">1.5</span>, <span class="op">-</span><span class="dv">3</span>)</span>
<span id="cb21-13"><a aria-hidden="true" href="#cb21-13" tabindex="-1"></a>}</span>
<span id="cb21-14"><a aria-hidden="true" href="#cb21-14" tabindex="-1"></a></span>
<span id="cb21-15"><a aria-hidden="true" href="#cb21-15" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>, figsize <span class="op">=</span> (<span class="dv">3</span>, <span class="dv">3</span>))</span>
<span id="cb21-16"><a aria-hidden="true" href="#cb21-16" tabindex="-1"></a>G_Tree <span class="op">=</span> nx.Graph(edges)</span>
<span id="cb21-17"><a aria-hidden="true" href="#cb21-17" tabindex="-1"></a>nx.draw(G_Tree, pos <span class="op">=</span> pos, <span class="op">**</span>plot_kwargs)</span></code><button class="code-copy-button" title="Copy to Clipboard"><i class="bi"></i></button></pre></div>
</details>
<div class="no-row-height column-margin column-container"><div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img class="figure-img" height="241" src="02-degree-walks-paths_files/figure-html/cell-16-output-1.png" width="242"/></p>
<figcaption>A simple rooted tree with 9 nodes.</figcaption>
</figure>
</div>
</div></div></div>
<p>Trees play important roles, especially in math and computer science. Trees have many useful properties that we can exploit for network analysis. One of the most important ones is the uniqueness of paths: there is exactly one path between any pair of nodes (as long as we don’t allow “backtracking”). Many calculations on networks with this property are simple(r).</p>
</section>
</section>
<section class="level2" id="references">
<h2 class="anchored" data-anchor-id="references">References</h2>
<div class="references csl-bib-body hanging-indent" data-entry-spacing="0" id="refs" role="list">
<div class="csl-entry" id="ref-dijkstra2022note" role="listitem">
Dijkstra, Edsger W. 1956. <span>“A Note on Two Problems in Connexion with Graphs.”</span> In <em>Edsger Wybe Dijkstra: His Life, Work, and Legacy</em>, 287–90.
</div>
<div class="csl-entry" id="ref-rosen2011discrete" role="listitem">
Rosen, Kenneth H. 2011. <em>Discrete Mathematics and Its Applications (7th Edition)</em>. William C Brown Publishing.
</div>
</div>
</section>
<p><br/> <br/> <span style="color:grey;">© Heather Zinn Brooks and Phil Chodrow, 2025</span></p></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
<div class="nav-page nav-page-previous">
<a aria-label="Networks and Their Representations" class="pagination-link" href="../chapters/01-networkrepresentations.html">
<i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">1</span>  <span class="chapter-title">Networks and Their Representations</span></span>
</a>
</div>
<div class="nav-page nav-page-next">
<a aria-label="Components and the Graph Laplacian" class="pagination-link" href="../chapters/03-components-laplacian.html">
<span class="nav-page-text"><span class="chapter-number">3</span>  <span class="chapter-title">Components and the Graph Laplacian</span></span> <i class="bi bi-arrow-right-short"></i>
</a>
</div>
</nav>
</div> <!-- /content -->
</body></html>