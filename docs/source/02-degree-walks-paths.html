<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.55">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>3&nbsp; Degree, Walks, and Paths – Network Science: Models, Mathematics, and Computation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../source/03-example.html" rel="next">
<link href="../source/01-example.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-sidebar floating slimcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../source/02-degree-walks-paths.html">Measuring Networks</a></li><li class="breadcrumb-item"><a href="../source/02-degree-walks-paths.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Degree, Walks, and Paths</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">Network Science: Models, Mathematics, and Computation</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Welcome</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Network Fundamentals</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../source/01-networkrepresentations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Networks and their representations</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../source/01-example.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Some Stuff About Networks</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">Measuring Networks</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../source/02-degree-walks-paths.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Degree, Walks, and Paths</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../source/03-example.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Some Stuff About Networks</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true">
 <span class="menu-text">Real-World Networks</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../source/31-power-laws.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Power Law Degree Distributions</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <span class="sidebar-item-text sidebar-link text-start">
 <span class="menu-text">Models of Networks</span></span>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#degree" id="toc-degree" class="nav-link active" data-scroll-target="#degree">Degree</a>
  <ul class="collapse">
  <li><a href="#density-and-sparsity" id="toc-density-and-sparsity" class="nav-link" data-scroll-target="#density-and-sparsity">Density and sparsity</a></li>
  </ul></li>
  <li><a href="#walks-and-paths" id="toc-walks-and-paths" class="nav-link" data-scroll-target="#walks-and-paths">Walks and paths</a></li>
  <li><a href="#cyclic-and-acyclic-graphs" id="toc-cyclic-and-acyclic-graphs" class="nav-link" data-scroll-target="#cyclic-and-acyclic-graphs">Cyclic and acyclic graphs</a>
  <ul class="collapse">
  <li><a href="#trees" id="toc-trees" class="nav-link" data-scroll-target="#trees">Trees</a></li>
  </ul></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../source/02-degree-walks-paths.html">Measuring Networks</a></li><li class="breadcrumb-item"><a href="../source/02-degree-walks-paths.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Degree, Walks, and Paths</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Degree, Walks, and Paths</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>In our previous lecture we introduced the fundamentals of different representations of networks: mathematically through graphs and their matrix representations, and computationally through the Python package NetworkX. We’re now ready to start measuring some properties of different networks.</p>
<p>In this lecture we’ll focus on two different ways to measure features of connectivity in a network. The first is <em>degree</em>, which is a property of a node that gives us information about how many edges are connected to a node. We will also explore the notion of a <em>walk</em>, which tells us something about the ways to traverse between nodes.</p>
<section id="degree" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="degree">Degree</h2>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-degree" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 3.1</strong></span> The <em>degree</em> of a node in an undirected network is the number of edges connected to it. The degree of node <span class="math inline">\(i\)</span> is, equivalently, <span class="math display">\[
    k_i = \sum_{j=1}^n A_{ij} \,.
\]</span></p>
</div>
</div>
</div>
</div>
<p>Unsurprisingly, degree is directly related to the number of edges in an undirected network.</p>
<div class="callout callout-style-simple callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercise
</div>
</div>
<div class="callout-body-container callout-body">
<p>Use degree to calculate the total number of edges in an undirected network.</p>
</div>
</div>
<div class="hide proof solution">
<p><span class="proof-title"><em>Solution</em>. </span>The key here is to notice that degree counts <em>ends</em> of edges (sometimes we call these <em>stubs</em>). This means the total number of stubs will be the sum of the degrees of all the nodes. However, each edge is counted twice (each edge has two stubs), so the number of edges <span class="math inline">\(m\)</span> in an undirected network is</p>
<p><span class="math display">\[
    m = \frac{1}{2}\sum_{i=1^n}k_i = \frac{1}{2}\sum_{i=1}^n \sum_{j=1}^n A_{ij}\,.
\]</span></p>
<p>This relationship between degree and number of edges is a useful fact!</p>
</div>
<div class="callout callout-style-simple callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercise
</div>
</div>
<div class="callout-body-container callout-body">
<p>Calculate the mean degree of a node in an undirected network.</p>
</div>
</div>
<div class="hide proof solution">
<p><span class="proof-title"><em>Solution</em>. </span>Let <span class="math inline">\(c\)</span> represent the mean (or expected) degree of a node in an undirected network. Using the previous exercise, <span class="math display">\[\begin{align}
    c &amp;= \frac{1}{n} \sum_{i = 1}^n k_i \,, \\
    &amp;= \frac{2m}{n} \,.
\end{align}\]</span></p>
</div>
<p>In the code below we</p>
<div id="cell-fig-florentine" class="cell page-columns page-full" data-out.width="80%" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1" data-cap-location="margin"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib <span class="im">import</span> pyplot <span class="im">as</span> plt</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> networkx <span class="im">as</span> nx</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>plt.style.use(<span class="st">'seaborn-v0_8-whitegrid'</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co"># This is a coding exercise in the live notes.</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>G <span class="op">=</span> nx.florentine_families_graph()</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>nx.draw(G, with_labels <span class="op">=</span> <span class="va">True</span>)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Create and print a numpy array of node degrees directly from the adjacency matrix</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="co">#---</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> nx.adjacency_matrix(G)</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(np.<span class="bu">sum</span>(A, axis <span class="op">=</span> <span class="dv">1</span>))</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="co">#---</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the degrees using the built in function in NetworkX. </span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="co">#---</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>degree_vec <span class="op">=</span> nx.degree(G)</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(degree_vec)</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a><span class="co">#----</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre data-cap-location="margin"><code>[1 6 3 3 4 2 3 3 3 2 1 3 4 1 1]
[('Acciaiuoli', 1), ('Medici', 6), ('Castellani', 3), ('Peruzzi', 3), ('Strozzi', 4), ('Barbadori', 2), ('Ridolfi', 3), ('Tornabuoni', 3), ('Albizzi', 3), ('Salviati', 2), ('Pazzi', 1), ('Bischeri', 3), ('Guadagni', 4), ('Ginori', 1), ('Lamberteschi', 1)]</code></pre>
</div>
<div class="cell-output cell-output-display page-columns page-full">
<div id="fig-florentine" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full" data-cap-location="margin">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-florentine-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="02-degree-walks-paths_files/figure-html/fig-florentine-output-2.png" width="691" height="499" class="figure-img">
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-fig margin-caption" id="fig-florentine-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.1: A graph of the marriage relations of fifteenth-century Florentine families (<span class="citation" data-cites="breiger1968cumulated">(<a href="#ref-breiger1968cumulated" role="doc-biblioref"><strong>breiger1968cumulated?</strong></a>)</span>).
</figcaption>
</figure>
</div>
</div>
</div>
<p>We have to be a little more subtle in how we define degree in a directed network because there is a distinction between in-edges and out-edges in these networks.</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-directeddegree" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 3.2</strong></span> In a directed network, the <strong>in-degree</strong> is the number of ingoing edges to a node and the <strong>out-degree</strong> is the number of outgoing edges. That is, the in-degree is defined to be <span class="math display">\[
    k_i^{\text{in}} = \sum_{j=1}^n A_{ij}
\]</span> and the out-degree is <span class="math display">\[
    k_j^{\text{out}} = \sum_{i=1}^n A_{ij}
\]</span></p>
</div>
</div>
</div>
</div>
<p>We will repeat the exercises above for directed networks.</p>
<div class="callout callout-style-simple callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercise
</div>
</div>
<div class="callout-body-container callout-body">
<p>Use degree to calculate the total number of edges in a directed network, and use this to calculate the mean (expected) in-degree and out-degree of a directed network.</p>
</div>
</div>
<div class="hide proof solution">
<p><span class="proof-title"><em>Solution</em>. </span>The number of edges in a directed network is equal to the total number of ingoing (respectively, outgoing) ends of edges, so,</p>
<p><span class="math display">\[
    m = \sum_{i=1}^n k_i^{\text{in}} = \sum_{j=1}^n k_i^{\text{out}} = \sum_{i=1}^n \sum_{j=1}^n A_{ij} \,.
\]</span></p>
<p>This means that the expected in-degree and expected out-degree are also equal:</p>
<p><span class="math display">\[\begin{align}
    c_{\text{in}} &amp;= \frac{1}{n} \sum_{i=1}^n k_i^{\text{in}} \\
     &amp;= \frac{1}{n}\sum_{j=1}^n k_i^{\text{out}} \\
    &amp;= c_{\text{out}} \\
    &amp;= c \,.
\end{align}\]</span></p>
<p>Combining these gives <span class="math inline">\(c = \frac{m}{n}\)</span>.</p>
<p>Notice that this differs by a factor of 2 from the case of undirected networks.</p>
</div>
<blockquote class="blockquote">
<p>Code to calculate degrees in directed networks</p>
</blockquote>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-regulargraph" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 3.3</strong></span> A network in which all nodes have the same degree is called a <strong>regular graph</strong> or <strong>regular network</strong>. A regular graph where all nodes have degree <span class="math inline">\(k\)</span> is called <strong><span class="math inline">\(k\)</span>-regular</strong>.</p>
</div>
</div>
</div>
</div>
<p>Some special cases of regular graphs are <strong>lattices</strong> (e.g., a square lattice is 4-regular) and the <strong>complete graph</strong> where every node is connected to every other node (which is <span class="math inline">\((n-1)\)</span>-regular).</p>
<section id="density-and-sparsity" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="density-and-sparsity">Density and sparsity</h3>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-density" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 3.4</strong></span> The <strong>density</strong> or <strong>connectance</strong> <span class="math inline">\(\rho\)</span> of a simple network is the fraction of possible edges that are actually present. That is,</p>
<p><span class="math display">\[
    \rho = \frac{\text{number of edges}}{\text{possible edges}} = \frac{m}{\binom{n}{2}} \,.
\]</span></p>
</div>
</div>
</div>
</div>
<p>One way to interpret density is to think of it as a probability that a pair of nodes picked uniformly at random is connected by an edge.</p>
<div class="page-columns page-full"><p>We can rewrite density in terms of expected degree using our earlier exercises :</p><div class="no-row-height column-margin column-container"><span class="margin-aside">This simplification comes from the binomial coefficient formula <span class="math inline">\(\binom{n}{k} = \frac{n!}{k!(n-k)!}\)</span>. Also, we can notice the cool fact that <span class="math inline">\(n \choose 2\)</span> is equivalent to the sum of the first <span class="math inline">\(n-1\)</span> integers!</span></div></div>
<p><span class="math display">\[\begin{align}
    \rho &amp;= \frac{m}{\binom{n}{2}} \\
    &amp;= \frac{m}{\frac{1}{2}n(n-1)} \\
    &amp;= \frac{2m}{n(n-1)} \\
    &amp;= \frac{c}{n-1} \,.
\end{align}\]</span></p>
<p>If a network is sufficiently large, you can approximate the density as <span class="math inline">\(\rho \approx \frac{c}{n}.\)</span></p>
<blockquote class="blockquote">
<p>Code to calculate density</p>
</blockquote>
<p>While it’s pretty straightforward to calculate the density of a network, it’s more complicated to determine whether a network is <em>dense</em> or <em>sparse</em>. There isn’t a universally agreed upon threshold for density below which a real-world network would be considered sparse. However, we can create a definition which applies for certain theoretical models of networks. If we have a model where we can take a formal limit, then such a network is <em>sparse</em> if <span class="math inline">\(\rho \to 0\)</span> as <span class="math inline">\(n \to \infty\)</span>. In this scenario, the mean degree grows (much) more slowly than the number of nodes.</p>
</section>
</section>
<section id="walks-and-paths" class="level2">
<h2 class="anchored" data-anchor-id="walks-and-paths">Walks and paths</h2>
<p>We may like to know if it it is possible to reach one node from another by traversing edges. For this task, we introduce the notion of a <em>walk</em>.</p>
<blockquote class="blockquote">
<p>Code showing a walk</p>
</blockquote>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-walk" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 3.5</strong></span> A <strong>walk</strong> of length <span class="math inline">\(k \geq 2\)</span> is a set of edges <span class="math inline">\(\{ (i_1,j_1), (i_2, j_2), \dots, (i_k, j_k)\}\)</span> with the property that <span class="math inline">\(i_l = j_{l-1}\)</span> for each <span class="math inline">\(2 \leq l \leq k\)</span>. We say this is a walk from node <span class="math inline">\(i_1\)</span> to node <span class="math inline">\(j_k.\)</span></p>
<p>The <strong>length</strong> of a walk is the number of edges it contains.</p>
<p>A single edge <span class="math inline">\((i,j)\)</span> is always considered a walk of length 1 from <span class="math inline">\(i\)</span> to <span class="math inline">\(j\)</span>.</p>
</div>
</div>
</div>
</div>
<p>A walk between two nodes is not always well-defined. Consider the example below, where there is no walk from BLAH to BLAH.</p>
<blockquote class="blockquote">
<p>(CODE for network with two components)</p>
</blockquote>
<p>A question that pops up a lot in network analysis is “How many walks of length <span class="math inline">\(r\)</span> exist between nodes <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>?”</p>
<p>The adjacency matrix gives a concise way to address this question. First, let’s consider <span class="math inline">\(r=1\)</span>. That’s just the number of edges from node <span class="math inline">\(j\)</span> to <span class="math inline">\(i\)</span>, which is exactly <span class="math inline">\(A_{ij}\)</span>. Said another way,</p>
<blockquote class="blockquote">
<p>The <span class="math inline">\(ij\)</span>th entry of <span class="math inline">\({\bf A}^1\)</span> counts the number of walks of length 1 from node <span class="math inline">\(j\)</span> to node <span class="math inline">\(i\)</span>.</p>
</blockquote>
<p>This observation generalizes by induction.</p>
<div class="callout callout-style-simple callout-tip no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="thm-walks" class="theorem">
<p><span class="theorem-title"><strong>Theorem 3.1 (Counting Walks)</strong></span> The <span class="math inline">\(ij\)</span>th entry of the matrix <span class="math inline">\({\bf A}^r\)</span> contains the number of walks of length <span class="math inline">\(r\)</span> from <span class="math inline">\(j\)</span> to <span class="math inline">\(i\)</span>.</p>
</div>
</div>
</div>
</div>
<div class="hide proof">
<p><span class="proof-title"><em>Proof</em>. </span>We proceed by induction on walk length <span class="math inline">\(r\)</span>. We discussed the base case above: that is, the <span class="math inline">\(ij\)</span>th entry of the adjacency matrix <span class="math inline">\({\bf A}_{ij} =  {\bf A}_{ij}^1\)</span> gives us walks of length 1, by definition.</p>
<p>Now, suppose that <span class="math inline">\({\bf A}^r\)</span> gives the number of walks of length <span class="math inline">\(r\)</span>; we will show that <span class="math inline">\({\bf A}^{r+1}\)</span> gives the number of walks of length <span class="math inline">\({r+1}\)</span>. By definition, <span class="math inline">\({\bf A}^{r+1} = {\bf A}^{r}{\bf A}.\)</span> Thinking about matrix multiplication as an inner product, we see that the <span class="math inline">\(ij\)</span> entry can be written</p>
<p><span class="math display">\[
    A_{ij}^{r+1} = \sum_{l=1}^n A_{il}^rA_{lj} \,,
\]</span></p>
<p>that is, entry <span class="math inline">\(ij\)</span> comes from summing the componentwise product of the <span class="math inline">\(i\)</span>th row of <span class="math inline">\({\bf A}^r\)</span> with the <span class="math inline">\(j\)</span>th column of <span class="math inline">\({\bf A}.\)</span></p>
<p>The number of walks from node <span class="math inline">\(j\)</span> to <span class="math inline">\(i\)</span> of length <span class="math inline">\(r+1\)</span> is equivalent to the number of walks of length <span class="math inline">\(r\)</span> from <span class="math inline">\(j\)</span> to <span class="math inline">\(l\)</span> multiplied by the number of length <span class="math inline">\(1\)</span> walks from <span class="math inline">\(l\)</span> to <span class="math inline">\(i\)</span>, which is exactly the quantity we have written above. This completes the proof.</p>
</div>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-path" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 3.6</strong></span> A <strong>path</strong> is a walk that is not self-intersecting. That is, any edge <span class="math inline">\((i,j)\)</span> shows up in a path at most once.</p>
<p>A <strong>geodesic path</strong> or <strong>shortest path</strong> is from <span class="math inline">\(i\)</span> to <span class="math inline">\(j\)</span> is a walk fom <span class="math inline">\(i\)</span> to <span class="math inline">\(j\)</span> of minimum length; i.e.&nbsp;a walk such that no other walk has shorter length.</p>
<p>The length of a geodesic path is called the <strong>(geodesic) distance</strong> between <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> If two nodes are not path-connected, their geodesic distance is undefined.</p>
</div>
</div>
</div>
</div>
<p>Remarks</p>
<ul>
<li>Shortest paths are not necessarily unique.</li>
<li>Shortest paths are self-avoiding. This is because if a shortest path intersected itself, this would create a loop which could be removed to create a shorter path.</li>
</ul>
</section>
<section id="cyclic-and-acyclic-graphs" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="cyclic-and-acyclic-graphs">Cyclic and acyclic graphs</h2>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-cyle" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 3.7</strong></span> A <strong>cycle</strong> is a path from a node <span class="math inline">\(i\)</span> to itself.</p>
<p>A network with no cycles is <strong>acyclic</strong>.</p>
</div>
</div>
</div>
</div>
<p>By our definition, self-edges are cycles of length 1.</p>
<div class="callout callout-style-simple callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercise
</div>
</div>
<div class="callout-body-container callout-body">
<p>What is the number of cycles of length <span class="math inline">\(r\)</span> in a network starting and ending at node <span class="math inline">\(i\)</span>?</p>
</div>
</div>
<div class="hide proof solution">
<p><span class="proof-title"><em>Solution</em>. </span>Since a cycle can be represented as a walk from a node <span class="math inline">\(i\)</span> to itself, this is the diagonal element <span class="math inline">\(A_{ii}^r\)</span> from the theorem we proved earlier.</p>
<p>Be careful: this quantity separately counts cycles where the same nodes are visited in a different order. For example, the cycle <span class="math inline">\(1 \to 2 \to 3 \to 1\)</span> is counted separately as the cycle <span class="math inline">\(1 \to 3 \to 2 \to 1.\)</span> To count <em>distinct</em> cycles, you need to divide by the number of combinations.</p>
</div>
<p>While the formula above is very useful to look for cycles of a specific length, it could be quite inefficient to use to detect whether we have a cycle of any length (because we may have to check the diagonal entries of <span class="math inline">\({\bf A}^r\)</span> for all possible cycle lengths <span class="math inline">\(r\)</span>). We can construct a simple algorithm to determine computationally whether a network is cyclic or acyclic.</p>
<p>Use the sketch below to write this algorithm.</p>
<ul>
<li>Find a node with no out-edges.</li>
<li>If no such node exists, the network is cyclic. Otherwise, remove the node and repeat the process.</li>
<li>If all nodes can be removed using the strategy above, the network is acyclic.</li>
</ul>
<blockquote class="blockquote">
<p>Code block here</p>
</blockquote>
<div class="page-columns page-full"><p>This algorithm has a nice mathematical consequence. If we label the nodes in an acyclic network according to the order we removed them, we will end up with an adjacency matrix that is <em>strictly upper triangular</em>.  There exists at least one such labeling for any acyclic network.</p><div class="no-row-height column-margin column-container"><span class="margin-aside">This is because each node that is removed could only have out-edges that were already removed previously, i.e., nonzero entries of the <span class="math inline">\(i\)</span>th column could only occur between columns 1 and <span class="math inline">\(i-1\)</span>.</span></div></div>
<section id="trees" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="trees">Trees</h3>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-tree" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 3.8</strong></span> A <strong>tree</strong> is a connected, acyclic, undirected network. </p>
</div>
</div>
</div>
</div>
<div class="no-row-height column-margin column-container"><span class="margin-aside callout-margin-content callout-margin-content-simple">By “connected”, we mean every node is reachable from every other node by traversing a sequence of edges, i.e., there exists a walk between any two nodes</span></div><p>Trees are often drawn as <em>rooted trees</em> with a <em>root node</em> at the top and <em>leaf nodes</em> below.</p>
<p>A few remarks:</p>
<ul>
<li>Topologically, the root of a tree is not unique</li>
<li>All trees are necessarily simple graphs, because self- and multiedges would create cycles.</li>
</ul>
<p>Trees play important roles, especially in math and computer science. Trees have several useful properties that we can exploit for network analysis:</p>
<ul>
<li>Because trees have no cycles, there is exactly one path between any pair of nodes (as long as we don’t allow ``backtracking’’’). Many calculations on networks with this property are simple(r).</li>
<li>A tree of <span class="math inline">\(n\)</span> nodes has exactly <span class="math inline">\(n-1\)</span> edges. Furthermore, any connected network with <span class="math inline">\(n-1\)</span> edges and <span class="math inline">\(n\)</span> nodes is a tree.</li>
</ul>
</section>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>


</section>

<p><br> <br> <span style="color:grey;">© Heather Zinn Brooks and Phil Chodrow, 2024</span></p></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../source/01-example.html" class="pagination-link" aria-label="Some Stuff About Networks">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Some Stuff About Networks</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../source/03-example.html" class="pagination-link" aria-label="Some Stuff About Networks">
        <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Some Stuff About Networks</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>